
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4820      	ldr	r0, [pc, #128]	; (8000144 <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f000 fb35 	bl	8000740 <__early_init>
 80000d6:	481c      	ldr	r0, [pc, #112]	; (8000148 <endfiniloop+0x8>)
 80000d8:	491c      	ldr	r1, [pc, #112]	; (800014c <endfiniloop+0xc>)
 80000da:	4a1d      	ldr	r2, [pc, #116]	; (8000150 <endfiniloop+0x10>)

080000dc <msloop>:
 80000dc:	4291      	cmp	r1, r2
 80000de:	da02      	bge.n	80000e6 <endmsloop>
 80000e0:	6008      	str	r0, [r1, #0]
 80000e2:	3104      	adds	r1, #4
 80000e4:	e7fa      	b.n	80000dc <msloop>

080000e6 <endmsloop>:
 80000e6:	491b      	ldr	r1, [pc, #108]	; (8000154 <endfiniloop+0x14>)
 80000e8:	4a16      	ldr	r2, [pc, #88]	; (8000144 <endfiniloop+0x4>)

080000ea <psloop>:
 80000ea:	4291      	cmp	r1, r2
 80000ec:	da02      	bge.n	80000f4 <endpsloop>
 80000ee:	6008      	str	r0, [r1, #0]
 80000f0:	3104      	adds	r1, #4
 80000f2:	e7fa      	b.n	80000ea <psloop>

080000f4 <endpsloop>:
 80000f4:	4918      	ldr	r1, [pc, #96]	; (8000158 <endfiniloop+0x18>)
 80000f6:	4a19      	ldr	r2, [pc, #100]	; (800015c <endfiniloop+0x1c>)
 80000f8:	4b19      	ldr	r3, [pc, #100]	; (8000160 <endfiniloop+0x20>)

080000fa <dloop>:
 80000fa:	429a      	cmp	r2, r3
 80000fc:	da04      	bge.n	8000108 <enddloop>
 80000fe:	6808      	ldr	r0, [r1, #0]
 8000100:	6010      	str	r0, [r2, #0]
 8000102:	3104      	adds	r1, #4
 8000104:	3204      	adds	r2, #4
 8000106:	e7f8      	b.n	80000fa <dloop>

08000108 <enddloop>:
 8000108:	2000      	movs	r0, #0
 800010a:	4916      	ldr	r1, [pc, #88]	; (8000164 <endfiniloop+0x24>)
 800010c:	4a16      	ldr	r2, [pc, #88]	; (8000168 <endfiniloop+0x28>)

0800010e <bloop>:
 800010e:	4291      	cmp	r1, r2
 8000110:	da02      	bge.n	8000118 <endbloop>
 8000112:	6008      	str	r0, [r1, #0]
 8000114:	3104      	adds	r1, #4
 8000116:	e7fa      	b.n	800010e <bloop>

08000118 <endbloop>:
 8000118:	f001 faba 	bl	8001690 <__late_init>
 800011c:	4c13      	ldr	r4, [pc, #76]	; (800016c <endfiniloop+0x2c>)
 800011e:	4d14      	ldr	r5, [pc, #80]	; (8000170 <endfiniloop+0x30>)

08000120 <initloop>:
 8000120:	42ac      	cmp	r4, r5
 8000122:	da03      	bge.n	800012c <endinitloop>
 8000124:	6821      	ldr	r1, [r4, #0]
 8000126:	4788      	blx	r1
 8000128:	3404      	adds	r4, #4
 800012a:	e7f9      	b.n	8000120 <initloop>

0800012c <endinitloop>:
 800012c:	f002 fbe8 	bl	8002900 <main>
 8000130:	4c10      	ldr	r4, [pc, #64]	; (8000174 <endfiniloop+0x34>)
 8000132:	4d11      	ldr	r5, [pc, #68]	; (8000178 <endfiniloop+0x38>)

08000134 <finiloop>:
 8000134:	42ac      	cmp	r4, r5
 8000136:	da03      	bge.n	8000140 <endfiniloop>
 8000138:	6821      	ldr	r1, [r4, #0]
 800013a:	4788      	blx	r1
 800013c:	3404      	adds	r4, #4
 800013e:	e7f9      	b.n	8000134 <finiloop>

08000140 <endfiniloop>:
 8000140:	490e      	ldr	r1, [pc, #56]	; (800017c <endfiniloop+0x3c>)
 8000142:	4708      	bx	r1
 8000144:	20000600 	.word	0x20000600
 8000148:	55555555 	.word	0x55555555
 800014c:	20000000 	.word	0x20000000
 8000150:	20000400 	.word	0x20000400
 8000154:	20000400 	.word	0x20000400
 8000158:	080062c0 	.word	0x080062c0
 800015c:	20000600 	.word	0x20000600
 8000160:	200006b8 	.word	0x200006b8
 8000164:	200006b8 	.word	0x200006b8
 8000168:	20001168 	.word	0x20001168
 800016c:	080000c0 	.word	0x080000c0
 8000170:	080000c0 	.word	0x080000c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	08001681 	.word	0x08001681

08000180 <_port_switch>:
 8000180:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000182:	4644      	mov	r4, r8
 8000184:	464d      	mov	r5, r9
 8000186:	4656      	mov	r6, sl
 8000188:	465f      	mov	r7, fp
 800018a:	b4f0      	push	{r4, r5, r6, r7}
 800018c:	466b      	mov	r3, sp
 800018e:	60cb      	str	r3, [r1, #12]
 8000190:	68c3      	ldr	r3, [r0, #12]
 8000192:	469d      	mov	sp, r3
 8000194:	bcf0      	pop	{r4, r5, r6, r7}
 8000196:	46a0      	mov	r8, r4
 8000198:	46a9      	mov	r9, r5
 800019a:	46b2      	mov	sl, r6
 800019c:	46bb      	mov	fp, r7
 800019e:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001a0 <_port_thread_start>:
 80001a0:	b662      	cpsie	i
 80001a2:	1c28      	adds	r0, r5, #0
 80001a4:	47a0      	blx	r4
 80001a6:	2000      	movs	r0, #0
 80001a8:	f000 ffda 	bl	8001160 <chThdExit>

080001ac <_port_switch_from_isr>:
 80001ac:	f000 fb68 	bl	8000880 <chSchDoReschedule>

080001b0 <_port_exit_from_isr>:
 80001b0:	4a01      	ldr	r2, [pc, #4]	; (80001b8 <_port_exit_from_isr+0x8>)
 80001b2:	4b02      	ldr	r3, [pc, #8]	; (80001bc <_port_exit_from_isr+0xc>)
 80001b4:	6013      	str	r3, [r2, #0]
 80001b6:	e7fe      	b.n	80001b6 <_port_exit_from_isr+0x6>
 80001b8:	e000ed04 	.word	0xe000ed04
 80001bc:	80000000 	.word	0x80000000

080001c0 <__aeabi_uidiv>:
 80001c0:	2200      	movs	r2, #0
 80001c2:	0843      	lsrs	r3, r0, #1
 80001c4:	428b      	cmp	r3, r1
 80001c6:	d374      	bcc.n	80002b2 <__aeabi_uidiv+0xf2>
 80001c8:	0903      	lsrs	r3, r0, #4
 80001ca:	428b      	cmp	r3, r1
 80001cc:	d35f      	bcc.n	800028e <__aeabi_uidiv+0xce>
 80001ce:	0a03      	lsrs	r3, r0, #8
 80001d0:	428b      	cmp	r3, r1
 80001d2:	d344      	bcc.n	800025e <__aeabi_uidiv+0x9e>
 80001d4:	0b03      	lsrs	r3, r0, #12
 80001d6:	428b      	cmp	r3, r1
 80001d8:	d328      	bcc.n	800022c <__aeabi_uidiv+0x6c>
 80001da:	0c03      	lsrs	r3, r0, #16
 80001dc:	428b      	cmp	r3, r1
 80001de:	d30d      	bcc.n	80001fc <__aeabi_uidiv+0x3c>
 80001e0:	22ff      	movs	r2, #255	; 0xff
 80001e2:	0209      	lsls	r1, r1, #8
 80001e4:	ba12      	rev	r2, r2
 80001e6:	0c03      	lsrs	r3, r0, #16
 80001e8:	428b      	cmp	r3, r1
 80001ea:	d302      	bcc.n	80001f2 <__aeabi_uidiv+0x32>
 80001ec:	1212      	asrs	r2, r2, #8
 80001ee:	0209      	lsls	r1, r1, #8
 80001f0:	d065      	beq.n	80002be <__aeabi_uidiv+0xfe>
 80001f2:	0b03      	lsrs	r3, r0, #12
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d319      	bcc.n	800022c <__aeabi_uidiv+0x6c>
 80001f8:	e000      	b.n	80001fc <__aeabi_uidiv+0x3c>
 80001fa:	0a09      	lsrs	r1, r1, #8
 80001fc:	0bc3      	lsrs	r3, r0, #15
 80001fe:	428b      	cmp	r3, r1
 8000200:	d301      	bcc.n	8000206 <__aeabi_uidiv+0x46>
 8000202:	03cb      	lsls	r3, r1, #15
 8000204:	1ac0      	subs	r0, r0, r3
 8000206:	4152      	adcs	r2, r2
 8000208:	0b83      	lsrs	r3, r0, #14
 800020a:	428b      	cmp	r3, r1
 800020c:	d301      	bcc.n	8000212 <__aeabi_uidiv+0x52>
 800020e:	038b      	lsls	r3, r1, #14
 8000210:	1ac0      	subs	r0, r0, r3
 8000212:	4152      	adcs	r2, r2
 8000214:	0b43      	lsrs	r3, r0, #13
 8000216:	428b      	cmp	r3, r1
 8000218:	d301      	bcc.n	800021e <__aeabi_uidiv+0x5e>
 800021a:	034b      	lsls	r3, r1, #13
 800021c:	1ac0      	subs	r0, r0, r3
 800021e:	4152      	adcs	r2, r2
 8000220:	0b03      	lsrs	r3, r0, #12
 8000222:	428b      	cmp	r3, r1
 8000224:	d301      	bcc.n	800022a <__aeabi_uidiv+0x6a>
 8000226:	030b      	lsls	r3, r1, #12
 8000228:	1ac0      	subs	r0, r0, r3
 800022a:	4152      	adcs	r2, r2
 800022c:	0ac3      	lsrs	r3, r0, #11
 800022e:	428b      	cmp	r3, r1
 8000230:	d301      	bcc.n	8000236 <__aeabi_uidiv+0x76>
 8000232:	02cb      	lsls	r3, r1, #11
 8000234:	1ac0      	subs	r0, r0, r3
 8000236:	4152      	adcs	r2, r2
 8000238:	0a83      	lsrs	r3, r0, #10
 800023a:	428b      	cmp	r3, r1
 800023c:	d301      	bcc.n	8000242 <__aeabi_uidiv+0x82>
 800023e:	028b      	lsls	r3, r1, #10
 8000240:	1ac0      	subs	r0, r0, r3
 8000242:	4152      	adcs	r2, r2
 8000244:	0a43      	lsrs	r3, r0, #9
 8000246:	428b      	cmp	r3, r1
 8000248:	d301      	bcc.n	800024e <__aeabi_uidiv+0x8e>
 800024a:	024b      	lsls	r3, r1, #9
 800024c:	1ac0      	subs	r0, r0, r3
 800024e:	4152      	adcs	r2, r2
 8000250:	0a03      	lsrs	r3, r0, #8
 8000252:	428b      	cmp	r3, r1
 8000254:	d301      	bcc.n	800025a <__aeabi_uidiv+0x9a>
 8000256:	020b      	lsls	r3, r1, #8
 8000258:	1ac0      	subs	r0, r0, r3
 800025a:	4152      	adcs	r2, r2
 800025c:	d2cd      	bcs.n	80001fa <__aeabi_uidiv+0x3a>
 800025e:	09c3      	lsrs	r3, r0, #7
 8000260:	428b      	cmp	r3, r1
 8000262:	d301      	bcc.n	8000268 <__aeabi_uidiv+0xa8>
 8000264:	01cb      	lsls	r3, r1, #7
 8000266:	1ac0      	subs	r0, r0, r3
 8000268:	4152      	adcs	r2, r2
 800026a:	0983      	lsrs	r3, r0, #6
 800026c:	428b      	cmp	r3, r1
 800026e:	d301      	bcc.n	8000274 <__aeabi_uidiv+0xb4>
 8000270:	018b      	lsls	r3, r1, #6
 8000272:	1ac0      	subs	r0, r0, r3
 8000274:	4152      	adcs	r2, r2
 8000276:	0943      	lsrs	r3, r0, #5
 8000278:	428b      	cmp	r3, r1
 800027a:	d301      	bcc.n	8000280 <__aeabi_uidiv+0xc0>
 800027c:	014b      	lsls	r3, r1, #5
 800027e:	1ac0      	subs	r0, r0, r3
 8000280:	4152      	adcs	r2, r2
 8000282:	0903      	lsrs	r3, r0, #4
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__aeabi_uidiv+0xcc>
 8000288:	010b      	lsls	r3, r1, #4
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	08c3      	lsrs	r3, r0, #3
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__aeabi_uidiv+0xd8>
 8000294:	00cb      	lsls	r3, r1, #3
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0883      	lsrs	r3, r0, #2
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__aeabi_uidiv+0xe4>
 80002a0:	008b      	lsls	r3, r1, #2
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	0843      	lsrs	r3, r0, #1
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__aeabi_uidiv+0xf0>
 80002ac:	004b      	lsls	r3, r1, #1
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	1a41      	subs	r1, r0, r1
 80002b4:	d200      	bcs.n	80002b8 <__aeabi_uidiv+0xf8>
 80002b6:	4601      	mov	r1, r0
 80002b8:	4152      	adcs	r2, r2
 80002ba:	4610      	mov	r0, r2
 80002bc:	4770      	bx	lr
 80002be:	e7ff      	b.n	80002c0 <__aeabi_uidiv+0x100>
 80002c0:	b501      	push	{r0, lr}
 80002c2:	2000      	movs	r0, #0
 80002c4:	f000 f80c 	bl	80002e0 <__aeabi_idiv0>
 80002c8:	bd02      	pop	{r1, pc}
 80002ca:	46c0      	nop			; (mov r8, r8)

080002cc <__aeabi_uidivmod>:
 80002cc:	2900      	cmp	r1, #0
 80002ce:	d0f7      	beq.n	80002c0 <__aeabi_uidiv+0x100>
 80002d0:	b503      	push	{r0, r1, lr}
 80002d2:	f7ff ff75 	bl	80001c0 <__aeabi_uidiv>
 80002d6:	bc0e      	pop	{r1, r2, r3}
 80002d8:	4342      	muls	r2, r0
 80002da:	1a89      	subs	r1, r1, r2
 80002dc:	4718      	bx	r3
 80002de:	46c0      	nop			; (mov r8, r8)

080002e0 <__aeabi_idiv0>:
 80002e0:	4770      	bx	lr
 80002e2:	46c0      	nop			; (mov r8, r8)
	...

080002f0 <tmr.lto_priv.63>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 80002f0:	2201      	movs	r2, #1
 80002f2:	4b01      	ldr	r3, [pc, #4]	; (80002f8 <tmr.lto_priv.63+0x8>)
 80002f4:	701a      	strb	r2, [r3, #0]
}
 80002f6:	4770      	bx	lr
 80002f8:	20000e96 	.word	0x20000e96
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <notify2.lto_priv.65>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000300:	2380      	movs	r3, #128	; 0x80
 8000302:	4a02      	ldr	r2, [pc, #8]	; (800030c <notify2.lto_priv.65+0xc>)
 8000304:	6811      	ldr	r1, [r2, #0]
 8000306:	430b      	orrs	r3, r1
 8000308:	6013      	str	r3, [r2, #0]
}
 800030a:	4770      	bx	lr
 800030c:	40004400 	.word	0x40004400

08000310 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000310:	300f      	adds	r0, #15
 8000312:	d011      	beq.n	8000338 <_port_irq_epilogue+0x28>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000314:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000316:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800031a:	3b20      	subs	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800031c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000320:	2280      	movs	r2, #128	; 0x80
 8000322:	0452      	lsls	r2, r2, #17
 8000324:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000326:	4a06      	ldr	r2, [pc, #24]	; (8000340 <_port_irq_epilogue+0x30>)
 8000328:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800032a:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800032c:	6889      	ldr	r1, [r1, #8]
 800032e:	6892      	ldr	r2, [r2, #8]
 8000330:	4291      	cmp	r1, r2
 8000332:	d802      	bhi.n	800033a <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000334:	4a03      	ldr	r2, [pc, #12]	; (8000344 <_port_irq_epilogue+0x34>)
 8000336:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000338:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800033a:	4a03      	ldr	r2, [pc, #12]	; (8000348 <_port_irq_epilogue+0x38>)
 800033c:	619a      	str	r2, [r3, #24]
 800033e:	e7fb      	b.n	8000338 <_port_irq_epilogue+0x28>
 8000340:	20000f20 	.word	0x20000f20
 8000344:	080001b0 	.word	0x080001b0
 8000348:	080001ad 	.word	0x080001ad
 800034c:	46c0      	nop			; (mov r8, r8)
 800034e:	46c0      	nop			; (mov r8, r8)

08000350 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000350:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000354:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000356:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800035a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800035c:	4770      	bx	lr
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <chCoreAlloc>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000362:	2207      	movs	r2, #7
 8000364:	1dc3      	adds	r3, r0, #7
 8000366:	4393      	bics	r3, r2
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000368:	4906      	ldr	r1, [pc, #24]	; (8000384 <chCoreAlloc+0x24>)
 800036a:	4a07      	ldr	r2, [pc, #28]	; (8000388 <chCoreAlloc+0x28>)
 800036c:	6808      	ldr	r0, [r1, #0]
 800036e:	6812      	ldr	r2, [r2, #0]
 8000370:	1a12      	subs	r2, r2, r0
 8000372:	4293      	cmp	r3, r2
 8000374:	d803      	bhi.n	800037e <chCoreAlloc+0x1e>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8000376:	18c3      	adds	r3, r0, r3
 8000378:	600b      	str	r3, [r1, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037a:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800037c:	4770      	bx	lr

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800037e:	2000      	movs	r0, #0
 8000380:	e7fb      	b.n	800037a <chCoreAlloc+0x1a>
 8000382:	46c0      	nop			; (mov r8, r8)
 8000384:	20000e90 	.word	0x20000e90
 8000388:	200010cc 	.word	0x200010cc
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <wakeup.lto_priv.152>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000390:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000392:	7f03      	ldrb	r3, [r0, #28]
 8000394:	2b07      	cmp	r3, #7
 8000396:	d80c      	bhi.n	80003b2 <wakeup.lto_priv.152+0x22>
 8000398:	4a11      	ldr	r2, [pc, #68]	; (80003e0 <wakeup.lto_priv.152+0x50>)
 800039a:	009b      	lsls	r3, r3, #2
 800039c:	58d3      	ldr	r3, [r2, r3]
 800039e:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80003a0:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80003a2:	6893      	ldr	r3, [r2, #8]
 80003a4:	3301      	adds	r3, #1
 80003a6:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80003a8:	6802      	ldr	r2, [r0, #0]
 80003aa:	6843      	ldr	r3, [r0, #4]
 80003ac:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80003ae:	6802      	ldr	r2, [r0, #0]
 80003b0:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80003b2:	2301      	movs	r3, #1
 80003b4:	425b      	negs	r3, r3
 80003b6:	6203      	str	r3, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80003b8:	2300      	movs	r3, #0
 80003ba:	6882      	ldr	r2, [r0, #8]
 80003bc:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80003be:	4b09      	ldr	r3, [pc, #36]	; (80003e4 <wakeup.lto_priv.152+0x54>)
  do {
    cp = cp->p_next;
 80003c0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80003c2:	6899      	ldr	r1, [r3, #8]
 80003c4:	4291      	cmp	r1, r2
 80003c6:	d2fb      	bcs.n	80003c0 <wakeup.lto_priv.152+0x30>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80003c8:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80003ca:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80003cc:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 80003ce:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80003d0:	6058      	str	r0, [r3, #4]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003d2:	b662      	cpsie	i
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80003d4:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80003d6:	2200      	movs	r2, #0
 80003d8:	6a03      	ldr	r3, [r0, #32]
 80003da:	601a      	str	r2, [r3, #0]
 80003dc:	e7e9      	b.n	80003b2 <wakeup.lto_priv.152+0x22>
 80003de:	46c0      	nop			; (mov r8, r8)
 80003e0:	080055c0 	.word	0x080055c0
 80003e4:	20000f20 	.word	0x20000f20
 80003e8:	46c0      	nop			; (mov r8, r8)
 80003ea:	46c0      	nop			; (mov r8, r8)
 80003ec:	46c0      	nop			; (mov r8, r8)
 80003ee:	46c0      	nop			; (mov r8, r8)

080003f0 <_idle_thread.lto_priv.64>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 80003f0:	4b02      	ldr	r3, [pc, #8]	; (80003fc <_idle_thread.lto_priv.64+0xc>)
 80003f2:	4a03      	ldr	r2, [pc, #12]	; (8000400 <_idle_thread.lto_priv.64+0x10>)
 80003f4:	699b      	ldr	r3, [r3, #24]
 80003f6:	619a      	str	r2, [r3, #24]
 80003f8:	e7fe      	b.n	80003f8 <_idle_thread.lto_priv.64+0x8>
 80003fa:	46c0      	nop			; (mov r8, r8)
 80003fc:	20000f20 	.word	0x20000f20
 8000400:	080055e0 	.word	0x080055e0
 8000404:	46c0      	nop			; (mov r8, r8)
 8000406:	46c0      	nop			; (mov r8, r8)
 8000408:	46c0      	nop			; (mov r8, r8)
 800040a:	46c0      	nop			; (mov r8, r8)
 800040c:	46c0      	nop			; (mov r8, r8)
 800040e:	46c0      	nop			; (mov r8, r8)

08000410 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000410:	e7fe      	b.n	8000410 <BusFault_Handler>
 8000412:	46c0      	nop			; (mov r8, r8)
 8000414:	46c0      	nop			; (mov r8, r8)
 8000416:	46c0      	nop			; (mov r8, r8)
 8000418:	46c0      	nop			; (mov r8, r8)
 800041a:	46c0      	nop			; (mov r8, r8)
 800041c:	46c0      	nop			; (mov r8, r8)
 800041e:	46c0      	nop			; (mov r8, r8)

08000420 <Vector80>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000422:	4646      	mov	r6, r8
 8000424:	464f      	mov	r7, r9
 8000426:	b4c0      	push	{r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000428:	4e22      	ldr	r6, [pc, #136]	; (80004b4 <Vector80+0x94>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800042a:	46f0      	mov	r8, lr

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800042c:	6933      	ldr	r3, [r6, #16]
 800042e:	079b      	lsls	r3, r3, #30
 8000430:	d406      	bmi.n	8000440 <Vector80+0x20>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000432:	4640      	mov	r0, r8
 8000434:	f7ff ff6c 	bl	8000310 <_port_irq_epilogue>
}
 8000438:	bc0c      	pop	{r2, r3}
 800043a:	4690      	mov	r8, r2
 800043c:	4699      	mov	r9, r3
 800043e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000440:	2300      	movs	r3, #0
 8000442:	6133      	str	r3, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000444:	b672      	cpsid	i
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000446:	4c1c      	ldr	r4, [pc, #112]	; (80004b8 <Vector80+0x98>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000448:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800044a:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800044c:	8ce7      	ldrh	r7, [r4, #38]	; 0x26
 800044e:	b290      	uxth	r0, r2
 8000450:	1bc1      	subs	r1, r0, r7
 8000452:	891a      	ldrh	r2, [r3, #8]
 8000454:	b289      	uxth	r1, r1
 8000456:	4291      	cmp	r1, r2
 8000458:	d31a      	bcc.n	8000490 <Vector80+0x70>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800045a:	2100      	movs	r1, #0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800045c:	1c25      	adds	r5, r4, #0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800045e:	4689      	mov	r9, r1
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000460:	351c      	adds	r5, #28
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8000462:	4648      	mov	r0, r9
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000464:	18ba      	adds	r2, r7, r2
 8000466:	84e2      	strh	r2, [r4, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000468:	681a      	ldr	r2, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 800046a:	68d9      	ldr	r1, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800046c:	6055      	str	r5, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800046e:	61e2      	str	r2, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8000470:	60d8      	str	r0, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000472:	42aa      	cmp	r2, r5
 8000474:	d01a      	beq.n	80004ac <Vector80+0x8c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000476:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8000478:	6918      	ldr	r0, [r3, #16]
 800047a:	4788      	blx	r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800047c:	b672      	cpsid	i
 800047e:	6a72      	ldr	r2, [r6, #36]	; 0x24
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8000480:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000482:	8ce7      	ldrh	r7, [r4, #38]	; 0x26
 8000484:	b290      	uxth	r0, r2
 8000486:	1bc1      	subs	r1, r0, r7
 8000488:	891a      	ldrh	r2, [r3, #8]
 800048a:	b289      	uxth	r1, r1
 800048c:	428a      	cmp	r2, r1
 800048e:	d9e8      	bls.n	8000462 <Vector80+0x42>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000490:	490a      	ldr	r1, [pc, #40]	; (80004bc <Vector80+0x9c>)
 8000492:	428b      	cmp	r3, r1
 8000494:	d008      	beq.n	80004a8 <Vector80+0x88>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000496:	18ba      	adds	r2, r7, r2
 8000498:	1a12      	subs	r2, r2, r0
 800049a:	b292      	uxth	r2, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800049c:	2a01      	cmp	r2, #1
 800049e:	d907      	bls.n	80004b0 <Vector80+0x90>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 80004a0:	1812      	adds	r2, r2, r0
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80004a2:	4b04      	ldr	r3, [pc, #16]	; (80004b4 <Vector80+0x94>)
 80004a4:	b292      	uxth	r2, r2
 80004a6:	635a      	str	r2, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80004a8:	b662      	cpsie	i
 80004aa:	e7c2      	b.n	8000432 <Vector80+0x12>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80004ac:	60f0      	str	r0, [r6, #12]
 80004ae:	e7e2      	b.n	8000476 <Vector80+0x56>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80004b0:	2202      	movs	r2, #2
 80004b2:	e7f5      	b.n	80004a0 <Vector80+0x80>
 80004b4:	40000400 	.word	0x40000400
 80004b8:	20000f20 	.word	0x20000f20
 80004bc:	20000f3c 	.word	0x20000f3c

080004c0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80004c0:	4a0c      	ldr	r2, [pc, #48]	; (80004f4 <chSchDoRescheduleAhead+0x34>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80004c2:	b510      	push	{r4, lr}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80004c4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp, *cp;

  otp = currp;
 80004c6:	6991      	ldr	r1, [r2, #24]

  tqp->p_next = tp->p_next;
 80004c8:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80004ca:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80004cc:	6013      	str	r3, [r2, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80004ce:	6190      	str	r0, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80004d0:	2201      	movs	r2, #1
 80004d2:	7702      	strb	r2, [r0, #28]

  otp->p_state = CH_STATE_READY;
 80004d4:	2200      	movs	r2, #0
 80004d6:	770a      	strb	r2, [r1, #28]
 80004d8:	688a      	ldr	r2, [r1, #8]
 80004da:	e000      	b.n	80004de <chSchDoRescheduleAhead+0x1e>
 80004dc:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80004de:	689c      	ldr	r4, [r3, #8]
 80004e0:	4294      	cmp	r4, r2
 80004e2:	d8fb      	bhi.n	80004dc <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80004e4:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80004e6:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 80004e8:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
 80004ea:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 80004ec:	6059      	str	r1, [r3, #4]

  chSysSwitch(currp, otp);
 80004ee:	f7ff fe47 	bl	8000180 <_port_switch>
}
 80004f2:	bd10      	pop	{r4, pc}
 80004f4:	20000f20 	.word	0x20000f20
 80004f8:	46c0      	nop			; (mov r8, r8)
 80004fa:	46c0      	nop			; (mov r8, r8)
 80004fc:	46c0      	nop			; (mov r8, r8)
 80004fe:	46c0      	nop			; (mov r8, r8)

08000500 <print_line.lto_priv.138>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 8000500:	b538      	push	{r3, r4, r5, lr}
 8000502:	244c      	movs	r4, #76	; 0x4c
 8000504:	4d07      	ldr	r5, [pc, #28]	; (8000524 <print_line.lto_priv.138+0x24>)
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 8000506:	6828      	ldr	r0, [r5, #0]
 8000508:	212d      	movs	r1, #45	; 0x2d
 800050a:	6803      	ldr	r3, [r0, #0]
 800050c:	3c01      	subs	r4, #1
 800050e:	689b      	ldr	r3, [r3, #8]
 8000510:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8000512:	2c00      	cmp	r4, #0
 8000514:	d1f7      	bne.n	8000506 <print_line.lto_priv.138+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8000516:	6828      	ldr	r0, [r5, #0]
 8000518:	4903      	ldr	r1, [pc, #12]	; (8000528 <print_line.lto_priv.138+0x28>)
 800051a:	6803      	ldr	r3, [r0, #0]
 800051c:	2202      	movs	r2, #2
 800051e:	681b      	ldr	r3, [r3, #0]
 8000520:	4798      	blx	r3
}
 8000522:	bd38      	pop	{r3, r4, r5, pc}
 8000524:	20001068 	.word	0x20001068
 8000528:	080055e8 	.word	0x080055e8
 800052c:	46c0      	nop			; (mov r8, r8)
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8000530:	b510      	push	{r4, lr}
 8000532:	2300      	movs	r3, #0
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 8000534:	2404      	movs	r4, #4
 8000536:	4806      	ldr	r0, [pc, #24]	; (8000550 <test_terminate_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8000538:	58c2      	ldr	r2, [r0, r3]
 800053a:	2a00      	cmp	r2, #0
 800053c:	d004      	beq.n	8000548 <test_terminate_threads+0x18>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800053e:	b672      	cpsid	i
 8000540:	7f51      	ldrb	r1, [r2, #29]
 8000542:	4321      	orrs	r1, r4
 8000544:	7751      	strb	r1, [r2, #29]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000546:	b662      	cpsie	i
 8000548:	3304      	adds	r3, #4
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800054a:	2b14      	cmp	r3, #20
 800054c:	d1f4      	bne.n	8000538 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800054e:	bd10      	pop	{r4, pc}
 8000550:	20001090 	.word	0x20001090
 8000554:	46c0      	nop			; (mov r8, r8)
 8000556:	46c0      	nop			; (mov r8, r8)
 8000558:	46c0      	nop			; (mov r8, r8)
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	46c0      	nop			; (mov r8, r8)
 800055e:	46c0      	nop			; (mov r8, r8)

08000560 <_test_assert_time_window>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000560:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000562:	4b0a      	ldr	r3, [pc, #40]	; (800058c <_test_assert_time_window+0x2c>)
 8000564:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000566:	b662      	cpsie	i
 8000568:	041b      	lsls	r3, r3, #16
 800056a:	0c1b      	lsrs	r3, r3, #16
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
 800056c:	1a5b      	subs	r3, r3, r1
 800056e:	1a52      	subs	r2, r2, r1

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8000570:	2100      	movs	r1, #0
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8000572:	4293      	cmp	r3, r2
 8000574:	db07      	blt.n	8000586 <_test_assert_time_window+0x26>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000576:	2301      	movs	r3, #1
 8000578:	4a05      	ldr	r2, [pc, #20]	; (8000590 <_test_assert_time_window+0x30>)
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 800057a:	3101      	adds	r1, #1
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 800057c:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 800057e:	4a05      	ldr	r2, [pc, #20]	; (8000594 <_test_assert_time_window+0x34>)
 8000580:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 8000582:	4b05      	ldr	r3, [pc, #20]	; (8000598 <_test_assert_time_window+0x38>)
 8000584:	6018      	str	r0, [r3, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8000586:	1c08      	adds	r0, r1, #0
 8000588:	4770      	bx	lr
 800058a:	46c0      	nop			; (mov r8, r8)
 800058c:	40000400 	.word	0x40000400
 8000590:	20000e94 	.word	0x20000e94
 8000594:	20000e95 	.word	0x20000e95
 8000598:	200006b8 	.word	0x200006b8
 800059c:	46c0      	nop			; (mov r8, r8)
 800059e:	46c0      	nop			; (mov r8, r8)

080005a0 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(point);
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
 80005a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80005a2:	4684      	mov	ip, r0
 80005a4:	4f0f      	ldr	r7, [pc, #60]	; (80005e4 <_test_assert_sequence+0x44>)
 80005a6:	4810      	ldr	r0, [pc, #64]	; (80005e8 <_test_assert_sequence+0x48>)
 80005a8:	683e      	ldr	r6, [r7, #0]
 80005aa:	1c03      	adds	r3, r0, #0
 80005ac:	e005      	b.n	80005ba <_test_assert_sequence+0x1a>
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
 80005ae:	7815      	ldrb	r5, [r2, #0]
 80005b0:	7822      	ldrb	r2, [r4, #0]
 80005b2:	3101      	adds	r1, #1
 80005b4:	3301      	adds	r3, #1
 80005b6:	4295      	cmp	r5, r2
 80005b8:	d109      	bne.n	80005ce <_test_assert_sequence+0x2e>
 80005ba:	1c0c      	adds	r4, r1, #0
 80005bc:	1c1a      	adds	r2, r3, #0
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 80005be:	429e      	cmp	r6, r3
 80005c0:	d8f5      	bhi.n	80005ae <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 80005c2:	780b      	ldrb	r3, [r1, #0]
 80005c4:	2b00      	cmp	r3, #0
 80005c6:	d102      	bne.n	80005ce <_test_assert_sequence+0x2e>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 80005c8:	6038      	str	r0, [r7, #0]
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
 80005ca:	2000      	movs	r0, #0
 80005cc:	e008      	b.n	80005e0 <_test_assert_sequence+0x40>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80005ce:	2301      	movs	r3, #1
 80005d0:	4a06      	ldr	r2, [pc, #24]	; (80005ec <_test_assert_sequence+0x4c>)

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
 80005d2:	2001      	movs	r0, #1
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80005d4:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 80005d6:	4a06      	ldr	r2, [pc, #24]	; (80005f0 <_test_assert_sequence+0x50>)
 80005d8:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 80005da:	4662      	mov	r2, ip
 80005dc:	4b05      	ldr	r3, [pc, #20]	; (80005f4 <_test_assert_sequence+0x54>)
 80005de:	601a      	str	r2, [r3, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 80005e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005e2:	46c0      	nop			; (mov r8, r8)
 80005e4:	200010a4 	.word	0x200010a4
 80005e8:	200010bc 	.word	0x200010bc
 80005ec:	20000e94 	.word	0x20000e94
 80005f0:	20000e95 	.word	0x20000e95
 80005f4:	200006b8 	.word	0x200006b8
 80005f8:	46c0      	nop			; (mov r8, r8)
 80005fa:	46c0      	nop			; (mov r8, r8)
 80005fc:	46c0      	nop			; (mov r8, r8)
 80005fe:	46c0      	nop			; (mov r8, r8)

08000600 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8000600:	2300      	movs	r3, #0
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8000602:	2900      	cmp	r1, #0
 8000604:	d107      	bne.n	8000616 <_test_assert+0x16>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000606:	4a05      	ldr	r2, [pc, #20]	; (800061c <_test_assert+0x1c>)
 8000608:	3301      	adds	r3, #1
 800060a:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 800060c:	4a04      	ldr	r2, [pc, #16]	; (8000620 <_test_assert+0x20>)
 800060e:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 8000610:	4b04      	ldr	r3, [pc, #16]	; (8000624 <_test_assert+0x24>)
 8000612:	6018      	str	r0, [r3, #0]
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 8000614:	2301      	movs	r3, #1
  return FALSE;
}
 8000616:	1c18      	adds	r0, r3, #0
 8000618:	4770      	bx	lr
 800061a:	46c0      	nop			; (mov r8, r8)
 800061c:	20000e94 	.word	0x20000e94
 8000620:	20000e95 	.word	0x20000e95
 8000624:	200006b8 	.word	0x200006b8
 8000628:	46c0      	nop			; (mov r8, r8)
 800062a:	46c0      	nop			; (mov r8, r8)
 800062c:	46c0      	nop			; (mov r8, r8)
 800062e:	46c0      	nop			; (mov r8, r8)

08000630 <test_emit_token>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000630:	b672      	cpsid	i
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
  *tokp++ = token;
 8000632:	4a03      	ldr	r2, [pc, #12]	; (8000640 <test_emit_token+0x10>)
 8000634:	6813      	ldr	r3, [r2, #0]
 8000636:	1c59      	adds	r1, r3, #1
 8000638:	6011      	str	r1, [r2, #0]
 800063a:	7018      	strb	r0, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800063c:	b662      	cpsie	i
  chSysUnlock();
}
 800063e:	4770      	bx	lr
 8000640:	200010a4 	.word	0x200010a4
 8000644:	46c0      	nop			; (mov r8, r8)
 8000646:	46c0      	nop			; (mov r8, r8)
 8000648:	46c0      	nop			; (mov r8, r8)
 800064a:	46c0      	nop			; (mov r8, r8)
 800064c:	46c0      	nop			; (mov r8, r8)
 800064e:	46c0      	nop			; (mov r8, r8)

08000650 <thread.lto_priv.158>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 8000650:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8000652:	7800      	ldrb	r0, [r0, #0]
 8000654:	f7ff ffec 	bl	8000630 <test_emit_token>
}
 8000658:	bd08      	pop	{r3, pc}
 800065a:	46c0      	nop			; (mov r8, r8)
 800065c:	46c0      	nop			; (mov r8, r8)
 800065e:	46c0      	nop			; (mov r8, r8)

08000660 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000660:	b538      	push	{r3, r4, r5, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000662:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000664:	1c04      	adds	r4, r0, #0
 8000666:	4d09      	ldr	r5, [pc, #36]	; (800068c <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000668:	2900      	cmp	r1, #0
 800066a:	d007      	beq.n	800067c <test_println+0x1c>
    chSequentialStreamPut(chp, *msgp++);
 800066c:	6828      	ldr	r0, [r5, #0]
 800066e:	3401      	adds	r4, #1
 8000670:	6803      	ldr	r3, [r0, #0]
 8000672:	689b      	ldr	r3, [r3, #8]
 8000674:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000676:	7821      	ldrb	r1, [r4, #0]
 8000678:	2900      	cmp	r1, #0
 800067a:	d1f7      	bne.n	800066c <test_println+0xc>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800067c:	6828      	ldr	r0, [r5, #0]
 800067e:	4904      	ldr	r1, [pc, #16]	; (8000690 <test_println+0x30>)
 8000680:	6803      	ldr	r3, [r0, #0]
 8000682:	2202      	movs	r2, #2
 8000684:	681b      	ldr	r3, [r3, #0]
 8000686:	4798      	blx	r3
}
 8000688:	bd38      	pop	{r3, r4, r5, pc}
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	20001068 	.word	0x20001068
 8000690:	080055e8 	.word	0x080055e8
 8000694:	46c0      	nop			; (mov r8, r8)
 8000696:	46c0      	nop			; (mov r8, r8)
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 80006a0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 80006a2:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 80006a4:	1c04      	adds	r4, r0, #0

  while (*msgp)
 80006a6:	2900      	cmp	r1, #0
 80006a8:	d008      	beq.n	80006bc <test_print+0x1c>
 80006aa:	4d05      	ldr	r5, [pc, #20]	; (80006c0 <test_print+0x20>)
    chSequentialStreamPut(chp, *msgp++);
 80006ac:	6828      	ldr	r0, [r5, #0]
 80006ae:	3401      	adds	r4, #1
 80006b0:	6803      	ldr	r3, [r0, #0]
 80006b2:	689b      	ldr	r3, [r3, #8]
 80006b4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80006b6:	7821      	ldrb	r1, [r4, #0]
 80006b8:	2900      	cmp	r1, #0
 80006ba:	d1f7      	bne.n	80006ac <test_print+0xc>
    chSequentialStreamPut(chp, *msgp++);
}
 80006bc:	bd38      	pop	{r3, r4, r5, pc}
 80006be:	46c0      	nop			; (mov r8, r8)
 80006c0:	20001068 	.word	0x20001068
 80006c4:	46c0      	nop			; (mov r8, r8)
 80006c6:	46c0      	nop			; (mov r8, r8)
 80006c8:	46c0      	nop			; (mov r8, r8)
 80006ca:	46c0      	nop			; (mov r8, r8)
 80006cc:	46c0      	nop			; (mov r8, r8)
 80006ce:	46c0      	nop			; (mov r8, r8)

080006d0 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 80006d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006d2:	4647      	mov	r7, r8
 80006d4:	b480      	push	{r7}
 80006d6:	1c06      	adds	r6, r0, #0
 80006d8:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 80006da:	2800      	cmp	r0, #0
 80006dc:	d023      	beq.n	8000726 <test_printn+0x56>
 80006de:	46e8      	mov	r8, sp
 80006e0:	466f      	mov	r7, sp
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 80006e2:	1c30      	adds	r0, r6, #0
 80006e4:	210a      	movs	r1, #10
 80006e6:	f7ff fdf1 	bl	80002cc <__aeabi_uidivmod>
 80006ea:	3701      	adds	r7, #1
 80006ec:	3130      	adds	r1, #48	; 0x30
 80006ee:	b2cc      	uxtb	r4, r1
 80006f0:	1e7d      	subs	r5, r7, #1
 80006f2:	1c30      	adds	r0, r6, #0
 80006f4:	702c      	strb	r4, [r5, #0]
 80006f6:	210a      	movs	r1, #10
 80006f8:	f7ff fd62 	bl	80001c0 <__aeabi_uidiv>
 80006fc:	1e06      	subs	r6, r0, #0

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80006fe:	d1f0      	bne.n	80006e2 <test_printn+0x12>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000700:	4547      	cmp	r7, r8
 8000702:	d90c      	bls.n	800071e <test_printn+0x4e>
 8000704:	466b      	mov	r3, sp
 8000706:	4e0b      	ldr	r6, [pc, #44]	; (8000734 <test_printn+0x64>)
 8000708:	1e5f      	subs	r7, r3, #1
 800070a:	e000      	b.n	800070e <test_printn+0x3e>
 800070c:	782c      	ldrb	r4, [r5, #0]
      chSequentialStreamPut(chp, *--p);
 800070e:	6830      	ldr	r0, [r6, #0]
 8000710:	1c21      	adds	r1, r4, #0
 8000712:	6803      	ldr	r3, [r0, #0]
 8000714:	3d01      	subs	r5, #1
 8000716:	689b      	ldr	r3, [r3, #8]
 8000718:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800071a:	42bd      	cmp	r5, r7
 800071c:	d1f6      	bne.n	800070c <test_printn+0x3c>
      chSequentialStreamPut(chp, *--p);
  }
}
 800071e:	b004      	add	sp, #16
 8000720:	bc04      	pop	{r2}
 8000722:	4690      	mov	r8, r2
 8000724:	bdf0      	pop	{r4, r5, r6, r7, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8000726:	4b03      	ldr	r3, [pc, #12]	; (8000734 <test_printn+0x64>)
 8000728:	2130      	movs	r1, #48	; 0x30
 800072a:	6818      	ldr	r0, [r3, #0]
 800072c:	6803      	ldr	r3, [r0, #0]
 800072e:	689b      	ldr	r3, [r3, #8]
 8000730:	4798      	blx	r3
 8000732:	e7f4      	b.n	800071e <test_printn+0x4e>
 8000734:	20001068 	.word	0x20001068
 8000738:	46c0      	nop			; (mov r8, r8)
 800073a:	46c0      	nop			; (mov r8, r8)
 800073c:	46c0      	nop			; (mov r8, r8)
 800073e:	46c0      	nop			; (mov r8, r8)

08000740 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000740:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000742:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000744:	4927      	ldr	r1, [pc, #156]	; (80007e4 <__early_init+0xa4>)
 8000746:	680a      	ldr	r2, [r1, #0]
 8000748:	4313      	orrs	r3, r2
 800074a:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800074c:	680a      	ldr	r2, [r1, #0]
 800074e:	4b25      	ldr	r3, [pc, #148]	; (80007e4 <__early_init+0xa4>)
 8000750:	4210      	tst	r0, r2
 8000752:	d0fb      	beq.n	800074c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000754:	2103      	movs	r1, #3
 8000756:	685a      	ldr	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000758:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800075a:	438a      	bics	r2, r1
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800075c:	1c19      	adds	r1, r3, #0
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800075e:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000760:	685a      	ldr	r2, [r3, #4]
 8000762:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000764:	684b      	ldr	r3, [r1, #4]
 8000766:	4a1f      	ldr	r2, [pc, #124]	; (80007e4 <__early_init+0xa4>)
 8000768:	4003      	ands	r3, r0
 800076a:	d1fb      	bne.n	8000764 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800076c:	20f9      	movs	r0, #249	; 0xf9
 800076e:	6811      	ldr	r1, [r2, #0]
 8000770:	4001      	ands	r1, r0
 8000772:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000774:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000776:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000778:	3301      	adds	r3, #1
 800077a:	430b      	orrs	r3, r1
 800077c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800077e:	38f7      	subs	r0, #247	; 0xf7
 8000780:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000782:	4b18      	ldr	r3, [pc, #96]	; (80007e4 <__early_init+0xa4>)
 8000784:	4208      	tst	r0, r1
 8000786:	d0fb      	beq.n	8000780 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000788:	2201      	movs	r2, #1
 800078a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800078c:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800078e:	430a      	orrs	r2, r1
 8000790:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000792:	1c1a      	adds	r2, r3, #0
 8000794:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8000796:	4b13      	ldr	r3, [pc, #76]	; (80007e4 <__early_init+0xa4>)
 8000798:	4208      	tst	r0, r1
 800079a:	d0fb      	beq.n	8000794 <__early_init+0x54>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL | STM32_PLLMUL | STM32_PLLSRC |
 800079c:	22a1      	movs	r2, #161	; 0xa1
 800079e:	0392      	lsls	r2, r2, #14
 80007a0:	605a      	str	r2, [r3, #4]
               STM32_ADCPRE | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80007a2:	2200      	movs	r2, #0
  RCC->CFGR3 = STM32_ADCSW  | STM32_USBSW  | STM32_CECSW  |
               STM32_I2C1SW | STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80007a4:	2180      	movs	r1, #128	; 0x80
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80007a6:	2080      	movs	r0, #128	; 0x80
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL | STM32_PLLMUL | STM32_PLLSRC |
               STM32_ADCPRE | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80007a8:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_ADCSW  | STM32_USBSW  | STM32_CECSW  |
 80007aa:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_I2C1SW | STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80007ac:	681a      	ldr	r2, [r3, #0]
 80007ae:	0449      	lsls	r1, r1, #17
 80007b0:	430a      	orrs	r2, r1
 80007b2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80007b4:	0480      	lsls	r0, r0, #18
 80007b6:	6819      	ldr	r1, [r3, #0]
 80007b8:	4a0a      	ldr	r2, [pc, #40]	; (80007e4 <__early_init+0xa4>)
 80007ba:	4201      	tst	r1, r0
 80007bc:	d0fb      	beq.n	80007b6 <__early_init+0x76>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80007be:	2111      	movs	r1, #17
 80007c0:	4b09      	ldr	r3, [pc, #36]	; (80007e8 <__early_init+0xa8>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80007c2:	200c      	movs	r0, #12
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80007c4:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80007c6:	2302      	movs	r3, #2
 80007c8:	6851      	ldr	r1, [r2, #4]
 80007ca:	430b      	orrs	r3, r1
 80007cc:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80007ce:	6853      	ldr	r3, [r2, #4]
 80007d0:	4904      	ldr	r1, [pc, #16]	; (80007e4 <__early_init+0xa4>)
 80007d2:	4003      	ands	r3, r0
 80007d4:	2b08      	cmp	r3, #8
 80007d6:	d1fa      	bne.n	80007ce <__early_init+0x8e>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80007d8:	698a      	ldr	r2, [r1, #24]
 80007da:	3b07      	subs	r3, #7
 80007dc:	4313      	orrs	r3, r2
 80007de:	618b      	str	r3, [r1, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 80007e0:	4770      	bx	lr
 80007e2:	46c0      	nop			; (mov r8, r8)
 80007e4:	40021000 	.word	0x40021000
 80007e8:	40022000 	.word	0x40022000
 80007ec:	46c0      	nop			; (mov r8, r8)
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80007f0:	b508      	push	{r3, lr}
 80007f2:	1c03      	adds	r3, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007f4:	b672      	cpsid	i
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 80007f6:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80007f8:	2800      	cmp	r0, #0
 80007fa:	d003      	beq.n	8000804 <chPoolAlloc+0x14>
    mp->mp_next = mp->mp_next->ph_next;
 80007fc:	6802      	ldr	r2, [r0, #0]
 80007fe:	601a      	str	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000800:	b662      	cpsie	i
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8000802:	bd08      	pop	{r3, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 8000804:	689a      	ldr	r2, [r3, #8]
 8000806:	2a00      	cmp	r2, #0
 8000808:	d0fa      	beq.n	8000800 <chPoolAlloc+0x10>
    objp = mp->mp_provider(mp->mp_object_size);
 800080a:	6858      	ldr	r0, [r3, #4]
 800080c:	4790      	blx	r2
 800080e:	e7f7      	b.n	8000800 <chPoolAlloc+0x10>

08000810 <chEvtUnregister>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000810:	b672      	cpsid	i
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8000812:	1c02      	adds	r2, r0, #0
 8000814:	e002      	b.n	800081c <chEvtUnregister+0xc>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 8000816:	428b      	cmp	r3, r1
 8000818:	d005      	beq.n	8000826 <chEvtUnregister+0x16>
 800081a:	1c1a      	adds	r2, r3, #0
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 800081c:	6813      	ldr	r3, [r2, #0]
 800081e:	4283      	cmp	r3, r0
 8000820:	d1f9      	bne.n	8000816 <chEvtUnregister+0x6>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000822:	b662      	cpsie	i
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
}
 8000824:	4770      	bx	lr
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 8000826:	680b      	ldr	r3, [r1, #0]
 8000828:	6013      	str	r3, [r2, #0]
 800082a:	e7fa      	b.n	8000822 <chEvtUnregister+0x12>
 800082c:	46c0      	nop			; (mov r8, r8)
 800082e:	46c0      	nop			; (mov r8, r8)

08000830 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8000830:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000832:	b672      	cpsid	i
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8000834:	4c0e      	ldr	r4, [pc, #56]	; (8000870 <chThdYield+0x40>)
 8000836:	6820      	ldr	r0, [r4, #0]
 8000838:	69a1      	ldr	r1, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800083a:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 800083c:	688a      	ldr	r2, [r1, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800083e:	4293      	cmp	r3, r2
 8000840:	d201      	bcs.n	8000846 <chThdYield+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000842:	b662      	cpsie	i

  chSysLock();
  chSchDoYieldS();
  chSysUnlock();
}
 8000844:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000846:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000848:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800084a:	6023      	str	r3, [r4, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800084c:	61a0      	str	r0, [r4, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800084e:	2401      	movs	r4, #1
 8000850:	7704      	strb	r4, [r0, #28]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000852:	2400      	movs	r4, #0
 8000854:	770c      	strb	r4, [r1, #28]
 8000856:	e000      	b.n	800085a <chThdYield+0x2a>
 8000858:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 800085a:	689c      	ldr	r4, [r3, #8]
 800085c:	42a2      	cmp	r2, r4
 800085e:	d9fb      	bls.n	8000858 <chThdYield+0x28>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000860:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000862:	600b      	str	r3, [r1, #0]
  tp->p_prev = cp->p_prev;
 8000864:	604a      	str	r2, [r1, #4]
  tp->p_prev->p_next = tp;
 8000866:	6011      	str	r1, [r2, #0]
  cp->p_prev = tp;
 8000868:	6059      	str	r1, [r3, #4]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800086a:	f7ff fc89 	bl	8000180 <_port_switch>
 800086e:	e7e8      	b.n	8000842 <chThdYield+0x12>
 8000870:	20000f20 	.word	0x20000f20
 8000874:	46c0      	nop			; (mov r8, r8)
 8000876:	46c0      	nop			; (mov r8, r8)
 8000878:	46c0      	nop			; (mov r8, r8)
 800087a:	46c0      	nop			; (mov r8, r8)
 800087c:	46c0      	nop			; (mov r8, r8)
 800087e:	46c0      	nop			; (mov r8, r8)

08000880 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000880:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000882:	f7ff fe1d 	bl	80004c0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000886:	bd08      	pop	{r3, pc}
 8000888:	46c0      	nop			; (mov r8, r8)
 800088a:	46c0      	nop			; (mov r8, r8)
 800088c:	46c0      	nop			; (mov r8, r8)
 800088e:	46c0      	nop			; (mov r8, r8)

08000890 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000890:	b508      	push	{r3, lr}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000892:	4b05      	ldr	r3, [pc, #20]	; (80008a8 <chSchRescheduleS+0x18>)
 8000894:	681a      	ldr	r2, [r3, #0]
 8000896:	699b      	ldr	r3, [r3, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000898:	6892      	ldr	r2, [r2, #8]
 800089a:	689b      	ldr	r3, [r3, #8]
 800089c:	429a      	cmp	r2, r3
 800089e:	d901      	bls.n	80008a4 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 80008a0:	f7ff fe0e 	bl	80004c0 <chSchDoRescheduleAhead>
  }
}
 80008a4:	bd08      	pop	{r3, pc}
 80008a6:	46c0      	nop			; (mov r8, r8)
 80008a8:	20000f20 	.word	0x20000f20
 80008ac:	46c0      	nop			; (mov r8, r8)
 80008ae:	46c0      	nop			; (mov r8, r8)

080008b0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 80008b0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008b2:	b672      	cpsid	i

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 80008b4:	4b07      	ldr	r3, [pc, #28]	; (80008d4 <chThdSetPriority+0x24>)
 80008b6:	699b      	ldr	r3, [r3, #24]
 80008b8:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 80008ba:	689a      	ldr	r2, [r3, #8]
 80008bc:	4294      	cmp	r4, r2
 80008be:	d001      	beq.n	80008c4 <chThdSetPriority+0x14>
 80008c0:	4282      	cmp	r2, r0
 80008c2:	d200      	bcs.n	80008c6 <chThdSetPriority+0x16>
    currp->p_prio = newprio;
 80008c4:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 80008c6:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 80008c8:	f7ff ffe2 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008cc:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 80008ce:	1c20      	adds	r0, r4, #0
 80008d0:	bd10      	pop	{r4, pc}
 80008d2:	46c0      	nop			; (mov r8, r8)
 80008d4:	20000f20 	.word	0x20000f20
 80008d8:	46c0      	nop			; (mov r8, r8)
 80008da:	46c0      	nop			; (mov r8, r8)
 80008dc:	46c0      	nop			; (mov r8, r8)
 80008de:	46c0      	nop			; (mov r8, r8)

080008e0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80008e0:	b538      	push	{r3, r4, r5, lr}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008e2:	4b12      	ldr	r3, [pc, #72]	; (800092c <chSchWakeupS+0x4c>)

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80008e4:	6201      	str	r1, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80008e6:	6999      	ldr	r1, [r3, #24]
 80008e8:	6882      	ldr	r2, [r0, #8]
 80008ea:	688c      	ldr	r4, [r1, #8]
 80008ec:	42a2      	cmp	r2, r4
 80008ee:	d80b      	bhi.n	8000908 <chSchWakeupS+0x28>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008f0:	2100      	movs	r1, #0
 80008f2:	7701      	strb	r1, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80008f4:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80008f6:	6899      	ldr	r1, [r3, #8]
 80008f8:	428a      	cmp	r2, r1
 80008fa:	d9fb      	bls.n	80008f4 <chSchWakeupS+0x14>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80008fc:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80008fe:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000900:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000902:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000904:	6058      	str	r0, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000906:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000908:	2200      	movs	r2, #0
 800090a:	770a      	strb	r2, [r1, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800090c:	1c1a      	adds	r2, r3, #0
  do {
    cp = cp->p_next;
 800090e:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000910:	6895      	ldr	r5, [r2, #8]
 8000912:	42ac      	cmp	r4, r5
 8000914:	d9fb      	bls.n	800090e <chSchWakeupS+0x2e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000916:	6854      	ldr	r4, [r2, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000918:	600a      	str	r2, [r1, #0]
  tp->p_prev = cp->p_prev;
 800091a:	604c      	str	r4, [r1, #4]
  tp->p_prev->p_next = tp;
 800091c:	6021      	str	r1, [r4, #0]
  cp->p_prev = tp;
 800091e:	6051      	str	r1, [r2, #4]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8000920:	6198      	str	r0, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000922:	2301      	movs	r3, #1
 8000924:	7703      	strb	r3, [r0, #28]
    chSysSwitch(ntp, otp);
 8000926:	f7ff fc2b 	bl	8000180 <_port_switch>
 800092a:	e7ec      	b.n	8000906 <chSchWakeupS+0x26>
 800092c:	20000f20 	.word	0x20000f20

08000930 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000930:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000932:	4b13      	ldr	r3, [pc, #76]	; (8000980 <chMtxUnlock+0x50>)
 8000934:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000936:	b672      	cpsid	i
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000938:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800093a:	6804      	ldr	r4, [r0, #0]
 800093c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800093e:	42a0      	cmp	r0, r4
 8000940:	d01a      	beq.n	8000978 <chMtxUnlock+0x48>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000942:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000944:	2b00      	cmp	r3, #0
 8000946:	d009      	beq.n	800095c <chMtxUnlock+0x2c>
 8000948:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800094a:	4293      	cmp	r3, r2
 800094c:	d003      	beq.n	8000956 <chMtxUnlock+0x26>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800094e:	6892      	ldr	r2, [r2, #8]
 8000950:	4291      	cmp	r1, r2
 8000952:	d200      	bcs.n	8000956 <chMtxUnlock+0x26>
 8000954:	1c11      	adds	r1, r2, #0
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000956:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000958:	2b00      	cmp	r3, #0
 800095a:	d1f5      	bne.n	8000948 <chMtxUnlock+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800095c:	6822      	ldr	r2, [r4, #0]
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800095e:	60a9      	str	r1, [r5, #8]
 8000960:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000962:	6050      	str	r0, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000964:	6ba2      	ldr	r2, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000966:	6084      	str	r4, [r0, #8]
      mp->m_next = tp->p_mtxlist;
 8000968:	60c2      	str	r2, [r0, #12]
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
 800096a:	2100      	movs	r1, #0
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 800096c:	63a0      	str	r0, [r4, #56]	; 0x38
      chSchWakeupS(tp, MSG_OK);
 800096e:	1c20      	adds	r0, r4, #0
 8000970:	f7ff ffb6 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000974:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8000976:	bd38      	pop	{r3, r4, r5, pc}
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
    }
    else {
      mp->m_owner = NULL;
 8000978:	2300      	movs	r3, #0
 800097a:	6083      	str	r3, [r0, #8]
 800097c:	e7fa      	b.n	8000974 <chMtxUnlock+0x44>
 800097e:	46c0      	nop			; (mov r8, r8)
 8000980:	20000f20 	.word	0x20000f20
 8000984:	46c0      	nop			; (mov r8, r8)
 8000986:	46c0      	nop			; (mov r8, r8)
 8000988:	46c0      	nop			; (mov r8, r8)
 800098a:	46c0      	nop			; (mov r8, r8)
 800098c:	46c0      	nop			; (mov r8, r8)
 800098e:	46c0      	nop			; (mov r8, r8)

08000990 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8000990:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000992:	b672      	cpsid	i
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 8000994:	6883      	ldr	r3, [r0, #8]
 8000996:	3301      	adds	r3, #1
 8000998:	6083      	str	r3, [r0, #8]
 800099a:	2b00      	cmp	r3, #0
 800099c:	dd01      	ble.n	80009a2 <chSemSignal+0x12>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800099e:	b662      	cpsie	i
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
  }
  chSysUnlock();
}
 80009a0:	bd08      	pop	{r3, pc}
 80009a2:	1c03      	adds	r3, r0, #0
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80009a4:	6800      	ldr	r0, [r0, #0]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 80009a6:	2100      	movs	r1, #0

  tqp->p_next = tp->p_next;
 80009a8:	6802      	ldr	r2, [r0, #0]
 80009aa:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80009ac:	6053      	str	r3, [r2, #4]
 80009ae:	f7ff ff97 	bl	80008e0 <chSchWakeupS>
 80009b2:	e7f4      	b.n	800099e <chSemSignal+0xe>
 80009b4:	46c0      	nop			; (mov r8, r8)
 80009b6:	46c0      	nop			; (mov r8, r8)
 80009b8:	46c0      	nop			; (mov r8, r8)
 80009ba:	46c0      	nop			; (mov r8, r8)
 80009bc:	46c0      	nop			; (mov r8, r8)
 80009be:	46c0      	nop			; (mov r8, r8)

080009c0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80009c0:	b510      	push	{r4, lr}
 80009c2:	1c04      	adds	r4, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009c4:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80009c6:	3924      	subs	r1, #36	; 0x24
 80009c8:	1841      	adds	r1, r0, r1
 80009ca:	60c1      	str	r1, [r0, #12]
 80009cc:	610b      	str	r3, [r1, #16]
 80009ce:	9b02      	ldr	r3, [sp, #8]
 80009d0:	614b      	str	r3, [r1, #20]
 80009d2:	4b0f      	ldr	r3, [pc, #60]	; (8000a10 <chThdCreateStatic+0x50>)
 80009d4:	620b      	str	r3, [r1, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80009d6:	2302      	movs	r3, #2
 80009d8:	7703      	strb	r3, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80009da:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80009dc:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80009de:	63c2      	str	r2, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80009e0:	2201      	movs	r2, #1
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80009e2:	7743      	strb	r3, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80009e4:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80009e6:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80009e8:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 80009ea:	4b0a      	ldr	r3, [pc, #40]	; (8000a14 <chThdCreateStatic+0x54>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80009ec:	7782      	strb	r2, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80009ee:	695a      	ldr	r2, [r3, #20]
 80009f0:	6103      	str	r3, [r0, #16]
 80009f2:	6142      	str	r2, [r0, #20]
 80009f4:	6110      	str	r0, [r2, #16]
 80009f6:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80009f8:	1c03      	adds	r3, r0, #0
 80009fa:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80009fc:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80009fe:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000a00:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8000a02:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8000a04:	2100      	movs	r1, #0
 8000a06:	f7ff ff6b 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a0a:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8000a0c:	1c20      	adds	r0, r4, #0
 8000a0e:	bd10      	pop	{r4, pc}
 8000a10:	080001a1 	.word	0x080001a1
 8000a14:	20000f20 	.word	0x20000f20
 8000a18:	46c0      	nop			; (mov r8, r8)
 8000a1a:	46c0      	nop			; (mov r8, r8)
 8000a1c:	46c0      	nop			; (mov r8, r8)
 8000a1e:	46c0      	nop			; (mov r8, r8)

08000a20 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000a20:	b508      	push	{r3, lr}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000a22:	4b06      	ldr	r3, [pc, #24]	; (8000a3c <chSchGoSleepS+0x1c>)
 8000a24:	6999      	ldr	r1, [r3, #24]
  otp->p_state = newstate;
 8000a26:	7708      	strb	r0, [r1, #28]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000a28:	6818      	ldr	r0, [r3, #0]

  tqp->p_next = tp->p_next;
 8000a2a:	6802      	ldr	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000a2c:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000a2e:	601a      	str	r2, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000a30:	6198      	str	r0, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000a32:	2301      	movs	r3, #1
 8000a34:	7703      	strb	r3, [r0, #28]
  chSysSwitch(currp, otp);
 8000a36:	f7ff fba3 	bl	8000180 <_port_switch>
}
 8000a3a:	bd08      	pop	{r3, pc}
 8000a3c:	20000f20 	.word	0x20000f20

08000a40 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8000a40:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a42:	b672      	cpsid	i
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8000a44:	4c0a      	ldr	r4, [pc, #40]	; (8000a70 <chMsgWait+0x30>)
 8000a46:	69a3      	ldr	r3, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8000a48:	1c1a      	adds	r2, r3, #0
 8000a4a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000a4c:	3228      	adds	r2, #40	; 0x28
 8000a4e:	4290      	cmp	r0, r2
 8000a50:	d006      	beq.n	8000a60 <chMsgWait+0x20>
 8000a52:	6801      	ldr	r1, [r0, #0]
 8000a54:	6299      	str	r1, [r3, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 8000a56:	230d      	movs	r3, #13
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000a58:	604a      	str	r2, [r1, #4]
 8000a5a:	7703      	strb	r3, [r0, #28]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a5c:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8000a5e:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8000a60:	200e      	movs	r0, #14
 8000a62:	f7ff ffdd 	bl	8000a20 <chSchGoSleepS>
 8000a66:	69a3      	ldr	r3, [r4, #24]
 8000a68:	1c1a      	adds	r2, r3, #0
 8000a6a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000a6c:	3228      	adds	r2, #40	; 0x28
 8000a6e:	e7f0      	b.n	8000a52 <chMsgWait+0x12>
 8000a70:	20000f20 	.word	0x20000f20
 8000a74:	46c0      	nop			; (mov r8, r8)
 8000a76:	46c0      	nop			; (mov r8, r8)
 8000a78:	46c0      	nop			; (mov r8, r8)
 8000a7a:	46c0      	nop			; (mov r8, r8)
 8000a7c:	46c0      	nop			; (mov r8, r8)
 8000a7e:	46c0      	nop			; (mov r8, r8)

08000a80 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8000a80:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a82:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8000a84:	6883      	ldr	r3, [r0, #8]
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8000a86:	2200      	movs	r2, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8000a88:	3b01      	subs	r3, #1
 8000a8a:	6083      	str	r3, [r0, #8]
 8000a8c:	2b00      	cmp	r3, #0
 8000a8e:	db02      	blt.n	8000a96 <chSemWait+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a90:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8000a92:	1c10      	adds	r0, r2, #0
 8000a94:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8000a96:	4c07      	ldr	r4, [pc, #28]	; (8000ab4 <chSemWait+0x34>)
 8000a98:	69a3      	ldr	r3, [r4, #24]
 8000a9a:	6218      	str	r0, [r3, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000a9c:	6842      	ldr	r2, [r0, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8000a9e:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000aa0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000aa2:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8000aa4:	6043      	str	r3, [r0, #4]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000aa6:	2005      	movs	r0, #5
 8000aa8:	f7ff ffba 	bl	8000a20 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8000aac:	69a3      	ldr	r3, [r4, #24]
 8000aae:	6a1a      	ldr	r2, [r3, #32]
 8000ab0:	e7ee      	b.n	8000a90 <chSemWait+0x10>
 8000ab2:	46c0      	nop			; (mov r8, r8)
 8000ab4:	20000f20 	.word	0x20000f20
 8000ab8:	46c0      	nop			; (mov r8, r8)
 8000aba:	46c0      	nop			; (mov r8, r8)
 8000abc:	46c0      	nop			; (mov r8, r8)
 8000abe:	46c0      	nop			; (mov r8, r8)

08000ac0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ac0:	2300      	movs	r3, #0
 8000ac2:	6882      	ldr	r2, [r0, #8]
 8000ac4:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000ac6:	4b05      	ldr	r3, [pc, #20]	; (8000adc <chSchReadyI+0x1c>)
  do {
    cp = cp->p_next;
 8000ac8:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000aca:	6899      	ldr	r1, [r3, #8]
 8000acc:	4291      	cmp	r1, r2
 8000ace:	d2fb      	bcs.n	8000ac8 <chSchReadyI+0x8>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000ad0:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000ad2:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000ad4:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000ad6:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000ad8:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000ada:	4770      	bx	lr
 8000adc:	20000f20 	.word	0x20000f20

08000ae0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8000ae0:	b508      	push	{r3, lr}
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000ae2:	6942      	ldr	r2, [r0, #20]
 8000ae4:	6983      	ldr	r3, [r0, #24]
 8000ae6:	429a      	cmp	r2, r3
 8000ae8:	d01d      	beq.n	8000b26 <chIQPutI+0x46>
 8000aea:	6883      	ldr	r3, [r0, #8]

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000aec:	3301      	adds	r3, #1
 8000aee:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 8000af0:	1c53      	adds	r3, r2, #1
 8000af2:	6143      	str	r3, [r0, #20]
 8000af4:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000af6:	6943      	ldr	r3, [r0, #20]
 8000af8:	6902      	ldr	r2, [r0, #16]
 8000afa:	4293      	cmp	r3, r2
 8000afc:	d20c      	bcs.n	8000b18 <chIQPutI+0x38>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000afe:	6803      	ldr	r3, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000b00:	4298      	cmp	r0, r3
 8000b02:	d00e      	beq.n	8000b22 <chIQPutI+0x42>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000b04:	681a      	ldr	r2, [r3, #0]
 8000b06:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000b08:	6050      	str	r0, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000b0a:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
 8000b0c:	1c18      	adds	r0, r3, #0

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000b0e:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000b10:	f7ff ffd6 	bl	8000ac0 <chSchReadyI>
    iqp->q_wrptr = iqp->q_buffer;
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8000b14:	2000      	movs	r0, #0
}
 8000b16:	bd08      	pop	{r3, pc}
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 8000b18:	68c3      	ldr	r3, [r0, #12]
 8000b1a:	6143      	str	r3, [r0, #20]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000b1c:	6803      	ldr	r3, [r0, #0]
 8000b1e:	4298      	cmp	r0, r3
 8000b20:	d1f0      	bne.n	8000b04 <chIQPutI+0x24>
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8000b22:	2000      	movs	r0, #0
 8000b24:	e7f7      	b.n	8000b16 <chIQPutI+0x36>
 8000b26:	6883      	ldr	r3, [r0, #8]
 8000b28:	2b00      	cmp	r3, #0
 8000b2a:	d0df      	beq.n	8000aec <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8000b2c:	2004      	movs	r0, #4
 8000b2e:	4240      	negs	r0, r0
 8000b30:	e7f1      	b.n	8000b16 <chIQPutI+0x36>
 8000b32:	46c0      	nop			; (mov r8, r8)
 8000b34:	46c0      	nop			; (mov r8, r8)
 8000b36:	46c0      	nop			; (mov r8, r8)
 8000b38:	46c0      	nop			; (mov r8, r8)
 8000b3a:	46c0      	nop			; (mov r8, r8)
 8000b3c:	46c0      	nop			; (mov r8, r8)
 8000b3e:	46c0      	nop			; (mov r8, r8)

08000b40 <chOQGetI>:
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000b40:	6982      	ldr	r2, [r0, #24]
 8000b42:	6943      	ldr	r3, [r0, #20]
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8000b44:	b510      	push	{r4, lr}
 8000b46:	4293      	cmp	r3, r2
 8000b48:	d018      	beq.n	8000b7c <chOQGetI+0x3c>
 8000b4a:	6883      	ldr	r3, [r0, #8]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000b4c:	3301      	adds	r3, #1
 8000b4e:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 8000b50:	1c53      	adds	r3, r2, #1
 8000b52:	6183      	str	r3, [r0, #24]
 8000b54:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000b56:	6902      	ldr	r2, [r0, #16]
 8000b58:	4293      	cmp	r3, r2
 8000b5a:	d20c      	bcs.n	8000b76 <chOQGetI+0x36>
 8000b5c:	6802      	ldr	r2, [r0, #0]
 8000b5e:	4290      	cmp	r0, r2
 8000b60:	d007      	beq.n	8000b72 <chOQGetI+0x32>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000b62:	2300      	movs	r3, #0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000b64:	6811      	ldr	r1, [r2, #0]
 8000b66:	6001      	str	r1, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000b68:	6048      	str	r0, [r1, #4]
 8000b6a:	6213      	str	r3, [r2, #32]
  (void) chSchReadyI(tp);
 8000b6c:	1c10      	adds	r0, r2, #0
 8000b6e:	f7ff ffa7 	bl	8000ac0 <chSchReadyI>
    oqp->q_rdptr = oqp->q_buffer;
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
 8000b72:	1c20      	adds	r0, r4, #0
}
 8000b74:	bd10      	pop	{r4, pc}
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
    oqp->q_rdptr = oqp->q_buffer;
 8000b76:	68c3      	ldr	r3, [r0, #12]
 8000b78:	6183      	str	r3, [r0, #24]
 8000b7a:	e7ef      	b.n	8000b5c <chOQGetI+0x1c>
 8000b7c:	6883      	ldr	r3, [r0, #8]
 8000b7e:	2b00      	cmp	r3, #0
 8000b80:	d0e4      	beq.n	8000b4c <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8000b82:	2003      	movs	r0, #3
 8000b84:	4240      	negs	r0, r0
 8000b86:	e7f5      	b.n	8000b74 <chOQGetI+0x34>
 8000b88:	46c0      	nop			; (mov r8, r8)
 8000b8a:	46c0      	nop			; (mov r8, r8)
 8000b8c:	46c0      	nop			; (mov r8, r8)
 8000b8e:	46c0      	nop			; (mov r8, r8)

08000b90 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8000b90:	4b0c      	ldr	r3, [pc, #48]	; (8000bc4 <chMsgSend+0x34>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8000b92:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8000b94:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b96:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8000b98:	1c03      	adds	r3, r0, #0
 8000b9a:	3328      	adds	r3, #40	; 0x28
 8000b9c:	6223      	str	r3, [r4, #32]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8000b9e:	6023      	str	r3, [r4, #0]
  tp->p_prev = tqp->p_prev;
 8000ba0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 8000ba2:	6321      	str	r1, [r4, #48]	; 0x30
 8000ba4:	6063      	str	r3, [r4, #4]
  tp->p_prev->p_next = tp;
 8000ba6:	601c      	str	r4, [r3, #0]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8000ba8:	7f03      	ldrb	r3, [r0, #28]
  tqp->p_prev = tp;
 8000baa:	62c4      	str	r4, [r0, #44]	; 0x2c
 8000bac:	2b0e      	cmp	r3, #14
 8000bae:	d005      	beq.n	8000bbc <chMsgSend+0x2c>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8000bb0:	200c      	movs	r0, #12
 8000bb2:	f7ff ff35 	bl	8000a20 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8000bb6:	6a20      	ldr	r0, [r4, #32]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000bb8:	b662      	cpsie	i
  chSysUnlock();

  return msg;
}
 8000bba:	bd10      	pop	{r4, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8000bbc:	f7ff ff80 	bl	8000ac0 <chSchReadyI>
 8000bc0:	e7f6      	b.n	8000bb0 <chMsgSend+0x20>
 8000bc2:	46c0      	nop			; (mov r8, r8)
 8000bc4:	20000f20 	.word	0x20000f20
 8000bc8:	46c0      	nop			; (mov r8, r8)
 8000bca:	46c0      	nop			; (mov r8, r8)
 8000bcc:	46c0      	nop			; (mov r8, r8)
 8000bce:	46c0      	nop			; (mov r8, r8)

08000bd0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000bd0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000bd2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000bd4:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000bd6:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000bd8:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000bda:	2b0a      	cmp	r3, #10
 8000bdc:	d00b      	beq.n	8000bf6 <chEvtSignalI+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000bde:	2b0b      	cmp	r3, #11
 8000be0:	d000      	beq.n	8000be4 <chEvtSignalI+0x14>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000be2:	bd08      	pop	{r3, pc}
  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000be4:	6a03      	ldr	r3, [r0, #32]
 8000be6:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000be8:	428b      	cmp	r3, r1
 8000bea:	d1fa      	bne.n	8000be2 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000bec:	2300      	movs	r3, #0
 8000bee:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8000bf0:	f7ff ff66 	bl	8000ac0 <chSchReadyI>
 8000bf4:	e7f5      	b.n	8000be2 <chEvtSignalI+0x12>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000bf6:	6a03      	ldr	r3, [r0, #32]
 8000bf8:	420b      	tst	r3, r1
 8000bfa:	d0f2      	beq.n	8000be2 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000bfc:	2300      	movs	r3, #0
 8000bfe:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8000c00:	f7ff ff5e 	bl	8000ac0 <chSchReadyI>
 8000c04:	e7ed      	b.n	8000be2 <chEvtSignalI+0x12>
 8000c06:	46c0      	nop			; (mov r8, r8)
 8000c08:	46c0      	nop			; (mov r8, r8)
 8000c0a:	46c0      	nop			; (mov r8, r8)
 8000c0c:	46c0      	nop			; (mov r8, r8)
 8000c0e:	46c0      	nop			; (mov r8, r8)

08000c10 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000c10:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000c12:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000c14:	1c06      	adds	r6, r0, #0
 8000c16:	1c0d      	adds	r5, r1, #0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000c18:	42a0      	cmp	r0, r4
 8000c1a:	d00e      	beq.n	8000c3a <chEvtBroadcastFlagsI+0x2a>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000c1c:	68e3      	ldr	r3, [r4, #12]
 8000c1e:	432b      	orrs	r3, r5
 8000c20:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000c22:	2d00      	cmp	r5, #0
 8000c24:	d002      	beq.n	8000c2c <chEvtBroadcastFlagsI+0x1c>
 8000c26:	6922      	ldr	r2, [r4, #16]
 8000c28:	421a      	tst	r2, r3
 8000c2a:	d003      	beq.n	8000c34 <chEvtBroadcastFlagsI+0x24>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000c2c:	6860      	ldr	r0, [r4, #4]
 8000c2e:	68a1      	ldr	r1, [r4, #8]
 8000c30:	f7ff ffce 	bl	8000bd0 <chEvtSignalI>
    }
    elp = elp->el_next;
 8000c34:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000c36:	42a6      	cmp	r6, r4
 8000c38:	d1f0      	bne.n	8000c1c <chEvtBroadcastFlagsI+0xc>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8000c3a:	bd70      	pop	{r4, r5, r6, pc}
 8000c3c:	46c0      	nop			; (mov r8, r8)
 8000c3e:	46c0      	nop			; (mov r8, r8)

08000c40 <VectorB0>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000c40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c42:	4645      	mov	r5, r8
 8000c44:	4657      	mov	r7, sl
 8000c46:	464e      	mov	r6, r9
 8000c48:	b4e0      	push	{r5, r6, r7}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000c4a:	4f3f      	ldr	r7, [pc, #252]	; (8000d48 <VectorB0+0x108>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8000c4c:	46f0      	mov	r8, lr
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000c4e:	6f7d      	ldr	r5, [r7, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8000c50:	682e      	ldr	r6, [r5, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000c52:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 8000c54:	622c      	str	r4, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000c56:	0723      	lsls	r3, r4, #28
 8000c58:	d134      	bne.n	8000cc4 <VectorB0+0x84>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000c5a:	05e3      	lsls	r3, r4, #23
 8000c5c:	d42a      	bmi.n	8000cb4 <VectorB0+0x74>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000c5e:	06a3      	lsls	r3, r4, #26
 8000c60:	d417      	bmi.n	8000c92 <VectorB0+0x52>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000c62:	2380      	movs	r3, #128	; 0x80
 8000c64:	4233      	tst	r3, r6
 8000c66:	d001      	beq.n	8000c6c <VectorB0+0x2c>
 8000c68:	4223      	tst	r3, r4
 8000c6a:	d141      	bne.n	8000cf0 <VectorB0+0xb0>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000c6c:	0663      	lsls	r3, r4, #25
 8000c6e:	d508      	bpl.n	8000c82 <VectorB0+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c70:	b672      	cpsid	i
 8000c72:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8000c74:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8000c76:	4293      	cmp	r3, r2
 8000c78:	d046      	beq.n	8000d08 <VectorB0+0xc8>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000c7a:	2340      	movs	r3, #64	; 0x40
 8000c7c:	439e      	bics	r6, r3
 8000c7e:	602e      	str	r6, [r5, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c80:	b662      	cpsie	i

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8000c82:	4640      	mov	r0, r8
 8000c84:	f7ff fb44 	bl	8000310 <_port_irq_epilogue>
}
 8000c88:	bc1c      	pop	{r2, r3, r4}
 8000c8a:	4690      	mov	r8, r2
 8000c8c:	4699      	mov	r9, r3
 8000c8e:	46a2      	mov	sl, r4
 8000c90:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c92:	b672      	cpsid	i
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000c94:	8cab      	ldrh	r3, [r5, #36]	; 0x24
 8000c96:	b2db      	uxtb	r3, r3
 8000c98:	4699      	mov	r9, r3
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000c9a:	697b      	ldr	r3, [r7, #20]
 8000c9c:	2b00      	cmp	r3, #0
 8000c9e:	d03b      	beq.n	8000d18 <VectorB0+0xd8>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8000ca0:	4b2a      	ldr	r3, [pc, #168]	; (8000d4c <VectorB0+0x10c>)
 8000ca2:	4649      	mov	r1, r9
 8000ca4:	1c18      	adds	r0, r3, #0
 8000ca6:	469a      	mov	sl, r3
 8000ca8:	f7ff ff1a 	bl	8000ae0 <chIQPutI>
 8000cac:	2800      	cmp	r0, #0
 8000cae:	db38      	blt.n	8000d22 <VectorB0+0xe2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cb0:	b662      	cpsie	i
 8000cb2:	e7d6      	b.n	8000c62 <VectorB0+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cb4:	b672      	cpsid	i
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000cb6:	2180      	movs	r1, #128	; 0x80
 8000cb8:	4825      	ldr	r0, [pc, #148]	; (8000d50 <VectorB0+0x110>)
 8000cba:	0089      	lsls	r1, r1, #2
 8000cbc:	f7ff ffa8 	bl	8000c10 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cc0:	b662      	cpsie	i
 8000cc2:	e7cc      	b.n	8000c5e <VectorB0+0x1e>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8000cc4:	0721      	lsls	r1, r4, #28
    sts |= SD_OVERRUN_ERROR;
 8000cc6:	0fc9      	lsrs	r1, r1, #31
 8000cc8:	01c9      	lsls	r1, r1, #7
  if (isr & USART_ISR_PE)
 8000cca:	07e3      	lsls	r3, r4, #31
 8000ccc:	d501      	bpl.n	8000cd2 <VectorB0+0x92>
    sts |= SD_PARITY_ERROR;
 8000cce:	2320      	movs	r3, #32
 8000cd0:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 8000cd2:	07a3      	lsls	r3, r4, #30
 8000cd4:	d501      	bpl.n	8000cda <VectorB0+0x9a>
    sts |= SD_FRAMING_ERROR;
 8000cd6:	2340      	movs	r3, #64	; 0x40
 8000cd8:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 8000cda:	0763      	lsls	r3, r4, #29
 8000cdc:	d502      	bpl.n	8000ce4 <VectorB0+0xa4>
    sts |= SD_NOISE_ERROR;
 8000cde:	2380      	movs	r3, #128	; 0x80
 8000ce0:	005b      	lsls	r3, r3, #1
 8000ce2:	4319      	orrs	r1, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ce4:	b672      	cpsid	i
 8000ce6:	481a      	ldr	r0, [pc, #104]	; (8000d50 <VectorB0+0x110>)
 8000ce8:	f7ff ff92 	bl	8000c10 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cec:	b662      	cpsie	i
 8000cee:	e7b4      	b.n	8000c5a <VectorB0+0x1a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cf0:	b672      	cpsid	i

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8000cf2:	4b18      	ldr	r3, [pc, #96]	; (8000d54 <VectorB0+0x114>)
 8000cf4:	1c18      	adds	r0, r3, #0
 8000cf6:	4699      	mov	r9, r3
 8000cf8:	f7ff ff22 	bl	8000b40 <chOQGetI>
    if (b < Q_OK) {
 8000cfc:	2800      	cmp	r0, #0
 8000cfe:	db16      	blt.n	8000d2e <VectorB0+0xee>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000d00:	b280      	uxth	r0, r0
 8000d02:	8528      	strh	r0, [r5, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d04:	b662      	cpsie	i
 8000d06:	e7b1      	b.n	8000c6c <VectorB0+0x2c>
 8000d08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8000d0a:	2b00      	cmp	r3, #0
 8000d0c:	d0b5      	beq.n	8000c7a <VectorB0+0x3a>
 8000d0e:	1d38      	adds	r0, r7, #4
 8000d10:	2110      	movs	r1, #16
 8000d12:	f7ff ff7d 	bl	8000c10 <chEvtBroadcastFlagsI>
 8000d16:	e7b0      	b.n	8000c7a <VectorB0+0x3a>
 8000d18:	1d38      	adds	r0, r7, #4
 8000d1a:	2104      	movs	r1, #4
 8000d1c:	f7ff ff78 	bl	8000c10 <chEvtBroadcastFlagsI>
 8000d20:	e7be      	b.n	8000ca0 <VectorB0+0x60>
 8000d22:	4650      	mov	r0, sl
 8000d24:	2180      	movs	r1, #128	; 0x80
 8000d26:	3808      	subs	r0, #8
 8000d28:	f7ff ff72 	bl	8000c10 <chEvtBroadcastFlagsI>
 8000d2c:	e7c0      	b.n	8000cb0 <VectorB0+0x70>
 8000d2e:	4648      	mov	r0, r9
 8000d30:	2108      	movs	r1, #8
 8000d32:	382c      	subs	r0, #44	; 0x2c
 8000d34:	f7ff ff6c 	bl	8000c10 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000d38:	23c0      	movs	r3, #192	; 0xc0
 8000d3a:	1c32      	adds	r2, r6, #0
 8000d3c:	439a      	bics	r2, r3
 8000d3e:	3b80      	subs	r3, #128	; 0x80
 8000d40:	4313      	orrs	r3, r2
 8000d42:	602b      	str	r3, [r5, #0]
 8000d44:	e7de      	b.n	8000d04 <VectorB0+0xc4>
 8000d46:	46c0      	nop			; (mov r8, r8)
 8000d48:	20000e98 	.word	0x20000e98
 8000d4c:	20000ea4 	.word	0x20000ea4
 8000d50:	20000e9c 	.word	0x20000e9c
 8000d54:	20000ec8 	.word	0x20000ec8
 8000d58:	46c0      	nop			; (mov r8, r8)
 8000d5a:	46c0      	nop			; (mov r8, r8)
 8000d5c:	46c0      	nop			; (mov r8, r8)
 8000d5e:	46c0      	nop			; (mov r8, r8)

08000d60 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8000d60:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000d62:	4b11      	ldr	r3, [pc, #68]	; (8000da8 <chMtxUnlockAll+0x48>)
 8000d64:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d66:	b672      	cpsid	i

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 8000d68:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000d6a:	2b00      	cmp	r3, #0
 8000d6c:	d01a      	beq.n	8000da4 <chMtxUnlockAll+0x44>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8000d6e:	2500      	movs	r5, #0
 8000d70:	e00b      	b.n	8000d8a <chMtxUnlockAll+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000d72:	6802      	ldr	r2, [r0, #0]
 8000d74:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000d76:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 8000d78:	6b82      	ldr	r2, [r0, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 8000d7a:	6098      	str	r0, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 8000d7c:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 8000d7e:	6383      	str	r3, [r0, #56]	; 0x38
        (void) chSchReadyI(tp);
 8000d80:	f7ff fe9e 	bl	8000ac0 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 8000d84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000d86:	2b00      	cmp	r3, #0
 8000d88:	d008      	beq.n	8000d9c <chMtxUnlockAll+0x3c>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8000d8a:	68da      	ldr	r2, [r3, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000d8c:	6818      	ldr	r0, [r3, #0]
 8000d8e:	63a2      	str	r2, [r4, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8000d90:	4283      	cmp	r3, r0
 8000d92:	d1ee      	bne.n	8000d72 <chMtxUnlockAll+0x12>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8000d94:	609d      	str	r5, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8000d96:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000d98:	2b00      	cmp	r3, #0
 8000d9a:	d1f6      	bne.n	8000d8a <chMtxUnlockAll+0x2a>
    ctp->p_prio = ctp->p_realprio;
 8000d9c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000d9e:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 8000da0:	f7ff fd76 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000da4:	b662      	cpsie	i
  }
  chSysUnlock();
}
 8000da6:	bd38      	pop	{r3, r4, r5, pc}
 8000da8:	20000f20 	.word	0x20000f20
 8000dac:	46c0      	nop			; (mov r8, r8)
 8000dae:	46c0      	nop			; (mov r8, r8)

08000db0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8000db0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000db2:	4b11      	ldr	r3, [pc, #68]	; (8000df8 <chMtxUnlockS+0x48>)
 8000db4:	6804      	ldr	r4, [r0, #0]
 8000db6:	699d      	ldr	r5, [r3, #24]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000db8:	68c3      	ldr	r3, [r0, #12]
 8000dba:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000dbc:	42a0      	cmp	r0, r4
 8000dbe:	d018      	beq.n	8000df2 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000dc0:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000dc2:	2b00      	cmp	r3, #0
 8000dc4:	d009      	beq.n	8000dda <chMtxUnlockS+0x2a>
 8000dc6:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000dc8:	4293      	cmp	r3, r2
 8000dca:	d003      	beq.n	8000dd4 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000dcc:	6892      	ldr	r2, [r2, #8]
 8000dce:	4291      	cmp	r1, r2
 8000dd0:	d200      	bcs.n	8000dd4 <chMtxUnlockS+0x24>
 8000dd2:	1c11      	adds	r1, r2, #0
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000dd4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000dd6:	2b00      	cmp	r3, #0
 8000dd8:	d1f5      	bne.n	8000dc6 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000dda:	6822      	ldr	r2, [r4, #0]
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000ddc:	60a9      	str	r1, [r5, #8]
 8000dde:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000de0:	6050      	str	r0, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000de2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000de4:	6084      	str	r4, [r0, #8]
      mp->m_next = tp->p_mtxlist;
 8000de6:	60c2      	str	r2, [r0, #12]
      tp->p_mtxlist = mp;
 8000de8:	63a0      	str	r0, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8000dea:	1c20      	adds	r0, r4, #0
 8000dec:	f7ff fe68 	bl	8000ac0 <chSchReadyI>
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000df0:	bd38      	pop	{r3, r4, r5, pc}
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
    }
    else {
      mp->m_owner = NULL;
 8000df2:	2300      	movs	r3, #0
 8000df4:	6083      	str	r3, [r0, #8]
 8000df6:	e7fb      	b.n	8000df0 <chMtxUnlockS+0x40>
 8000df8:	20000f20 	.word	0x20000f20
 8000dfc:	46c0      	nop			; (mov r8, r8)
 8000dfe:	46c0      	nop			; (mov r8, r8)

08000e00 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000e00:	4b30      	ldr	r3, [pc, #192]	; (8000ec4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000e02:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000e04:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000e06:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000e08:	2a00      	cmp	r2, #0
 8000e0a:	d055      	beq.n	8000eb8 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000e0c:	68a1      	ldr	r1, [r4, #8]
 8000e0e:	6893      	ldr	r3, [r2, #8]
 8000e10:	1c05      	adds	r5, r0, #0
 8000e12:	4299      	cmp	r1, r3
 8000e14:	d907      	bls.n	8000e26 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000e16:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000e18:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000e1a:	2b06      	cmp	r3, #6
 8000e1c:	d033      	beq.n	8000e86 <chMtxLockS+0x86>
 8000e1e:	2b07      	cmp	r3, #7
 8000e20:	d01d      	beq.n	8000e5e <chMtxLockS+0x5e>
 8000e22:	2b00      	cmp	r3, #0
 8000e24:	d012      	beq.n	8000e4c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000e26:	1c2b      	adds	r3, r5, #0
 8000e28:	e003      	b.n	8000e32 <chMtxLockS+0x32>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e2a:	689a      	ldr	r2, [r3, #8]
 8000e2c:	68a1      	ldr	r1, [r4, #8]
 8000e2e:	428a      	cmp	r2, r1
 8000e30:	d302      	bcc.n	8000e38 <chMtxLockS+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000e32:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e34:	429d      	cmp	r5, r3
 8000e36:	d1f8      	bne.n	8000e2a <chMtxLockS+0x2a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000e38:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000e3a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8000e3c:	6062      	str	r2, [r4, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000e3e:	2006      	movs	r0, #6
  tp->p_prev->p_next = tp;
 8000e40:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000e42:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8000e44:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8000e46:	f7ff fdeb 	bl	8000a20 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8000e4a:	bd70      	pop	{r4, r5, r6, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000e4c:	6811      	ldr	r1, [r2, #0]
 8000e4e:	6853      	ldr	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000e50:	1c10      	adds	r0, r2, #0
 8000e52:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e54:	6811      	ldr	r1, [r2, #0]
 8000e56:	604b      	str	r3, [r1, #4]
 8000e58:	f7ff fe32 	bl	8000ac0 <chSchReadyI>
 8000e5c:	e7e3      	b.n	8000e26 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000e5e:	6853      	ldr	r3, [r2, #4]
 8000e60:	6810      	ldr	r0, [r2, #0]
 8000e62:	6018      	str	r0, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e64:	6810      	ldr	r0, [r2, #0]
 8000e66:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000e68:	6a10      	ldr	r0, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000e6a:	1c03      	adds	r3, r0, #0
 8000e6c:	e002      	b.n	8000e74 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e6e:	689e      	ldr	r6, [r3, #8]
 8000e70:	428e      	cmp	r6, r1
 8000e72:	d302      	bcc.n	8000e7a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000e74:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e76:	4298      	cmp	r0, r3
 8000e78:	d1f9      	bne.n	8000e6e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000e7a:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000e7c:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 8000e7e:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 8000e80:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8000e82:	605a      	str	r2, [r3, #4]
 8000e84:	e7cf      	b.n	8000e26 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000e86:	6853      	ldr	r3, [r2, #4]
 8000e88:	6810      	ldr	r0, [r2, #0]
 8000e8a:	6018      	str	r0, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e8c:	6810      	ldr	r0, [r2, #0]
 8000e8e:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000e90:	6a10      	ldr	r0, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000e92:	1c03      	adds	r3, r0, #0
 8000e94:	e002      	b.n	8000e9c <chMtxLockS+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e96:	689e      	ldr	r6, [r3, #8]
 8000e98:	428e      	cmp	r6, r1
 8000e9a:	d302      	bcc.n	8000ea2 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000e9c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e9e:	4298      	cmp	r0, r3
 8000ea0:	d1f9      	bne.n	8000e96 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000ea2:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000ea4:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 8000ea6:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 8000ea8:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8000eaa:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 8000eac:	6882      	ldr	r2, [r0, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000eae:	68a1      	ldr	r1, [r4, #8]
 8000eb0:	6893      	ldr	r3, [r2, #8]
 8000eb2:	428b      	cmp	r3, r1
 8000eb4:	d3af      	bcc.n	8000e16 <chMtxLockS+0x16>
 8000eb6:	e7b6      	b.n	8000e26 <chMtxLockS+0x26>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8000eb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8000eba:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
 8000ebc:	60c3      	str	r3, [r0, #12]
    ctp->p_mtxlist = mp;
 8000ebe:	63a0      	str	r0, [r4, #56]	; 0x38
 8000ec0:	e7c3      	b.n	8000e4a <chMtxLockS+0x4a>
 8000ec2:	46c0      	nop			; (mov r8, r8)
 8000ec4:	20000f20 	.word	0x20000f20
 8000ec8:	46c0      	nop			; (mov r8, r8)
 8000eca:	46c0      	nop			; (mov r8, r8)
 8000ecc:	46c0      	nop			; (mov r8, r8)
 8000ece:	46c0      	nop			; (mov r8, r8)

08000ed0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8000ed0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ed2:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 8000ed4:	f7ff ff94 	bl	8000e00 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ed8:	b662      	cpsie	i
  chSysUnlock();
}
 8000eda:	bd08      	pop	{r3, pc}
 8000edc:	46c0      	nop			; (mov r8, r8)
 8000ede:	46c0      	nop			; (mov r8, r8)

08000ee0 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8000ee0:	b570      	push	{r4, r5, r6, lr}
 8000ee2:	1c04      	adds	r4, r0, #0
 8000ee4:	1c0e      	adds	r6, r1, #0
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8000ee6:	2800      	cmp	r0, #0
 8000ee8:	d018      	beq.n	8000f1c <chHeapStatus+0x3c>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8000eea:	1c25      	adds	r5, r4, #0
 8000eec:	3510      	adds	r5, #16
 8000eee:	1c28      	adds	r0, r5, #0
 8000ef0:	f7ff ffee 	bl	8000ed0 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000ef4:	68a3      	ldr	r3, [r4, #8]
 8000ef6:	2200      	movs	r2, #0
 8000ef8:	2400      	movs	r4, #0
 8000efa:	2b00      	cmp	r3, #0
 8000efc:	d006      	beq.n	8000f0c <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
 8000efe:	6859      	ldr	r1, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000f00:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
 8000f02:	468c      	mov	ip, r1
    n++;
 8000f04:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8000f06:	4462      	add	r2, ip

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000f08:	2b00      	cmp	r3, #0
 8000f0a:	d1f8      	bne.n	8000efe <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8000f0c:	2e00      	cmp	r6, #0
 8000f0e:	d000      	beq.n	8000f12 <chHeapStatus+0x32>
    *sizep = sz;
 8000f10:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 8000f12:	1c28      	adds	r0, r5, #0
 8000f14:	f7ff fd0c 	bl	8000930 <chMtxUnlock>

  return n;
}
 8000f18:	1c20      	adds	r0, r4, #0
 8000f1a:	bd70      	pop	{r4, r5, r6, pc}
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8000f1c:	4c00      	ldr	r4, [pc, #0]	; (8000f20 <chHeapStatus+0x40>)
 8000f1e:	e7e4      	b.n	8000eea <chHeapStatus+0xa>
 8000f20:	20001070 	.word	0x20001070
 8000f24:	46c0      	nop			; (mov r8, r8)
 8000f26:	46c0      	nop			; (mov r8, r8)
 8000f28:	46c0      	nop			; (mov r8, r8)
 8000f2a:	46c0      	nop			; (mov r8, r8)
 8000f2c:	46c0      	nop			; (mov r8, r8)
 8000f2e:	46c0      	nop			; (mov r8, r8)

08000f30 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8000f30:	b570      	push	{r4, r5, r6, lr}
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8000f32:	3808      	subs	r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8000f34:	6806      	ldr	r6, [r0, #0]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8000f36:	1c04      	adds	r4, r0, #0
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000f38:	1c35      	adds	r5, r6, #0

  H_LOCK(heapp);
 8000f3a:	3610      	adds	r6, #16

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000f3c:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8000f3e:	1c30      	adds	r0, r6, #0
 8000f40:	f7ff ffc6 	bl	8000ed0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000f44:	1c2b      	adds	r3, r5, #0

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000f46:	42ab      	cmp	r3, r5
 8000f48:	d004      	beq.n	8000f54 <chHeapFree+0x24>
 8000f4a:	42a3      	cmp	r3, r4
 8000f4c:	d302      	bcc.n	8000f54 <chHeapFree+0x24>
 8000f4e:	681b      	ldr	r3, [r3, #0]
 8000f50:	42ab      	cmp	r3, r5
 8000f52:	d1fa      	bne.n	8000f4a <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f54:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000f56:	2a00      	cmp	r2, #0
 8000f58:	d003      	beq.n	8000f62 <chHeapFree+0x32>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f5a:	4294      	cmp	r4, r2
 8000f5c:	d301      	bcc.n	8000f62 <chHeapFree+0x32>
 8000f5e:	1c13      	adds	r3, r2, #0
 8000f60:	e7f1      	b.n	8000f46 <chHeapFree+0x16>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000f62:	6861      	ldr	r1, [r4, #4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8000f64:	6022      	str	r2, [r4, #0]
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000f66:	1c0a      	adds	r2, r1, #0

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
 8000f68:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000f6a:	3208      	adds	r2, #8
 8000f6c:	6820      	ldr	r0, [r4, #0]
 8000f6e:	18a2      	adds	r2, r4, r2
 8000f70:	4282      	cmp	r2, r0
 8000f72:	d009      	beq.n	8000f88 <chHeapFree+0x58>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8000f74:	6859      	ldr	r1, [r3, #4]
 8000f76:	1c0a      	adds	r2, r1, #0
 8000f78:	3208      	adds	r2, #8
 8000f7a:	189a      	adds	r2, r3, r2
 8000f7c:	4294      	cmp	r4, r2
 8000f7e:	d010      	beq.n	8000fa2 <chHeapFree+0x72>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8000f80:	1c30      	adds	r0, r6, #0
 8000f82:	f7ff fcd5 	bl	8000930 <chMtxUnlock>

  return;
}
 8000f86:	bd70      	pop	{r4, r5, r6, pc}
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8000f88:	6850      	ldr	r0, [r2, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8000f8a:	6812      	ldr	r2, [r2, #0]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8000f8c:	4684      	mov	ip, r0
 8000f8e:	4461      	add	r1, ip
 8000f90:	3108      	adds	r1, #8
 8000f92:	6061      	str	r1, [r4, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8000f94:	6859      	ldr	r1, [r3, #4]
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
 8000f96:	6022      	str	r2, [r4, #0]
      }
      if ((LIMIT(qp) == hp)) {
 8000f98:	1c0a      	adds	r2, r1, #0
 8000f9a:	3208      	adds	r2, #8
 8000f9c:	189a      	adds	r2, r3, r2
 8000f9e:	4294      	cmp	r4, r2
 8000fa0:	d1ee      	bne.n	8000f80 <chHeapFree+0x50>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8000fa2:	6862      	ldr	r2, [r4, #4]
 8000fa4:	4694      	mov	ip, r2
        qp->h.u.next = hp->h.u.next;
 8000fa6:	6822      	ldr	r2, [r4, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8000fa8:	4461      	add	r1, ip
 8000faa:	3108      	adds	r1, #8
 8000fac:	6059      	str	r1, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8000fae:	601a      	str	r2, [r3, #0]
 8000fb0:	e7e6      	b.n	8000f80 <chHeapFree+0x50>
 8000fb2:	46c0      	nop			; (mov r8, r8)
 8000fb4:	46c0      	nop			; (mov r8, r8)
 8000fb6:	46c0      	nop			; (mov r8, r8)
 8000fb8:	46c0      	nop			; (mov r8, r8)
 8000fba:	46c0      	nop			; (mov r8, r8)
 8000fbc:	46c0      	nop			; (mov r8, r8)
 8000fbe:	46c0      	nop			; (mov r8, r8)

08000fc0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8000fc0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fc2:	b672      	cpsid	i
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 8000fc4:	7f83      	ldrb	r3, [r0, #30]
 8000fc6:	3b01      	subs	r3, #1
 8000fc8:	b2db      	uxtb	r3, r3
 8000fca:	7783      	strb	r3, [r0, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fcc:	b662      	cpsie	i
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d102      	bne.n	8000fd8 <chThdRelease+0x18>
 8000fd2:	7f03      	ldrb	r3, [r0, #28]
 8000fd4:	2b0f      	cmp	r3, #15
 8000fd6:	d000      	beq.n	8000fda <chThdRelease+0x1a>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 8000fd8:	bd08      	pop	{r3, pc}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8000fda:	2203      	movs	r2, #3
 8000fdc:	7f43      	ldrb	r3, [r0, #29]
 8000fde:	4013      	ands	r3, r2
 8000fe0:	2b01      	cmp	r3, #1
 8000fe2:	d00d      	beq.n	8001000 <chThdRelease+0x40>
 8000fe4:	2b02      	cmp	r3, #2
 8000fe6:	d1f7      	bne.n	8000fd8 <chThdRelease+0x18>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8000fe8:	6943      	ldr	r3, [r0, #20]
 8000fea:	6902      	ldr	r2, [r0, #16]
 8000fec:	611a      	str	r2, [r3, #16]
 8000fee:	6902      	ldr	r2, [r0, #16]
 8000ff0:	6153      	str	r3, [r2, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 8000ff2:	6c03      	ldr	r3, [r0, #64]	; 0x40
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ff4:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8000ff6:	681a      	ldr	r2, [r3, #0]
 8000ff8:	6002      	str	r2, [r0, #0]
  mp->mp_next = php;
 8000ffa:	6018      	str	r0, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ffc:	b662      	cpsie	i
 8000ffe:	e7eb      	b.n	8000fd8 <chThdRelease+0x18>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001000:	6902      	ldr	r2, [r0, #16]
 8001002:	6943      	ldr	r3, [r0, #20]
 8001004:	611a      	str	r2, [r3, #16]
 8001006:	6902      	ldr	r2, [r0, #16]
 8001008:	6153      	str	r3, [r2, #20]
#endif
      chHeapFree(tp);
 800100a:	f7ff ff91 	bl	8000f30 <chHeapFree>
 800100e:	e7e3      	b.n	8000fd8 <chThdRelease+0x18>

08001010 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001010:	b538      	push	{r3, r4, r5, lr}
 8001012:	1c04      	adds	r4, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001014:	b672      	cpsid	i
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 8001016:	7f03      	ldrb	r3, [r0, #28]
 8001018:	2b0f      	cmp	r3, #15
 800101a:	d007      	beq.n	800102c <chThdWait+0x1c>
    list_insert(currp, &tp->p_waiting);
 800101c:	4b07      	ldr	r3, [pc, #28]	; (800103c <chThdWait+0x2c>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 800101e:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001020:	699b      	ldr	r3, [r3, #24]
 8001022:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8001024:	6243      	str	r3, [r0, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001026:	2009      	movs	r0, #9
 8001028:	f7ff fcfa 	bl	8000a20 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 800102c:	6a25      	ldr	r5, [r4, #32]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800102e:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001030:	1c20      	adds	r0, r4, #0
 8001032:	f7ff ffc5 	bl	8000fc0 <chThdRelease>
#endif

  return msg;
}
 8001036:	1c28      	adds	r0, r5, #0
 8001038:	bd38      	pop	{r3, r4, r5, pc}
 800103a:	46c0      	nop			; (mov r8, r8)
 800103c:	20000f20 	.word	0x20000f20

08001040 <test_wait_threads>:
}

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8001040:	b570      	push	{r4, r5, r6, lr}
 8001042:	4c07      	ldr	r4, [pc, #28]	; (8001060 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8001044:	2600      	movs	r6, #0
 8001046:	1c25      	adds	r5, r4, #0
 8001048:	3514      	adds	r5, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 800104a:	6820      	ldr	r0, [r4, #0]
 800104c:	2800      	cmp	r0, #0
 800104e:	d002      	beq.n	8001056 <test_wait_threads+0x16>
      chThdWait(threads[i]);
 8001050:	f7ff ffde 	bl	8001010 <chThdWait>
      threads[i] = NULL;
 8001054:	6026      	str	r6, [r4, #0]
 8001056:	3404      	adds	r4, #4
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8001058:	42ac      	cmp	r4, r5
 800105a:	d1f6      	bne.n	800104a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800105c:	bd70      	pop	{r4, r5, r6, pc}
 800105e:	46c0      	nop			; (mov r8, r8)
 8001060:	20001090 	.word	0x20001090
 8001064:	46c0      	nop			; (mov r8, r8)
 8001066:	46c0      	nop			; (mov r8, r8)
 8001068:	46c0      	nop			; (mov r8, r8)
 800106a:	46c0      	nop			; (mov r8, r8)
 800106c:	46c0      	nop			; (mov r8, r8)
 800106e:	46c0      	nop			; (mov r8, r8)

08001070 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8001070:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001072:	4647      	mov	r7, r8
 8001074:	b480      	push	{r7}
 8001076:	1e07      	subs	r7, r0, #0
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8001078:	d039      	beq.n	80010ee <chHeapAlloc+0x7e>
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 800107a:	2307      	movs	r3, #7
 800107c:	1dce      	adds	r6, r1, #7
 800107e:	439e      	bics	r6, r3
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8001080:	3309      	adds	r3, #9
 8001082:	4698      	mov	r8, r3
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 8001084:	1c3d      	adds	r5, r7, #0

  H_LOCK(heapp);
 8001086:	44b8      	add	r8, r7
 8001088:	4640      	mov	r0, r8
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 800108a:	3508      	adds	r5, #8

  H_LOCK(heapp);
 800108c:	f7ff ff20 	bl	8000ed0 <chMtxLock>
 8001090:	e003      	b.n	800109a <chHeapAlloc+0x2a>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8001092:	6863      	ldr	r3, [r4, #4]
 8001094:	429e      	cmp	r6, r3
 8001096:	d914      	bls.n	80010c2 <chHeapAlloc+0x52>
 8001098:	1c25      	adds	r5, r4, #0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800109a:	682c      	ldr	r4, [r5, #0]
 800109c:	2c00      	cmp	r4, #0
 800109e:	d1f8      	bne.n	8001092 <chHeapAlloc+0x22>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 80010a0:	4640      	mov	r0, r8
 80010a2:	f7ff fc45 	bl	8000930 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 80010a6:	683b      	ldr	r3, [r7, #0]
 80010a8:	2b00      	cmp	r3, #0
 80010aa:	d022      	beq.n	80010f2 <chHeapAlloc+0x82>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 80010ac:	1c30      	adds	r0, r6, #0
 80010ae:	3008      	adds	r0, #8
 80010b0:	4798      	blx	r3
    if (hp != NULL) {
 80010b2:	2800      	cmp	r0, #0
 80010b4:	d01d      	beq.n	80010f2 <chHeapAlloc+0x82>
      hp->h.u.heap = heapp;
 80010b6:	6007      	str	r7, [r0, #0]
      hp->h.size = size;
 80010b8:	6046      	str	r6, [r0, #4]
      hp++;
 80010ba:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 80010bc:	bc04      	pop	{r2}
 80010be:	4690      	mov	r8, r2
 80010c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 80010c2:	1c32      	adds	r2, r6, #0
 80010c4:	3208      	adds	r2, #8
 80010c6:	429a      	cmp	r2, r3
 80010c8:	d908      	bls.n	80010dc <chHeapAlloc+0x6c>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80010ca:	6823      	ldr	r3, [r4, #0]
 80010cc:	602b      	str	r3, [r5, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
      H_UNLOCK(heapp);
 80010ce:	4640      	mov	r0, r8
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 80010d0:	6027      	str	r7, [r4, #0]
      H_UNLOCK(heapp);
 80010d2:	f7ff fc2d 	bl	8000930 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 80010d6:	1c20      	adds	r0, r4, #0
 80010d8:	3008      	adds	r0, #8
 80010da:	e7ef      	b.n	80010bc <chHeapAlloc+0x4c>
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80010dc:	6821      	ldr	r1, [r4, #0]
 80010de:	1b9b      	subs	r3, r3, r6
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80010e0:	18a2      	adds	r2, r4, r2
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80010e2:	3b08      	subs	r3, #8
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80010e4:	6011      	str	r1, [r2, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80010e6:	6053      	str	r3, [r2, #4]
        qp->h.u.next = fp;
 80010e8:	602a      	str	r2, [r5, #0]
        hp->h.size = size;
 80010ea:	6066      	str	r6, [r4, #4]
 80010ec:	e7ef      	b.n	80010ce <chHeapAlloc+0x5e>
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 80010ee:	4f02      	ldr	r7, [pc, #8]	; (80010f8 <chHeapAlloc+0x88>)
 80010f0:	e7c3      	b.n	800107a <chHeapAlloc+0xa>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 80010f2:	2000      	movs	r0, #0
 80010f4:	e7e2      	b.n	80010bc <chHeapAlloc+0x4c>
 80010f6:	46c0      	nop			; (mov r8, r8)
 80010f8:	20001070 	.word	0x20001070
 80010fc:	46c0      	nop			; (mov r8, r8)
 80010fe:	46c0      	nop			; (mov r8, r8)

08001100 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001100:	b508      	push	{r3, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001102:	6883      	ldr	r3, [r0, #8]
 8001104:	3301      	adds	r3, #1
 8001106:	6083      	str	r3, [r0, #8]
 8001108:	2b00      	cmp	r3, #0
 800110a:	dd00      	ble.n	800110e <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 800110c:	bd08      	pop	{r3, pc}
 800110e:	1c03      	adds	r3, r0, #0
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001110:	6800      	ldr	r0, [r0, #0]

  tqp->p_next = tp->p_next;
 8001112:	6802      	ldr	r2, [r0, #0]
 8001114:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001116:	6053      	str	r3, [r2, #4]

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001118:	2300      	movs	r3, #0
 800111a:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 800111c:	f7ff fcd0 	bl	8000ac0 <chSchReadyI>
 8001120:	e7f4      	b.n	800110c <chSemSignalI+0xc>
 8001122:	46c0      	nop			; (mov r8, r8)
 8001124:	46c0      	nop			; (mov r8, r8)
 8001126:	46c0      	nop			; (mov r8, r8)
 8001128:	46c0      	nop			; (mov r8, r8)
 800112a:	46c0      	nop			; (mov r8, r8)
 800112c:	46c0      	nop			; (mov r8, r8)
 800112e:	46c0      	nop			; (mov r8, r8)

08001130 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001130:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001132:	6885      	ldr	r5, [r0, #8]
  sp->s_cnt = n;
 8001134:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8001136:	3501      	adds	r5, #1
 8001138:	2d00      	cmp	r5, #0
 800113a:	dc0c      	bgt.n	8001156 <chSemResetI+0x26>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800113c:	2602      	movs	r6, #2
 800113e:	1c04      	adds	r4, r0, #0
 8001140:	4276      	negs	r6, r6

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8001142:	6860      	ldr	r0, [r4, #4]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001144:	3501      	adds	r5, #1

  tqp->p_prev = tp->p_prev;
 8001146:	6843      	ldr	r3, [r0, #4]
 8001148:	6063      	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800114a:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800114c:	f7ff fcb8 	bl	8000ac0 <chSchReadyI>
 8001150:	6206      	str	r6, [r0, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001152:	2d01      	cmp	r5, #1
 8001154:	d1f5      	bne.n	8001142 <chSemResetI+0x12>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001156:	bd70      	pop	{r4, r5, r6, pc}
 8001158:	46c0      	nop			; (mov r8, r8)
 800115a:	46c0      	nop			; (mov r8, r8)
 800115c:	46c0      	nop			; (mov r8, r8)
 800115e:	46c0      	nop			; (mov r8, r8)

08001160 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001160:	b538      	push	{r3, r4, r5, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001162:	b672      	cpsid	i
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001164:	4b0d      	ldr	r3, [pc, #52]	; (800119c <chThdExit+0x3c>)
 8001166:	699c      	ldr	r4, [r3, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001168:	1c25      	adds	r5, r4, #0
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 800116a:	6220      	str	r0, [r4, #32]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800116c:	6a60      	ldr	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800116e:	3524      	adds	r5, #36	; 0x24
 8001170:	42a8      	cmp	r0, r5
 8001172:	d006      	beq.n	8001182 <chThdExit+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001174:	6803      	ldr	r3, [r0, #0]
 8001176:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001178:	f7ff fca2 	bl	8000ac0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800117c:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800117e:	42a8      	cmp	r0, r5
 8001180:	d1f8      	bne.n	8001174 <chThdExit+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001182:	7f63      	ldrb	r3, [r4, #29]
 8001184:	079b      	lsls	r3, r3, #30
 8001186:	d104      	bne.n	8001192 <chThdExit+0x32>
    REG_REMOVE(tp);
 8001188:	6922      	ldr	r2, [r4, #16]
 800118a:	6963      	ldr	r3, [r4, #20]
 800118c:	611a      	str	r2, [r3, #16]
 800118e:	6922      	ldr	r2, [r4, #16]
 8001190:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001192:	200f      	movs	r0, #15
 8001194:	f7ff fc44 	bl	8000a20 <chSchGoSleepS>
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8001198:	bd38      	pop	{r3, r4, r5, pc}
 800119a:	46c0      	nop			; (mov r8, r8)
 800119c:	20000f20 	.word	0x20000f20

080011a0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80011a0:	4b1b      	ldr	r3, [pc, #108]	; (8001210 <chVTDoResetI+0x70>)
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80011a2:	b510      	push	{r4, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80011a4:	69da      	ldr	r2, [r3, #28]
 80011a6:	4282      	cmp	r2, r0
 80011a8:	d00e      	beq.n	80011c8 <chVTDoResetI+0x28>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80011aa:	6841      	ldr	r1, [r0, #4]
 80011ac:	6802      	ldr	r2, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80011ae:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80011b0:	600a      	str	r2, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80011b2:	6802      	ldr	r2, [r0, #0]
 80011b4:	6051      	str	r1, [r2, #4]
    vtp->vt_func = NULL;
 80011b6:	2100      	movs	r1, #0
 80011b8:	60c1      	str	r1, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80011ba:	429a      	cmp	r2, r3
 80011bc:	d003      	beq.n	80011c6 <chVTDoResetI+0x26>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 80011be:	8901      	ldrh	r1, [r0, #8]
 80011c0:	8913      	ldrh	r3, [r2, #8]
 80011c2:	18cb      	adds	r3, r1, r3
 80011c4:	8113      	strh	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80011c6:	bd10      	pop	{r4, pc}
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80011c8:	1c18      	adds	r0, r3, #0
  vtp->vt_func = NULL;
 80011ca:	2400      	movs	r4, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80011cc:	6811      	ldr	r1, [r2, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80011ce:	301c      	adds	r0, #28

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80011d0:	61d9      	str	r1, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80011d2:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 80011d4:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80011d6:	4281      	cmp	r1, r0
 80011d8:	d017      	beq.n	800120a <chVTDoResetI+0x6a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80011da:	8910      	ldrh	r0, [r2, #8]
 80011dc:	890a      	ldrh	r2, [r1, #8]
 80011de:	1882      	adds	r2, r0, r2
 80011e0:	b292      	uxth	r2, r2
 80011e2:	810a      	strh	r2, [r1, #8]
 80011e4:	490b      	ldr	r1, [pc, #44]	; (8001214 <chVTDoResetI+0x74>)
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80011e6:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80011e8:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80011ea:	b289      	uxth	r1, r1
 80011ec:	1acb      	subs	r3, r1, r3
 80011ee:	b29b      	uxth	r3, r3

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80011f0:	429a      	cmp	r2, r3
 80011f2:	d9e8      	bls.n	80011c6 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80011f4:	1ad2      	subs	r2, r2, r3
 80011f6:	b292      	uxth	r2, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80011f8:	2a01      	cmp	r2, #1
 80011fa:	d904      	bls.n	8001206 <chVTDoResetI+0x66>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80011fc:	1852      	adds	r2, r2, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80011fe:	4b05      	ldr	r3, [pc, #20]	; (8001214 <chVTDoResetI+0x74>)
 8001200:	b292      	uxth	r2, r2
 8001202:	635a      	str	r2, [r3, #52]	; 0x34
 8001204:	e7df      	b.n	80011c6 <chVTDoResetI+0x26>
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001206:	2202      	movs	r2, #2
 8001208:	e7f8      	b.n	80011fc <chVTDoResetI+0x5c>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800120a:	4b02      	ldr	r3, [pc, #8]	; (8001214 <chVTDoResetI+0x74>)
 800120c:	60dc      	str	r4, [r3, #12]
 800120e:	e7da      	b.n	80011c6 <chVTDoResetI+0x26>
 8001210:	20000f20 	.word	0x20000f20
 8001214:	40000400 	.word	0x40000400
 8001218:	46c0      	nop			; (mov r8, r8)
 800121a:	46c0      	nop			; (mov r8, r8)
 800121c:	46c0      	nop			; (mov r8, r8)
 800121e:	46c0      	nop			; (mov r8, r8)

08001220 <chVTDoSetI>:
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001220:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001222:	4b1e      	ldr	r3, [pc, #120]	; (800129c <chVTDoSetI+0x7c>)
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001224:	b570      	push	{r4, r5, r6, lr}
 8001226:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8001228:	60c2      	str	r2, [r0, #12]
 800122a:	b29b      	uxth	r3, r3
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800122c:	2901      	cmp	r1, #1
 800122e:	d924      	bls.n	800127a <chVTDoSetI+0x5a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001230:	4d1b      	ldr	r5, [pc, #108]	; (80012a0 <chVTDoSetI+0x80>)
 8001232:	1c2c      	adds	r4, r5, #0
 8001234:	69ea      	ldr	r2, [r5, #28]
 8001236:	341c      	adds	r4, #28
 8001238:	42a2      	cmp	r2, r4
 800123a:	d020      	beq.n	800127e <chVTDoSetI+0x5e>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800123c:	18c9      	adds	r1, r1, r3
 800123e:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
 8001240:	b289      	uxth	r1, r1
 8001242:	1acb      	subs	r3, r1, r3
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001244:	8914      	ldrh	r4, [r2, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001246:	b29b      	uxth	r3, r3
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001248:	42a3      	cmp	r3, r4
 800124a:	d204      	bcs.n	8001256 <chVTDoSetI+0x36>
 800124c:	e012      	b.n	8001274 <chVTDoSetI+0x54>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 800124e:	6812      	ldr	r2, [r2, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001250:	1b1b      	subs	r3, r3, r4
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001252:	8914      	ldrh	r4, [r2, #8]
    delta -= p->vt_delta;
 8001254:	b29b      	uxth	r3, r3
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001256:	429c      	cmp	r4, r3
 8001258:	d3f9      	bcc.n	800124e <chVTDoSetI+0x2e>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800125a:	6851      	ldr	r1, [r2, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800125c:	6002      	str	r2, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800125e:	6041      	str	r1, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
 8001260:	6008      	str	r0, [r1, #0]
  p->vt_prev = vtp;
 8001262:	6050      	str	r0, [r2, #4]
  vtp->vt_delta = delta
 8001264:	8103      	strh	r3, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001266:	8911      	ldrh	r1, [r2, #8]
 8001268:	1acb      	subs	r3, r1, r3
 800126a:	8113      	strh	r3, [r2, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800126c:	2301      	movs	r3, #1
 800126e:	425b      	negs	r3, r3
 8001270:	84ab      	strh	r3, [r5, #36]	; 0x24
}
 8001272:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001274:	4e09      	ldr	r6, [pc, #36]	; (800129c <chVTDoSetI+0x7c>)
 8001276:	6371      	str	r1, [r6, #52]	; 0x34
 8001278:	e7ed      	b.n	8001256 <chVTDoSetI+0x36>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800127a:	2102      	movs	r1, #2
 800127c:	e7d8      	b.n	8001230 <chVTDoSetI+0x10>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800127e:	84eb      	strh	r3, [r5, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8001280:	61e8      	str	r0, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 8001282:	6228      	str	r0, [r5, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8001284:	18cb      	adds	r3, r1, r3
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8001286:	6002      	str	r2, [r0, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001288:	6042      	str	r2, [r0, #4]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800128a:	4a04      	ldr	r2, [pc, #16]	; (800129c <chVTDoSetI+0x7c>)
 800128c:	b29b      	uxth	r3, r3
      vtp->vt_delta = delay;
 800128e:	8101      	strh	r1, [r0, #8]
 8001290:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001292:	2300      	movs	r3, #0
 8001294:	6113      	str	r3, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001296:	3302      	adds	r3, #2
 8001298:	60d3      	str	r3, [r2, #12]
 800129a:	e7ea      	b.n	8001272 <chVTDoSetI+0x52>
 800129c:	40000400 	.word	0x40000400
 80012a0:	20000f20 	.word	0x20000f20
 80012a4:	46c0      	nop			; (mov r8, r8)
 80012a6:	46c0      	nop			; (mov r8, r8)
 80012a8:	46c0      	nop			; (mov r8, r8)
 80012aa:	46c0      	nop			; (mov r8, r8)
 80012ac:	46c0      	nop			; (mov r8, r8)
 80012ae:	46c0      	nop			; (mov r8, r8)

080012b0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80012b0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80012b2:	4b0e      	ldr	r3, [pc, #56]	; (80012ec <chSchGoSleepTimeoutS+0x3c>)
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80012b4:	b087      	sub	sp, #28
 80012b6:	1c05      	adds	r5, r0, #0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80012b8:	4299      	cmp	r1, r3
 80012ba:	d012      	beq.n	80012e2 <chSchGoSleepTimeoutS+0x32>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80012bc:	4c0c      	ldr	r4, [pc, #48]	; (80012f0 <chSchGoSleepTimeoutS+0x40>)
 80012be:	a801      	add	r0, sp, #4
 80012c0:	69a3      	ldr	r3, [r4, #24]
 80012c2:	4a0c      	ldr	r2, [pc, #48]	; (80012f4 <chSchGoSleepTimeoutS+0x44>)
 80012c4:	f7ff ffac 	bl	8001220 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80012c8:	1c28      	adds	r0, r5, #0
 80012ca:	f7ff fba9 	bl	8000a20 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80012ce:	9b04      	ldr	r3, [sp, #16]
 80012d0:	2b00      	cmp	r3, #0
 80012d2:	d002      	beq.n	80012da <chSchGoSleepTimeoutS+0x2a>
      chVTDoResetI(&vt);
 80012d4:	a801      	add	r0, sp, #4
 80012d6:	f7ff ff63 	bl	80011a0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80012da:	69a3      	ldr	r3, [r4, #24]
 80012dc:	6a18      	ldr	r0, [r3, #32]
}
 80012de:	b007      	add	sp, #28
 80012e0:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80012e2:	f7ff fb9d 	bl	8000a20 <chSchGoSleepS>
 80012e6:	4c02      	ldr	r4, [pc, #8]	; (80012f0 <chSchGoSleepTimeoutS+0x40>)
 80012e8:	e7f7      	b.n	80012da <chSchGoSleepTimeoutS+0x2a>
 80012ea:	46c0      	nop			; (mov r8, r8)
 80012ec:	0000ffff 	.word	0x0000ffff
 80012f0:	20000f20 	.word	0x20000f20
 80012f4:	08000391 	.word	0x08000391
 80012f8:	46c0      	nop			; (mov r8, r8)
 80012fa:	46c0      	nop			; (mov r8, r8)
 80012fc:	46c0      	nop			; (mov r8, r8)
 80012fe:	46c0      	nop			; (mov r8, r8)

08001300 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001300:	b510      	push	{r4, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001302:	6884      	ldr	r4, [r0, #8]
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001304:	1c03      	adds	r3, r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001306:	1e62      	subs	r2, r4, #1
 8001308:	6082      	str	r2, [r0, #8]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 800130a:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800130c:	2a00      	cmp	r2, #0
 800130e:	db00      	blt.n	8001312 <chSemWaitTimeoutS+0x12>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001310:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8001312:	2900      	cmp	r1, #0
 8001314:	d00b      	beq.n	800132e <chSemWaitTimeoutS+0x2e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8001316:	4a07      	ldr	r2, [pc, #28]	; (8001334 <chSemWaitTimeoutS+0x34>)
 8001318:	6992      	ldr	r2, [r2, #24]
 800131a:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800131c:	6858      	ldr	r0, [r3, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800131e:	6013      	str	r3, [r2, #0]
  tp->p_prev = tqp->p_prev;
 8001320:	6050      	str	r0, [r2, #4]
  tp->p_prev->p_next = tp;
 8001322:	6002      	str	r2, [r0, #0]
  tqp->p_prev = tp;
 8001324:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001326:	2005      	movs	r0, #5
 8001328:	f7ff ffc2 	bl	80012b0 <chSchGoSleepTimeoutS>
 800132c:	e7f0      	b.n	8001310 <chSemWaitTimeoutS+0x10>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 800132e:	609c      	str	r4, [r3, #8]

      return MSG_TIMEOUT;
 8001330:	3801      	subs	r0, #1
 8001332:	e7ed      	b.n	8001310 <chSemWaitTimeoutS+0x10>
 8001334:	20000f20 	.word	0x20000f20
 8001338:	46c0      	nop			; (mov r8, r8)
 800133a:	46c0      	nop			; (mov r8, r8)
 800133c:	46c0      	nop			; (mov r8, r8)
 800133e:	46c0      	nop			; (mov r8, r8)

08001340 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001340:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8001342:	2900      	cmp	r1, #0
 8001344:	d00a      	beq.n	800135c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001346:	4b07      	ldr	r3, [pc, #28]	; (8001364 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001348:	6842      	ldr	r2, [r0, #4]
 800134a:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800134c:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800134e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001350:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8001352:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001354:	2004      	movs	r0, #4
 8001356:	f7ff ffab 	bl	80012b0 <chSchGoSleepTimeoutS>
}
 800135a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800135c:	2001      	movs	r0, #1
 800135e:	4240      	negs	r0, r0
 8001360:	e7fb      	b.n	800135a <chThdEnqueueTimeoutS+0x1a>
 8001362:	46c0      	nop			; (mov r8, r8)
 8001364:	20000f20 	.word	0x20000f20
 8001368:	46c0      	nop			; (mov r8, r8)
 800136a:	46c0      	nop			; (mov r8, r8)
 800136c:	46c0      	nop			; (mov r8, r8)
 800136e:	46c0      	nop			; (mov r8, r8)

08001370 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001370:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001372:	464e      	mov	r6, r9
 8001374:	4645      	mov	r5, r8
 8001376:	4657      	mov	r7, sl
 8001378:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 800137a:	69c3      	ldr	r3, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 800137c:	b4e0      	push	{r5, r6, r7}
 800137e:	1c04      	adds	r4, r0, #0
 8001380:	1c0e      	adds	r6, r1, #0
 8001382:	1c15      	adds	r5, r2, #0
  qnotify_t nfy = oqp->q_notify;
 8001384:	4698      	mov	r8, r3
 8001386:	b672      	cpsid	i
  size_t w = 0;
 8001388:	2700      	movs	r7, #0
 800138a:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800138c:	2b00      	cmp	r3, #0
 800138e:	d01d      	beq.n	80013cc <chOQWriteTimeout+0x5c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001390:	3b01      	subs	r3, #1
 8001392:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001394:	6963      	ldr	r3, [r4, #20]
 8001396:	1c5a      	adds	r2, r3, #1
 8001398:	6162      	str	r2, [r4, #20]
 800139a:	1c72      	adds	r2, r6, #1
 800139c:	4692      	mov	sl, r2
 800139e:	7832      	ldrb	r2, [r6, #0]
 80013a0:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80013a2:	6963      	ldr	r3, [r4, #20]
 80013a4:	6922      	ldr	r2, [r4, #16]
 80013a6:	4293      	cmp	r3, r2
 80013a8:	d301      	bcc.n	80013ae <chOQWriteTimeout+0x3e>
      oqp->q_wrptr = oqp->q_buffer;
 80013aa:	68e3      	ldr	r3, [r4, #12]
 80013ac:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 80013ae:	4643      	mov	r3, r8
 80013b0:	2b00      	cmp	r3, #0
 80013b2:	d001      	beq.n	80013b8 <chOQWriteTimeout+0x48>
      nfy(oqp);
 80013b4:	1c20      	adds	r0, r4, #0
 80013b6:	47c0      	blx	r8
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013b8:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80013ba:	3d01      	subs	r5, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80013bc:	3701      	adds	r7, #1
    if (--n == 0U) {
 80013be:	2d00      	cmp	r5, #0
 80013c0:	d00b      	beq.n	80013da <chOQWriteTimeout+0x6a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013c2:	b672      	cpsid	i
 80013c4:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80013c6:	4656      	mov	r6, sl

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	d1e1      	bne.n	8001390 <chOQWriteTimeout+0x20>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80013cc:	1c20      	adds	r0, r4, #0
 80013ce:	4649      	mov	r1, r9
 80013d0:	f7ff ffb6 	bl	8001340 <chThdEnqueueTimeoutS>
 80013d4:	2800      	cmp	r0, #0
 80013d6:	d0d8      	beq.n	800138a <chOQWriteTimeout+0x1a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013d8:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80013da:	1c38      	adds	r0, r7, #0
 80013dc:	bc1c      	pop	{r2, r3, r4}
 80013de:	4690      	mov	r8, r2
 80013e0:	4699      	mov	r9, r3
 80013e2:	46a2      	mov	sl, r4
 80013e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80013e6:	46c0      	nop			; (mov r8, r8)
 80013e8:	46c0      	nop			; (mov r8, r8)
 80013ea:	46c0      	nop			; (mov r8, r8)
 80013ec:	46c0      	nop			; (mov r8, r8)
 80013ee:	46c0      	nop			; (mov r8, r8)

080013f0 <writet.lto_priv.72>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 80013f0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80013f2:	3030      	adds	r0, #48	; 0x30
 80013f4:	f7ff ffbc 	bl	8001370 <chOQWriteTimeout>
}
 80013f8:	bd08      	pop	{r3, pc}
 80013fa:	46c0      	nop			; (mov r8, r8)
 80013fc:	46c0      	nop			; (mov r8, r8)
 80013fe:	46c0      	nop			; (mov r8, r8)

08001400 <write.lto_priv.66>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8001400:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001402:	3030      	adds	r0, #48	; 0x30
 8001404:	4b01      	ldr	r3, [pc, #4]	; (800140c <write.lto_priv.66+0xc>)
 8001406:	f7ff ffb3 	bl	8001370 <chOQWriteTimeout>
                        n, TIME_INFINITE);
}
 800140a:	bd08      	pop	{r3, pc}
 800140c:	0000ffff 	.word	0x0000ffff

08001410 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001410:	b570      	push	{r4, r5, r6, lr}
 8001412:	1c04      	adds	r4, r0, #0
 8001414:	1c0e      	adds	r6, r1, #0
 8001416:	1c15      	adds	r5, r2, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001418:	b672      	cpsid	i
 800141a:	e005      	b.n	8001428 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800141c:	1c20      	adds	r0, r4, #0
 800141e:	1c29      	adds	r1, r5, #0
 8001420:	f7ff ff8e 	bl	8001340 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8001424:	2800      	cmp	r0, #0
 8001426:	db16      	blt.n	8001456 <chOQPutTimeout+0x46>
 8001428:	68a3      	ldr	r3, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800142a:	2b00      	cmp	r3, #0
 800142c:	d0f6      	beq.n	800141c <chOQPutTimeout+0xc>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800142e:	3b01      	subs	r3, #1
 8001430:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001432:	6963      	ldr	r3, [r4, #20]
 8001434:	1c5a      	adds	r2, r3, #1
 8001436:	6162      	str	r2, [r4, #20]
 8001438:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800143a:	6963      	ldr	r3, [r4, #20]
 800143c:	6922      	ldr	r2, [r4, #16]
 800143e:	4293      	cmp	r3, r2
 8001440:	d301      	bcc.n	8001446 <chOQPutTimeout+0x36>
    oqp->q_wrptr = oqp->q_buffer;
 8001442:	68e3      	ldr	r3, [r4, #12]
 8001444:	6163      	str	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8001446:	69e3      	ldr	r3, [r4, #28]
 8001448:	2b00      	cmp	r3, #0
 800144a:	d001      	beq.n	8001450 <chOQPutTimeout+0x40>
    oqp->q_notify(oqp);
 800144c:	1c20      	adds	r0, r4, #0
 800144e:	4798      	blx	r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001450:	b662      	cpsie	i
 8001452:	2000      	movs	r0, #0
  }
  chSysUnlock();

  return Q_OK;
}
 8001454:	bd70      	pop	{r4, r5, r6, pc}
 8001456:	b662      	cpsie	i
 8001458:	e7fc      	b.n	8001454 <chOQPutTimeout+0x44>
 800145a:	46c0      	nop			; (mov r8, r8)
 800145c:	46c0      	nop			; (mov r8, r8)
 800145e:	46c0      	nop			; (mov r8, r8)

08001460 <putt.lto_priv.70>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8001460:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001462:	3030      	adds	r0, #48	; 0x30
 8001464:	f7ff ffd4 	bl	8001410 <chOQPutTimeout>
}
 8001468:	bd08      	pop	{r3, pc}
 800146a:	46c0      	nop			; (mov r8, r8)
 800146c:	46c0      	nop			; (mov r8, r8)
 800146e:	46c0      	nop			; (mov r8, r8)

08001470 <put.lto_priv.68>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8001470:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001472:	3030      	adds	r0, #48	; 0x30
 8001474:	4a01      	ldr	r2, [pc, #4]	; (800147c <put.lto_priv.68+0xc>)
 8001476:	f7ff ffcb 	bl	8001410 <chOQPutTimeout>
}
 800147a:	bd08      	pop	{r3, pc}
 800147c:	0000ffff 	.word	0x0000ffff

08001480 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001482:	464f      	mov	r7, r9
 8001484:	4646      	mov	r6, r8
 8001486:	1c04      	adds	r4, r0, #0
 8001488:	b4c0      	push	{r6, r7}
 800148a:	4689      	mov	r9, r1
 800148c:	4690      	mov	r8, r2
 800148e:	1c1d      	adds	r5, r3, #0
  qnotify_t nfy = iqp->q_notify;
 8001490:	69c7      	ldr	r7, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001492:	b672      	cpsid	i
  size_t r = 0;
 8001494:	2600      	movs	r6, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8001496:	2f00      	cmp	r7, #0
 8001498:	d008      	beq.n	80014ac <chIQReadTimeout+0x2c>
      nfy(iqp);
 800149a:	1c20      	adds	r0, r4, #0
 800149c:	47b8      	blx	r7
 800149e:	e005      	b.n	80014ac <chIQReadTimeout+0x2c>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80014a0:	1c20      	adds	r0, r4, #0
 80014a2:	1c29      	adds	r1, r5, #0
 80014a4:	f7ff ff4c 	bl	8001340 <chThdEnqueueTimeoutS>
 80014a8:	2800      	cmp	r0, #0
 80014aa:	d116      	bne.n	80014da <chIQReadTimeout+0x5a>
 80014ac:	68a3      	ldr	r3, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80014ae:	2b00      	cmp	r3, #0
 80014b0:	d0f6      	beq.n	80014a0 <chIQReadTimeout+0x20>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80014b2:	3b01      	subs	r3, #1
 80014b4:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80014b6:	69a3      	ldr	r3, [r4, #24]
 80014b8:	1c5a      	adds	r2, r3, #1
 80014ba:	61a2      	str	r2, [r4, #24]
 80014bc:	464a      	mov	r2, r9
 80014be:	781b      	ldrb	r3, [r3, #0]
 80014c0:	5593      	strb	r3, [r2, r6]
    if (iqp->q_rdptr >= iqp->q_top) {
 80014c2:	69a3      	ldr	r3, [r4, #24]
 80014c4:	6922      	ldr	r2, [r4, #16]
 80014c6:	4293      	cmp	r3, r2
 80014c8:	d301      	bcc.n	80014ce <chIQReadTimeout+0x4e>
      iqp->q_rdptr = iqp->q_buffer;
 80014ca:	68e3      	ldr	r3, [r4, #12]
 80014cc:	61a3      	str	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014ce:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 80014d0:	3601      	adds	r6, #1
    if (--n == 0U) {
 80014d2:	45b0      	cmp	r8, r6
 80014d4:	d002      	beq.n	80014dc <chIQReadTimeout+0x5c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014d6:	b672      	cpsid	i
 80014d8:	e7dd      	b.n	8001496 <chIQReadTimeout+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014da:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 80014dc:	1c30      	adds	r0, r6, #0
 80014de:	bc0c      	pop	{r2, r3}
 80014e0:	4690      	mov	r8, r2
 80014e2:	4699      	mov	r9, r3
 80014e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80014e6:	46c0      	nop			; (mov r8, r8)
 80014e8:	46c0      	nop			; (mov r8, r8)
 80014ea:	46c0      	nop			; (mov r8, r8)
 80014ec:	46c0      	nop			; (mov r8, r8)
 80014ee:	46c0      	nop			; (mov r8, r8)

080014f0 <readt.lto_priv.73>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 80014f0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80014f2:	300c      	adds	r0, #12
 80014f4:	f7ff ffc4 	bl	8001480 <chIQReadTimeout>
}
 80014f8:	bd08      	pop	{r3, pc}
 80014fa:	46c0      	nop			; (mov r8, r8)
 80014fc:	46c0      	nop			; (mov r8, r8)
 80014fe:	46c0      	nop			; (mov r8, r8)

08001500 <read.lto_priv.67>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8001500:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001502:	300c      	adds	r0, #12
 8001504:	4b01      	ldr	r3, [pc, #4]	; (800150c <read.lto_priv.67+0xc>)
 8001506:	f7ff ffbb 	bl	8001480 <chIQReadTimeout>
                       n, TIME_INFINITE);
}
 800150a:	bd08      	pop	{r3, pc}
 800150c:	0000ffff 	.word	0x0000ffff

08001510 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001510:	b538      	push	{r3, r4, r5, lr}
 8001512:	1c04      	adds	r4, r0, #0
 8001514:	1c0d      	adds	r5, r1, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001516:	b672      	cpsid	i
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8001518:	69c3      	ldr	r3, [r0, #28]
 800151a:	2b00      	cmp	r3, #0
 800151c:	d007      	beq.n	800152e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 800151e:	4798      	blx	r3
 8001520:	e005      	b.n	800152e <chIQGetTimeout+0x1e>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001522:	1c20      	adds	r0, r4, #0
 8001524:	1c29      	adds	r1, r5, #0
 8001526:	f7ff ff0b 	bl	8001340 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800152a:	2800      	cmp	r0, #0
 800152c:	db0d      	blt.n	800154a <chIQGetTimeout+0x3a>
 800152e:	68a3      	ldr	r3, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8001530:	2b00      	cmp	r3, #0
 8001532:	d0f6      	beq.n	8001522 <chIQGetTimeout+0x12>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001534:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001536:	3b01      	subs	r3, #1
 8001538:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800153a:	1c53      	adds	r3, r2, #1
 800153c:	61a3      	str	r3, [r4, #24]
 800153e:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001540:	6922      	ldr	r2, [r4, #16]
 8001542:	4293      	cmp	r3, r2
 8001544:	d301      	bcc.n	800154a <chIQGetTimeout+0x3a>
    iqp->q_rdptr = iqp->q_buffer;
 8001546:	68e3      	ldr	r3, [r4, #12]
 8001548:	61a3      	str	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800154a:	b662      	cpsie	i
  }
  chSysUnlock();

  return (msg_t)b;
}
 800154c:	bd38      	pop	{r3, r4, r5, pc}
 800154e:	46c0      	nop			; (mov r8, r8)

08001550 <gett.lto_priv.71>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 8001550:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001552:	300c      	adds	r0, #12
 8001554:	f7ff ffdc 	bl	8001510 <chIQGetTimeout>
}
 8001558:	bd08      	pop	{r3, pc}
 800155a:	46c0      	nop			; (mov r8, r8)
 800155c:	46c0      	nop			; (mov r8, r8)
 800155e:	46c0      	nop			; (mov r8, r8)

08001560 <get.lto_priv.69>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 8001560:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001562:	300c      	adds	r0, #12
 8001564:	4901      	ldr	r1, [pc, #4]	; (800156c <get.lto_priv.69+0xc>)
 8001566:	f7ff ffd3 	bl	8001510 <chIQGetTimeout>
}
 800156a:	bd08      	pop	{r3, pc}
 800156c:	0000ffff 	.word	0x0000ffff

08001570 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001570:	b508      	push	{r3, lr}
 8001572:	1c01      	adds	r1, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001574:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001576:	2008      	movs	r0, #8
 8001578:	f7ff fe9a 	bl	80012b0 <chSchGoSleepTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800157c:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 800157e:	bd08      	pop	{r3, pc}

08001580 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8001580:	b508      	push	{r3, lr}

  chThdSleep(1);
 8001582:	2001      	movs	r0, #1
 8001584:	f7ff fff4 	bl	8001570 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001588:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800158a:	4b02      	ldr	r3, [pc, #8]	; (8001594 <test_wait_tick+0x14>)
 800158c:	6a58      	ldr	r0, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800158e:	b662      	cpsie	i
  return chVTGetSystemTime();
 8001590:	b280      	uxth	r0, r0
}
 8001592:	bd08      	pop	{r3, pc}
 8001594:	40000400 	.word	0x40000400
 8001598:	46c0      	nop			; (mov r8, r8)
 800159a:	46c0      	nop			; (mov r8, r8)
 800159c:	46c0      	nop			; (mov r8, r8)
 800159e:	46c0      	nop			; (mov r8, r8)

080015a0 <chSysRestoreStatusX.part.2.lto_priv.142>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80015a0:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80015a2:	f3ef 8305 	mrs	r3, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80015a6:	05db      	lsls	r3, r3, #23

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80015a8:	d101      	bne.n	80015ae <chSysRestoreStatusX.part.2.lto_priv.142+0xe>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80015aa:	f7ff f971 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80015ae:	b662      	cpsie	i
      chSysUnlock();
    }
  }
}
 80015b0:	bd08      	pop	{r3, pc}
 80015b2:	46c0      	nop			; (mov r8, r8)
 80015b4:	46c0      	nop			; (mov r8, r8)
 80015b6:	46c0      	nop			; (mov r8, r8)
 80015b8:	46c0      	nop			; (mov r8, r8)
 80015ba:	46c0      	nop			; (mov r8, r8)
 80015bc:	46c0      	nop			; (mov r8, r8)
 80015be:	46c0      	nop			; (mov r8, r8)

080015c0 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80015c0:	f3ef 8010 	mrs	r0, PRIMASK
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 80015c4:	07c3      	lsls	r3, r0, #31
 80015c6:	d402      	bmi.n	80015ce <chSysGetStatusAndLockX+0xe>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80015c8:	f3ef 8305 	mrs	r3, IPSR
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80015cc:	b672      	cpsid	i
    else {
      chSysLock();
    }
  }
  return sts;
}
 80015ce:	4770      	bx	lr

080015d0 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 80015d0:	b530      	push	{r4, r5, lr}
 80015d2:	1c05      	adds	r5, r0, #0
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80015d4:	07c3      	lsls	r3, r0, #31
 80015d6:	d511      	bpl.n	80015fc <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 80015d8:	4a28      	ldr	r2, [pc, #160]	; (800167c <chSysIntegrityCheckI+0xac>)
 80015da:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80015dc:	4291      	cmp	r1, r2
 80015de:	d03c      	beq.n	800165a <chSysIntegrityCheckI+0x8a>
 80015e0:	2300      	movs	r3, #0
      n++;
      tp = tp->p_next;
 80015e2:	6809      	ldr	r1, [r1, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 80015e4:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80015e6:	4291      	cmp	r1, r2
 80015e8:	d1fb      	bne.n	80015e2 <chSysIntegrityCheckI+0x12>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 80015ea:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80015ec:	428c      	cmp	r4, r1
 80015ee:	d032      	beq.n	8001656 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->p_prev;
 80015f0:	6864      	ldr	r4, [r4, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 80015f2:	3b01      	subs	r3, #1
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80015f4:	4294      	cmp	r4, r2
 80015f6:	d1fb      	bne.n	80015f0 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80015f8:	2b00      	cmp	r3, #0
 80015fa:	d12c      	bne.n	8001656 <chSysIntegrityCheckI+0x86>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80015fc:	07ab      	lsls	r3, r5, #30
 80015fe:	d513      	bpl.n	8001628 <chSysIntegrityCheckI+0x58>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 8001600:	4b1e      	ldr	r3, [pc, #120]	; (800167c <chSysIntegrityCheckI+0xac>)
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001602:	1c1c      	adds	r4, r3, #0
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 8001604:	69da      	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001606:	341c      	adds	r4, #28
 8001608:	42a2      	cmp	r2, r4
 800160a:	d02b      	beq.n	8001664 <chSysIntegrityCheckI+0x94>
 800160c:	2300      	movs	r3, #0
      n++;
      vtp = vtp->vt_next;
 800160e:	6812      	ldr	r2, [r2, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 8001610:	3301      	adds	r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001612:	42a2      	cmp	r2, r4
 8001614:	d1fb      	bne.n	800160e <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 8001616:	6851      	ldr	r1, [r2, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001618:	4291      	cmp	r1, r2
 800161a:	d01c      	beq.n	8001656 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
 800161c:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800161e:	3b01      	subs	r3, #1
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001620:	42a1      	cmp	r1, r4
 8001622:	d1fb      	bne.n	800161c <chSysIntegrityCheckI+0x4c>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001624:	2b00      	cmp	r3, #0
 8001626:	d116      	bne.n	8001656 <chSysIntegrityCheckI+0x86>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8001628:	2000      	movs	r0, #0
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800162a:	076b      	lsls	r3, r5, #29
 800162c:	d512      	bpl.n	8001654 <chSysIntegrityCheckI+0x84>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
 800162e:	4a13      	ldr	r2, [pc, #76]	; (800167c <chSysIntegrityCheckI+0xac>)
 8001630:	6911      	ldr	r1, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001632:	4291      	cmp	r1, r2
 8001634:	d01c      	beq.n	8001670 <chSysIntegrityCheckI+0xa0>
 8001636:	2300      	movs	r3, #0
      n++;
      tp = tp->p_newer;
 8001638:	6909      	ldr	r1, [r1, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 800163a:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 800163c:	4291      	cmp	r1, r2
 800163e:	d1fb      	bne.n	8001638 <chSysIntegrityCheckI+0x68>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 8001640:	694c      	ldr	r4, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8001642:	428c      	cmp	r4, r1
 8001644:	d007      	beq.n	8001656 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->p_older;
 8001646:	6964      	ldr	r4, [r4, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 8001648:	3b01      	subs	r3, #1
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 800164a:	4294      	cmp	r4, r2
 800164c:	d1fb      	bne.n	8001646 <chSysIntegrityCheckI+0x76>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800164e:	1e58      	subs	r0, r3, #1
 8001650:	4183      	sbcs	r3, r0
 8001652:	b2d8      	uxtb	r0, r3
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8001654:	bd30      	pop	{r4, r5, pc}
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 8001656:	2001      	movs	r0, #1
 8001658:	e7fc      	b.n	8001654 <chSysIntegrityCheckI+0x84>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800165a:	6854      	ldr	r4, [r2, #4]
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800165c:	2300      	movs	r3, #0
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800165e:	4294      	cmp	r4, r2
 8001660:	d1c6      	bne.n	80015f0 <chSysIntegrityCheckI+0x20>
 8001662:	e7cb      	b.n	80015fc <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 8001664:	6a19      	ldr	r1, [r3, #32]
 8001666:	1c14      	adds	r4, r2, #0
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8001668:	2300      	movs	r3, #0
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800166a:	4291      	cmp	r1, r2
 800166c:	d1d6      	bne.n	800161c <chSysIntegrityCheckI+0x4c>
 800166e:	e7db      	b.n	8001628 <chSysIntegrityCheckI+0x58>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 8001670:	694c      	ldr	r4, [r1, #20]
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 8001672:	2300      	movs	r3, #0
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8001674:	428c      	cmp	r4, r1
 8001676:	d1e6      	bne.n	8001646 <chSysIntegrityCheckI+0x76>
 8001678:	e7ec      	b.n	8001654 <chSysIntegrityCheckI+0x84>
 800167a:	46c0      	nop			; (mov r8, r8)
 800167c:	20000f20 	.word	0x20000f20

08001680 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001680:	e7fe      	b.n	8001680 <__default_exit>
 8001682:	46c0      	nop			; (mov r8, r8)
 8001684:	46c0      	nop			; (mov r8, r8)
 8001686:	46c0      	nop			; (mov r8, r8)
 8001688:	46c0      	nop			; (mov r8, r8)
 800168a:	46c0      	nop			; (mov r8, r8)
 800168c:	46c0      	nop			; (mov r8, r8)
 800168e:	46c0      	nop			; (mov r8, r8)

08001690 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001690:	4770      	bx	lr
 8001692:	46c0      	nop			; (mov r8, r8)
 8001694:	46c0      	nop			; (mov r8, r8)
 8001696:	46c0      	nop			; (mov r8, r8)
 8001698:	46c0      	nop			; (mov r8, r8)
 800169a:	46c0      	nop			; (mov r8, r8)
 800169c:	46c0      	nop			; (mov r8, r8)
 800169e:	46c0      	nop			; (mov r8, r8)

080016a0 <mtx5_setup.lto_priv.92>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80016a0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016a2:	4b02      	ldr	r3, [pc, #8]	; (80016ac <mtx5_setup.lto_priv.92+0xc>)
 80016a4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016a6:	605b      	str	r3, [r3, #4]
 80016a8:	609a      	str	r2, [r3, #8]
 */

static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}
 80016aa:	4770      	bx	lr
 80016ac:	2000063c 	.word	0x2000063c

080016b0 <mtx4_setup.lto_priv.90>:
 80016b0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016b2:	4b04      	ldr	r3, [pc, #16]	; (80016c4 <mtx4_setup.lto_priv.90+0x14>)
 80016b4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016b6:	605b      	str	r3, [r3, #4]
 80016b8:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016ba:	4b03      	ldr	r3, [pc, #12]	; (80016c8 <mtx4_setup.lto_priv.90+0x18>)
 80016bc:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016be:	605b      	str	r3, [r3, #4]
 80016c0:	609a      	str	r2, [r3, #8]

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 80016c2:	4770      	bx	lr
 80016c4:	2000063c 	.word	0x2000063c
 80016c8:	2000064c 	.word	0x2000064c
 80016cc:	46c0      	nop			; (mov r8, r8)
 80016ce:	46c0      	nop			; (mov r8, r8)

080016d0 <mtx1_setup.lto_priv.88>:
 80016d0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016d2:	4b02      	ldr	r3, [pc, #8]	; (80016dc <mtx1_setup.lto_priv.88+0xc>)
 80016d4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016d6:	605b      	str	r3, [r3, #4]
 80016d8:	609a      	str	r2, [r3, #8]
 */

static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}
 80016da:	4770      	bx	lr
 80016dc:	2000063c 	.word	0x2000063c

080016e0 <sem3_setup.lto_priv.85>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 80016e0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016e2:	4b02      	ldr	r3, [pc, #8]	; (80016ec <sem3_setup.lto_priv.85+0xc>)
 80016e4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016e6:	605b      	str	r3, [r3, #4]
 80016e8:	609a      	str	r2, [r3, #8]
 */

static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80016ea:	4770      	bx	lr
 80016ec:	20000600 	.word	0x20000600

080016f0 <sem2_setup.lto_priv.83>:
 80016f0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016f2:	4b02      	ldr	r3, [pc, #8]	; (80016fc <sem2_setup.lto_priv.83+0xc>)
 80016f4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016f6:	605b      	str	r3, [r3, #4]
 80016f8:	609a      	str	r2, [r3, #8]
 */

static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80016fa:	4770      	bx	lr
 80016fc:	20000600 	.word	0x20000600

08001700 <sem1_setup.lto_priv.81>:
 8001700:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001702:	4b02      	ldr	r3, [pc, #8]	; (800170c <sem1_setup.lto_priv.81+0xc>)
 8001704:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001706:	605b      	str	r3, [r3, #4]
 8001708:	609a      	str	r2, [r3, #8]
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 800170a:	4770      	bx	lr
 800170c:	20000600 	.word	0x20000600

08001710 <mtx4_execute.lto_priv.91>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8001710:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001712:	465f      	mov	r7, fp
 8001714:	4656      	mov	r6, sl
 8001716:	464d      	mov	r5, r9
 8001718:	4644      	mov	r4, r8
 800171a:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800171c:	4d8d      	ldr	r5, [pc, #564]	; (8001954 <mtx4_execute.lto_priv.91+0x244>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800171e:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001720:	69ab      	ldr	r3, [r5, #24]
 8001722:	4f8d      	ldr	r7, [pc, #564]	; (8001958 <mtx4_execute.lto_priv.91+0x248>)
 8001724:	689c      	ldr	r4, [r3, #8]
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8001726:	b083      	sub	sp, #12
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8001728:	1c63      	adds	r3, r4, #1
 800172a:	4698      	mov	r8, r3
  p2 = p + 2;
 800172c:	1ca3      	adds	r3, r4, #2
 800172e:	4699      	mov	r9, r3
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8001730:	4b8a      	ldr	r3, [pc, #552]	; (800195c <mtx4_execute.lto_priv.91+0x24c>)
 8001732:	0049      	lsls	r1, r1, #1
 8001734:	469b      	mov	fp, r3
 8001736:	4b8a      	ldr	r3, [pc, #552]	; (8001960 <mtx4_execute.lto_priv.91+0x250>)
 8001738:	4642      	mov	r2, r8
 800173a:	9300      	str	r3, [sp, #0]
 800173c:	1c38      	adds	r0, r7, #0
 800173e:	465b      	mov	r3, fp
 8001740:	f7ff f93e 	bl	80009c0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8001744:	23a4      	movs	r3, #164	; 0xa4
 8001746:	005b      	lsls	r3, r3, #1
 8001748:	469a      	mov	sl, r3
 800174a:	21a4      	movs	r1, #164	; 0xa4
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800174c:	4e85      	ldr	r6, [pc, #532]	; (8001964 <mtx4_execute.lto_priv.91+0x254>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800174e:	4b86      	ldr	r3, [pc, #536]	; (8001968 <mtx4_execute.lto_priv.91+0x258>)
 8001750:	44ba      	add	sl, r7
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8001752:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8001754:	0049      	lsls	r1, r1, #1
 8001756:	9300      	str	r3, [sp, #0]
 8001758:	464a      	mov	r2, r9
 800175a:	4b84      	ldr	r3, [pc, #528]	; (800196c <mtx4_execute.lto_priv.91+0x25c>)
 800175c:	4650      	mov	r0, sl
 800175e:	f7ff f92f 	bl	80009c0 <chThdCreateStatic>
 8001762:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 8001764:	4882      	ldr	r0, [pc, #520]	; (8001970 <mtx4_execute.lto_priv.91+0x260>)
 8001766:	f7ff fbb3 	bl	8000ed0 <chMtxLock>
 800176a:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800176c:	2001      	movs	r0, #1
 800176e:	6899      	ldr	r1, [r3, #8]
 8001770:	1a61      	subs	r1, r4, r1
 8001772:	424b      	negs	r3, r1
 8001774:	4159      	adcs	r1, r3
 8001776:	b2c9      	uxtb	r1, r1
 8001778:	f7fe ff42 	bl	8000600 <_test_assert>
 800177c:	2800      	cmp	r0, #0
 800177e:	d006      	beq.n	800178e <mtx4_execute.lto_priv.91+0x7e>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 8001780:	b003      	add	sp, #12
 8001782:	bc3c      	pop	{r2, r3, r4, r5}
 8001784:	4690      	mov	r8, r2
 8001786:	4699      	mov	r9, r3
 8001788:	46a2      	mov	sl, r4
 800178a:	46ab      	mov	fp, r5
 800178c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 800178e:	3064      	adds	r0, #100	; 0x64
 8001790:	f7ff feee 	bl	8001570 <chThdSleep>
 8001794:	69ab      	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8001796:	2002      	movs	r0, #2
 8001798:	6899      	ldr	r1, [r3, #8]
 800179a:	4643      	mov	r3, r8
 800179c:	1a59      	subs	r1, r3, r1
 800179e:	424b      	negs	r3, r1
 80017a0:	4159      	adcs	r1, r3
 80017a2:	b2c9      	uxtb	r1, r1
 80017a4:	f7fe ff2c 	bl	8000600 <_test_assert>
 80017a8:	2800      	cmp	r0, #0
 80017aa:	d1e9      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chMtxLock(&m1);
 80017ac:	4871      	ldr	r0, [pc, #452]	; (8001974 <mtx4_execute.lto_priv.91+0x264>)
 80017ae:	f7ff fb8f 	bl	8000ed0 <chMtxLock>
 80017b2:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 80017b4:	2003      	movs	r0, #3
 80017b6:	6899      	ldr	r1, [r3, #8]
 80017b8:	4643      	mov	r3, r8
 80017ba:	1a59      	subs	r1, r3, r1
 80017bc:	424b      	negs	r3, r1
 80017be:	4159      	adcs	r1, r3
 80017c0:	b2c9      	uxtb	r1, r1
 80017c2:	f7fe ff1d 	bl	8000600 <_test_assert>
 80017c6:	2800      	cmp	r0, #0
 80017c8:	d1da      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chThdSleepMilliseconds(100);
 80017ca:	3064      	adds	r0, #100	; 0x64
 80017cc:	f7ff fed0 	bl	8001570 <chThdSleep>
 80017d0:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 80017d2:	2004      	movs	r0, #4
 80017d4:	6899      	ldr	r1, [r3, #8]
 80017d6:	464b      	mov	r3, r9
 80017d8:	1a59      	subs	r1, r3, r1
 80017da:	424b      	negs	r3, r1
 80017dc:	4159      	adcs	r1, r3
 80017de:	b2c9      	uxtb	r1, r1
 80017e0:	f7fe ff0e 	bl	8000600 <_test_assert>
 80017e4:	2800      	cmp	r0, #0
 80017e6:	d1cb      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chMtxUnlock(&m1);
 80017e8:	4862      	ldr	r0, [pc, #392]	; (8001974 <mtx4_execute.lto_priv.91+0x264>)
 80017ea:	f7ff f8a1 	bl	8000930 <chMtxUnlock>
 80017ee:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 80017f0:	2005      	movs	r0, #5
 80017f2:	6899      	ldr	r1, [r3, #8]
 80017f4:	4643      	mov	r3, r8
 80017f6:	1a59      	subs	r1, r3, r1
 80017f8:	424b      	negs	r3, r1
 80017fa:	4159      	adcs	r1, r3
 80017fc:	b2c9      	uxtb	r1, r1
 80017fe:	f7fe feff 	bl	8000600 <_test_assert>
 8001802:	2800      	cmp	r0, #0
 8001804:	d1bc      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chThdSleepMilliseconds(100);
 8001806:	3064      	adds	r0, #100	; 0x64
 8001808:	f7ff feb2 	bl	8001570 <chThdSleep>
 800180c:	69ab      	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800180e:	2006      	movs	r0, #6
 8001810:	6899      	ldr	r1, [r3, #8]
 8001812:	4643      	mov	r3, r8
 8001814:	1a59      	subs	r1, r3, r1
 8001816:	424b      	negs	r3, r1
 8001818:	4159      	adcs	r1, r3
 800181a:	b2c9      	uxtb	r1, r1
 800181c:	f7fe fef0 	bl	8000600 <_test_assert>
 8001820:	2800      	cmp	r0, #0
 8001822:	d1ad      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chMtxUnlockAll();
 8001824:	f7ff fa9c 	bl	8000d60 <chMtxUnlockAll>
 8001828:	69ab      	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800182a:	2007      	movs	r0, #7
 800182c:	6899      	ldr	r1, [r3, #8]
 800182e:	1a61      	subs	r1, r4, r1
 8001830:	424b      	negs	r3, r1
 8001832:	4159      	adcs	r1, r3
 8001834:	b2c9      	uxtb	r1, r1
 8001836:	f7fe fee3 	bl	8000600 <_test_assert>
 800183a:	2800      	cmp	r0, #0
 800183c:	d1a0      	bne.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  test_wait_threads();
 800183e:	f7ff fbff 	bl	8001040 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8001842:	21a4      	movs	r1, #164	; 0xa4
 8001844:	4b4c      	ldr	r3, [pc, #304]	; (8001978 <mtx4_execute.lto_priv.91+0x268>)
 8001846:	0049      	lsls	r1, r1, #1
 8001848:	9300      	str	r3, [sp, #0]
 800184a:	4642      	mov	r2, r8
 800184c:	465b      	mov	r3, fp
 800184e:	1c38      	adds	r0, r7, #0
 8001850:	f7ff f8b6 	bl	80009c0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8001854:	21a4      	movs	r1, #164	; 0xa4
 8001856:	4b49      	ldr	r3, [pc, #292]	; (800197c <mtx4_execute.lto_priv.91+0x26c>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8001858:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800185a:	0049      	lsls	r1, r1, #1
 800185c:	9300      	str	r3, [sp, #0]
 800185e:	464a      	mov	r2, r9
 8001860:	4b42      	ldr	r3, [pc, #264]	; (800196c <mtx4_execute.lto_priv.91+0x25c>)
 8001862:	4650      	mov	r0, sl
 8001864:	f7ff f8ac 	bl	80009c0 <chThdCreateStatic>
 8001868:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 800186a:	4841      	ldr	r0, [pc, #260]	; (8001970 <mtx4_execute.lto_priv.91+0x260>)
 800186c:	f7ff fb30 	bl	8000ed0 <chMtxLock>
 8001870:	69ab      	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8001872:	2008      	movs	r0, #8
 8001874:	6899      	ldr	r1, [r3, #8]
 8001876:	1a61      	subs	r1, r4, r1
 8001878:	424b      	negs	r3, r1
 800187a:	4159      	adcs	r1, r3
 800187c:	b2c9      	uxtb	r1, r1
 800187e:	f7fe febf 	bl	8000600 <_test_assert>
 8001882:	2800      	cmp	r0, #0
 8001884:	d000      	beq.n	8001888 <mtx4_execute.lto_priv.91+0x178>
 8001886:	e77b      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chThdSleepMilliseconds(100);
 8001888:	3064      	adds	r0, #100	; 0x64
 800188a:	f7ff fe71 	bl	8001570 <chThdSleep>
 800188e:	69ab      	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8001890:	2009      	movs	r0, #9
 8001892:	6899      	ldr	r1, [r3, #8]
 8001894:	4643      	mov	r3, r8
 8001896:	1a59      	subs	r1, r3, r1
 8001898:	424b      	negs	r3, r1
 800189a:	4159      	adcs	r1, r3
 800189c:	b2c9      	uxtb	r1, r1
 800189e:	f7fe feaf 	bl	8000600 <_test_assert>
 80018a2:	2800      	cmp	r0, #0
 80018a4:	d000      	beq.n	80018a8 <mtx4_execute.lto_priv.91+0x198>
 80018a6:	e76b      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chMtxLock(&m1);
 80018a8:	4832      	ldr	r0, [pc, #200]	; (8001974 <mtx4_execute.lto_priv.91+0x264>)
 80018aa:	f7ff fb11 	bl	8000ed0 <chMtxLock>
 80018ae:	69ab      	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 80018b0:	200a      	movs	r0, #10
 80018b2:	6899      	ldr	r1, [r3, #8]
 80018b4:	4643      	mov	r3, r8
 80018b6:	1a59      	subs	r1, r3, r1
 80018b8:	424b      	negs	r3, r1
 80018ba:	4159      	adcs	r1, r3
 80018bc:	b2c9      	uxtb	r1, r1
 80018be:	f7fe fe9f 	bl	8000600 <_test_assert>
 80018c2:	2800      	cmp	r0, #0
 80018c4:	d000      	beq.n	80018c8 <mtx4_execute.lto_priv.91+0x1b8>
 80018c6:	e75b      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chThdSleepMilliseconds(100);
 80018c8:	3064      	adds	r0, #100	; 0x64
 80018ca:	f7ff fe51 	bl	8001570 <chThdSleep>
 80018ce:	69ab      	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 80018d0:	200b      	movs	r0, #11
 80018d2:	6899      	ldr	r1, [r3, #8]
 80018d4:	464b      	mov	r3, r9
 80018d6:	1a59      	subs	r1, r3, r1
 80018d8:	424b      	negs	r3, r1
 80018da:	4159      	adcs	r1, r3
 80018dc:	b2c9      	uxtb	r1, r1
 80018de:	f7fe fe8f 	bl	8000600 <_test_assert>
 80018e2:	2800      	cmp	r0, #0
 80018e4:	d000      	beq.n	80018e8 <mtx4_execute.lto_priv.91+0x1d8>
 80018e6:	e74b      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
 80018e8:	b672      	cpsid	i
  chSysLock();
  chMtxUnlockS(&m1);
 80018ea:	4822      	ldr	r0, [pc, #136]	; (8001974 <mtx4_execute.lto_priv.91+0x264>)
 80018ec:	f7ff fa60 	bl	8000db0 <chMtxUnlockS>
  chSchRescheduleS();
 80018f0:	f7fe ffce 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80018f4:	b662      	cpsie	i
 80018f6:	69ab      	ldr	r3, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 80018f8:	200c      	movs	r0, #12
 80018fa:	6899      	ldr	r1, [r3, #8]
 80018fc:	4643      	mov	r3, r8
 80018fe:	1a59      	subs	r1, r3, r1
 8001900:	424b      	negs	r3, r1
 8001902:	4159      	adcs	r1, r3
 8001904:	b2c9      	uxtb	r1, r1
 8001906:	f7fe fe7b 	bl	8000600 <_test_assert>
 800190a:	2800      	cmp	r0, #0
 800190c:	d000      	beq.n	8001910 <mtx4_execute.lto_priv.91+0x200>
 800190e:	e737      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chThdSleepMilliseconds(100);
 8001910:	3064      	adds	r0, #100	; 0x64
 8001912:	f7ff fe2d 	bl	8001570 <chThdSleep>
 8001916:	69ab      	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8001918:	200d      	movs	r0, #13
 800191a:	6899      	ldr	r1, [r3, #8]
 800191c:	4643      	mov	r3, r8
 800191e:	1a59      	subs	r1, r3, r1
 8001920:	424b      	negs	r3, r1
 8001922:	4159      	adcs	r1, r3
 8001924:	b2c9      	uxtb	r1, r1
 8001926:	f7fe fe6b 	bl	8000600 <_test_assert>
 800192a:	2800      	cmp	r0, #0
 800192c:	d000      	beq.n	8001930 <mtx4_execute.lto_priv.91+0x220>
 800192e:	e727      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  chMtxUnlockAll();
 8001930:	f7ff fa16 	bl	8000d60 <chMtxUnlockAll>
 8001934:	69ab      	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8001936:	200e      	movs	r0, #14
 8001938:	6899      	ldr	r1, [r3, #8]
 800193a:	1a61      	subs	r1, r4, r1
 800193c:	424c      	negs	r4, r1
 800193e:	4161      	adcs	r1, r4
 8001940:	b2c9      	uxtb	r1, r1
 8001942:	f7fe fe5d 	bl	8000600 <_test_assert>
 8001946:	2800      	cmp	r0, #0
 8001948:	d000      	beq.n	800194c <mtx4_execute.lto_priv.91+0x23c>
 800194a:	e719      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
  test_wait_threads();
 800194c:	f7ff fb78 	bl	8001040 <test_wait_threads>
 8001950:	e716      	b.n	8001780 <mtx4_execute.lto_priv.91+0x70>
 8001952:	46c0      	nop			; (mov r8, r8)
 8001954:	20000f20 	.word	0x20000f20
 8001958:	200006c0 	.word	0x200006c0
 800195c:	08001981 	.word	0x08001981
 8001960:	080055f0 	.word	0x080055f0
 8001964:	20001090 	.word	0x20001090
 8001968:	080055f4 	.word	0x080055f4
 800196c:	080019a1 	.word	0x080019a1
 8001970:	2000064c 	.word	0x2000064c
 8001974:	2000063c 	.word	0x2000063c
 8001978:	080055f8 	.word	0x080055f8
 800197c:	080055fc 	.word	0x080055fc

08001980 <thread4a>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 8001980:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8001982:	2032      	movs	r0, #50	; 0x32
 8001984:	f7ff fdf4 	bl	8001570 <chThdSleep>
  chMtxLock(&m2);
 8001988:	4c03      	ldr	r4, [pc, #12]	; (8001998 <thread4a+0x18>)
 800198a:	1c20      	adds	r0, r4, #0
 800198c:	f7ff faa0 	bl	8000ed0 <chMtxLock>
  chMtxUnlock(&m2);
 8001990:	1c20      	adds	r0, r4, #0
 8001992:	f7fe ffcd 	bl	8000930 <chMtxUnlock>
}
 8001996:	bd10      	pop	{r4, pc}
 8001998:	2000064c 	.word	0x2000064c
 800199c:	46c0      	nop			; (mov r8, r8)
 800199e:	46c0      	nop			; (mov r8, r8)

080019a0 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 80019a0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 80019a2:	2096      	movs	r0, #150	; 0x96
 80019a4:	f7ff fde4 	bl	8001570 <chThdSleep>
  chMtxLock(&m1);
 80019a8:	4c03      	ldr	r4, [pc, #12]	; (80019b8 <thread4b+0x18>)
 80019aa:	1c20      	adds	r0, r4, #0
 80019ac:	f7ff fa90 	bl	8000ed0 <chMtxLock>
  chMtxUnlock(&m1);
 80019b0:	1c20      	adds	r0, r4, #0
 80019b2:	f7fe ffbd 	bl	8000930 <chMtxUnlock>
}
 80019b6:	bd10      	pop	{r4, pc}
 80019b8:	2000063c 	.word	0x2000063c
 80019bc:	46c0      	nop			; (mov r8, r8)
 80019be:	46c0      	nop			; (mov r8, r8)

080019c0 <mtx1_execute.lto_priv.89>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80019c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019c2:	464f      	mov	r7, r9
 80019c4:	4646      	mov	r6, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80019c6:	4b31      	ldr	r3, [pc, #196]	; (8001a8c <mtx1_execute.lto_priv.89+0xcc>)
 80019c8:	b4c0      	push	{r6, r7}
 80019ca:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80019cc:	699b      	ldr	r3, [r3, #24]
 80019ce:	b083      	sub	sp, #12
 80019d0:	689c      	ldr	r4, [r3, #8]

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80019d2:	4b2f      	ldr	r3, [pc, #188]	; (8001a90 <mtx1_execute.lto_priv.89+0xd0>)
 80019d4:	1c18      	adds	r0, r3, #0
 80019d6:	4699      	mov	r9, r3
 80019d8:	f7ff fa7a 	bl	8000ed0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80019dc:	21a4      	movs	r1, #164	; 0xa4
 80019de:	4d2d      	ldr	r5, [pc, #180]	; (8001a94 <mtx1_execute.lto_priv.89+0xd4>)
 80019e0:	4f2d      	ldr	r7, [pc, #180]	; (8001a98 <mtx1_execute.lto_priv.89+0xd8>)
 80019e2:	4b2e      	ldr	r3, [pc, #184]	; (8001a9c <mtx1_execute.lto_priv.89+0xdc>)
 80019e4:	1c62      	adds	r2, r4, #1
 80019e6:	9300      	str	r3, [sp, #0]
 80019e8:	0049      	lsls	r1, r1, #1
 80019ea:	1c3b      	adds	r3, r7, #0
 80019ec:	1c28      	adds	r0, r5, #0
 80019ee:	f7fe ffe7 	bl	80009c0 <chThdCreateStatic>
 80019f2:	4e2b      	ldr	r6, [pc, #172]	; (8001aa0 <mtx1_execute.lto_priv.89+0xe0>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80019f4:	21a4      	movs	r1, #164	; 0xa4

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80019f6:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80019f8:	1c28      	adds	r0, r5, #0
 80019fa:	4b2a      	ldr	r3, [pc, #168]	; (8001aa4 <mtx1_execute.lto_priv.89+0xe4>)
 80019fc:	3049      	adds	r0, #73	; 0x49
 80019fe:	1ca2      	adds	r2, r4, #2
 8001a00:	9300      	str	r3, [sp, #0]
 8001a02:	0049      	lsls	r1, r1, #1
 8001a04:	1c3b      	adds	r3, r7, #0
 8001a06:	30ff      	adds	r0, #255	; 0xff
 8001a08:	f7fe ffda 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8001a0c:	23a4      	movs	r3, #164	; 0xa4
 8001a0e:	21a4      	movs	r1, #164	; 0xa4
 8001a10:	009b      	lsls	r3, r3, #2
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8001a12:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8001a14:	18e8      	adds	r0, r5, r3
 8001a16:	4b24      	ldr	r3, [pc, #144]	; (8001aa8 <mtx1_execute.lto_priv.89+0xe8>)
 8001a18:	1ce2      	adds	r2, r4, #3
 8001a1a:	9300      	str	r3, [sp, #0]
 8001a1c:	0049      	lsls	r1, r1, #1
 8001a1e:	1c3b      	adds	r3, r7, #0
 8001a20:	f7fe ffce 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8001a24:	23f6      	movs	r3, #246	; 0xf6
 8001a26:	21a4      	movs	r1, #164	; 0xa4
 8001a28:	009b      	lsls	r3, r3, #2

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8001a2a:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8001a2c:	18e8      	adds	r0, r5, r3
 8001a2e:	4b1f      	ldr	r3, [pc, #124]	; (8001aac <mtx1_execute.lto_priv.89+0xec>)
 8001a30:	1d22      	adds	r2, r4, #4
 8001a32:	9300      	str	r3, [sp, #0]
 8001a34:	0049      	lsls	r1, r1, #1
 8001a36:	1c3b      	adds	r3, r7, #0
 8001a38:	f7fe ffc2 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8001a3c:	23a4      	movs	r3, #164	; 0xa4
 8001a3e:	21a4      	movs	r1, #164	; 0xa4
 8001a40:	00db      	lsls	r3, r3, #3
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8001a42:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8001a44:	18e8      	adds	r0, r5, r3
 8001a46:	4b1a      	ldr	r3, [pc, #104]	; (8001ab0 <mtx1_execute.lto_priv.89+0xf0>)
 8001a48:	1d62      	adds	r2, r4, #5
 8001a4a:	0049      	lsls	r1, r1, #1
 8001a4c:	9300      	str	r3, [sp, #0]
 8001a4e:	1c3b      	adds	r3, r7, #0
 8001a50:	f7fe ffb6 	bl	80009c0 <chThdCreateStatic>
 8001a54:	6130      	str	r0, [r6, #16]
  chMtxUnlock(&m1);
 8001a56:	4648      	mov	r0, r9
 8001a58:	f7fe ff6a 	bl	8000930 <chMtxUnlock>
  test_wait_threads();
 8001a5c:	f7ff faf0 	bl	8001040 <test_wait_threads>
 8001a60:	4643      	mov	r3, r8
 8001a62:	699b      	ldr	r3, [r3, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8001a64:	2001      	movs	r0, #1
 8001a66:	6899      	ldr	r1, [r3, #8]
 8001a68:	1a61      	subs	r1, r4, r1
 8001a6a:	424c      	negs	r4, r1
 8001a6c:	4161      	adcs	r1, r4
 8001a6e:	b2c9      	uxtb	r1, r1
 8001a70:	f7fe fdc6 	bl	8000600 <_test_assert>
 8001a74:	2800      	cmp	r0, #0
 8001a76:	d103      	bne.n	8001a80 <mtx1_execute.lto_priv.89+0xc0>
  test_assert_sequence(2, "ABCDE");
 8001a78:	3002      	adds	r0, #2
 8001a7a:	490e      	ldr	r1, [pc, #56]	; (8001ab4 <mtx1_execute.lto_priv.89+0xf4>)
 8001a7c:	f7fe fd90 	bl	80005a0 <_test_assert_sequence>
}
 8001a80:	b003      	add	sp, #12
 8001a82:	bc0c      	pop	{r2, r3}
 8001a84:	4690      	mov	r8, r2
 8001a86:	4699      	mov	r9, r3
 8001a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a8a:	46c0      	nop			; (mov r8, r8)
 8001a8c:	20000f20 	.word	0x20000f20
 8001a90:	2000063c 	.word	0x2000063c
 8001a94:	200006c0 	.word	0x200006c0
 8001a98:	08001ba1 	.word	0x08001ba1
 8001a9c:	08005604 	.word	0x08005604
 8001aa0:	20001090 	.word	0x20001090
 8001aa4:	080055f8 	.word	0x080055f8
 8001aa8:	080055fc 	.word	0x080055fc
 8001aac:	080055f0 	.word	0x080055f0
 8001ab0:	080055f4 	.word	0x080055f4
 8001ab4:	08005600 	.word	0x08005600
 8001ab8:	46c0      	nop			; (mov r8, r8)
 8001aba:	46c0      	nop			; (mov r8, r8)
 8001abc:	46c0      	nop			; (mov r8, r8)
 8001abe:	46c0      	nop			; (mov r8, r8)

08001ac0 <thd1_execute.lto_priv.77>:

static void thd1_execute(void) {
 8001ac0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ac2:	4647      	mov	r7, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001ac4:	4b29      	ldr	r3, [pc, #164]	; (8001b6c <thd1_execute.lto_priv.77+0xac>)
 8001ac6:	b480      	push	{r7}

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001ac8:	27a4      	movs	r7, #164	; 0xa4
 8001aca:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001acc:	699b      	ldr	r3, [r3, #24]
 8001ace:	4c28      	ldr	r4, [pc, #160]	; (8001b70 <thd1_execute.lto_priv.77+0xb0>)
 8001ad0:	4e28      	ldr	r6, [pc, #160]	; (8001b74 <thd1_execute.lto_priv.77+0xb4>)
 8001ad2:	689a      	ldr	r2, [r3, #8]
 8001ad4:	4b28      	ldr	r3, [pc, #160]	; (8001b78 <thd1_execute.lto_priv.77+0xb8>)
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 8001ad6:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001ad8:	007f      	lsls	r7, r7, #1
 8001ada:	9300      	str	r3, [sp, #0]
 8001adc:	1c39      	adds	r1, r7, #0
 8001ade:	1c33      	adds	r3, r6, #0
 8001ae0:	3a05      	subs	r2, #5
 8001ae2:	1c20      	adds	r0, r4, #0
 8001ae4:	f7fe ff6c 	bl	80009c0 <chThdCreateStatic>
 8001ae8:	4643      	mov	r3, r8
 8001aea:	699b      	ldr	r3, [r3, #24]
 8001aec:	4d23      	ldr	r5, [pc, #140]	; (8001b7c <thd1_execute.lto_priv.77+0xbc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001aee:	689a      	ldr	r2, [r3, #8]
 8001af0:	4b23      	ldr	r3, [pc, #140]	; (8001b80 <thd1_execute.lto_priv.77+0xc0>)
  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001af2:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001af4:	1c39      	adds	r1, r7, #0
 8001af6:	9300      	str	r3, [sp, #0]
 8001af8:	19e0      	adds	r0, r4, r7
 8001afa:	1c33      	adds	r3, r6, #0
 8001afc:	3a04      	subs	r2, #4
 8001afe:	f7fe ff5f 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001b02:	23a4      	movs	r3, #164	; 0xa4
 8001b04:	009b      	lsls	r3, r3, #2
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001b06:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001b08:	18e0      	adds	r0, r4, r3
 8001b0a:	4643      	mov	r3, r8
 8001b0c:	699b      	ldr	r3, [r3, #24]
 8001b0e:	1c39      	adds	r1, r7, #0
 8001b10:	689a      	ldr	r2, [r3, #8]
 8001b12:	4b1c      	ldr	r3, [pc, #112]	; (8001b84 <thd1_execute.lto_priv.77+0xc4>)
 8001b14:	3a03      	subs	r2, #3
 8001b16:	9300      	str	r3, [sp, #0]
 8001b18:	1c33      	adds	r3, r6, #0
 8001b1a:	f7fe ff51 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001b1e:	23f6      	movs	r3, #246	; 0xf6
 8001b20:	009b      	lsls	r3, r3, #2

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001b22:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001b24:	18e0      	adds	r0, r4, r3
 8001b26:	4643      	mov	r3, r8
 8001b28:	699b      	ldr	r3, [r3, #24]
 8001b2a:	1c39      	adds	r1, r7, #0
 8001b2c:	689a      	ldr	r2, [r3, #8]
 8001b2e:	4b16      	ldr	r3, [pc, #88]	; (8001b88 <thd1_execute.lto_priv.77+0xc8>)
 8001b30:	3a02      	subs	r2, #2
 8001b32:	9300      	str	r3, [sp, #0]
 8001b34:	1c33      	adds	r3, r6, #0
 8001b36:	f7fe ff43 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001b3a:	23a4      	movs	r3, #164	; 0xa4
 8001b3c:	00db      	lsls	r3, r3, #3
static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001b3e:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001b40:	18e0      	adds	r0, r4, r3
 8001b42:	4643      	mov	r3, r8
 8001b44:	699b      	ldr	r3, [r3, #24]
 8001b46:	1c39      	adds	r1, r7, #0
 8001b48:	689a      	ldr	r2, [r3, #8]
 8001b4a:	4b10      	ldr	r3, [pc, #64]	; (8001b8c <thd1_execute.lto_priv.77+0xcc>)
 8001b4c:	3a01      	subs	r2, #1
 8001b4e:	9300      	str	r3, [sp, #0]
 8001b50:	1c33      	adds	r3, r6, #0
 8001b52:	f7fe ff35 	bl	80009c0 <chThdCreateStatic>
 8001b56:	6128      	str	r0, [r5, #16]
  test_wait_threads();
 8001b58:	f7ff fa72 	bl	8001040 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8001b5c:	490c      	ldr	r1, [pc, #48]	; (8001b90 <thd1_execute.lto_priv.77+0xd0>)
 8001b5e:	2001      	movs	r0, #1
 8001b60:	f7fe fd1e 	bl	80005a0 <_test_assert_sequence>
}
 8001b64:	b002      	add	sp, #8
 8001b66:	bc04      	pop	{r2}
 8001b68:	4690      	mov	r8, r2
 8001b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001b6c:	20000f20 	.word	0x20000f20
 8001b70:	200006c0 	.word	0x200006c0
 8001b74:	08000651 	.word	0x08000651
 8001b78:	08005604 	.word	0x08005604
 8001b7c:	20001090 	.word	0x20001090
 8001b80:	080055f8 	.word	0x080055f8
 8001b84:	080055fc 	.word	0x080055fc
 8001b88:	080055f0 	.word	0x080055f0
 8001b8c:	080055f4 	.word	0x080055f4
 8001b90:	08005600 	.word	0x08005600
 8001b94:	46c0      	nop			; (mov r8, r8)
 8001b96:	46c0      	nop			; (mov r8, r8)
 8001b98:	46c0      	nop			; (mov r8, r8)
 8001b9a:	46c0      	nop			; (mov r8, r8)
 8001b9c:	46c0      	nop			; (mov r8, r8)
 8001b9e:	46c0      	nop			; (mov r8, r8)

08001ba0 <thread1.lto_priv.156>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8001ba0:	b538      	push	{r3, r4, r5, lr}
 8001ba2:	1c05      	adds	r5, r0, #0

  chMtxLock(&m1);
 8001ba4:	4c05      	ldr	r4, [pc, #20]	; (8001bbc <thread1.lto_priv.156+0x1c>)
 8001ba6:	1c20      	adds	r0, r4, #0
 8001ba8:	f7ff f992 	bl	8000ed0 <chMtxLock>
  test_emit_token(*(char *)p);
 8001bac:	7828      	ldrb	r0, [r5, #0]
 8001bae:	f7fe fd3f 	bl	8000630 <test_emit_token>
  chMtxUnlock(&m1);
 8001bb2:	1c20      	adds	r0, r4, #0
 8001bb4:	f7fe febc 	bl	8000930 <chMtxUnlock>
}
 8001bb8:	bd38      	pop	{r3, r4, r5, pc}
 8001bba:	46c0      	nop			; (mov r8, r8)
 8001bbc:	2000063c 	.word	0x2000063c

08001bc0 <thread1.lto_priv.155>:

static THD_FUNCTION(thread1, p) {
 8001bc0:	b510      	push	{r4, lr}
 8001bc2:	1c04      	adds	r4, r0, #0

  chSemWait(&sem1);
 8001bc4:	4803      	ldr	r0, [pc, #12]	; (8001bd4 <thread1.lto_priv.155+0x14>)
 8001bc6:	f7fe ff5b 	bl	8000a80 <chSemWait>
  test_emit_token(*(char *)p);
 8001bca:	7820      	ldrb	r0, [r4, #0]
 8001bcc:	f7fe fd30 	bl	8000630 <test_emit_token>
}
 8001bd0:	bd10      	pop	{r4, pc}
 8001bd2:	46c0      	nop			; (mov r8, r8)
 8001bd4:	20000600 	.word	0x20000600
 8001bd8:	46c0      	nop			; (mov r8, r8)
 8001bda:	46c0      	nop			; (mov r8, r8)
 8001bdc:	46c0      	nop			; (mov r8, r8)
 8001bde:	46c0      	nop			; (mov r8, r8)

08001be0 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8001be0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001be2:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8001be4:	6883      	ldr	r3, [r0, #8]
 8001be6:	2b00      	cmp	r3, #0
 8001be8:	dd03      	ble.n	8001bf2 <thread4+0x12>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8001bea:	f7fe fe51 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bee:	b662      	cpsie	i

  chBSemSignal((binary_semaphore_t *)p);
}
 8001bf0:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8001bf2:	f7ff fa85 	bl	8001100 <chSemSignalI>
 8001bf6:	e7f8      	b.n	8001bea <thread4+0xa>
 8001bf8:	46c0      	nop			; (mov r8, r8)
 8001bfa:	46c0      	nop			; (mov r8, r8)
 8001bfc:	46c0      	nop			; (mov r8, r8)
 8001bfe:	46c0      	nop			; (mov r8, r8)

08001c00 <thread2>:
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 8001c00:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8001c02:	2032      	movs	r0, #50	; 0x32
 8001c04:	f7ff fcb4 	bl	8001570 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c08:	b672      	cpsid	i
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8001c0a:	4803      	ldr	r0, [pc, #12]	; (8001c18 <thread2+0x18>)
 8001c0c:	f7ff fa78 	bl	8001100 <chSemSignalI>
  chSchRescheduleS();
 8001c10:	f7fe fe3e 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c14:	b662      	cpsie	i
  chSysUnlock();
}
 8001c16:	bd08      	pop	{r3, pc}
 8001c18:	20000600 	.word	0x20000600
 8001c1c:	46c0      	nop			; (mov r8, r8)
 8001c1e:	46c0      	nop			; (mov r8, r8)

08001c20 <sem4_execute.lto_priv.87>:
 8001c20:	2300      	movs	r3, #0
static THD_FUNCTION(thread4, p) {

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 8001c22:	b510      	push	{r4, lr}
 8001c24:	b086      	sub	sp, #24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001c26:	ac03      	add	r4, sp, #12
 8001c28:	9403      	str	r4, [sp, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001c2a:	6064      	str	r4, [r4, #4]
 8001c2c:	60a3      	str	r3, [r4, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c2e:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001c30:	2100      	movs	r1, #0
 8001c32:	1c20      	adds	r0, r4, #0
 8001c34:	f7ff fa7c 	bl	8001130 <chSemResetI>
  chSchRescheduleS();
 8001c38:	f7fe fe2a 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c3c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c3e:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8001c40:	9b05      	ldr	r3, [sp, #20]
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8001c42:	2001      	movs	r0, #1
 8001c44:	1e59      	subs	r1, r3, #1
 8001c46:	4319      	orrs	r1, r3
 8001c48:	0fc9      	lsrs	r1, r1, #31
 8001c4a:	f7fe fcd9 	bl	8000600 <_test_assert>
 8001c4e:	2800      	cmp	r0, #0
 8001c50:	d002      	beq.n	8001c58 <sem4_execute.lto_priv.87+0x38>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c52:	b662      	cpsie	i

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8001c54:	b006      	add	sp, #24
 8001c56:	bd10      	pop	{r4, pc}
 8001c58:	b662      	cpsie	i
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8001c5a:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001c5c:	4b2d      	ldr	r3, [pc, #180]	; (8001d14 <sem4_execute.lto_priv.87+0xf4>)
 8001c5e:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001c60:	699b      	ldr	r3, [r3, #24]
 8001c62:	482d      	ldr	r0, [pc, #180]	; (8001d18 <sem4_execute.lto_priv.87+0xf8>)
 8001c64:	689a      	ldr	r2, [r3, #8]
 8001c66:	9400      	str	r4, [sp, #0]
 8001c68:	3a01      	subs	r2, #1
 8001c6a:	4b2c      	ldr	r3, [pc, #176]	; (8001d1c <sem4_execute.lto_priv.87+0xfc>)
 8001c6c:	f7fe fea8 	bl	80009c0 <chThdCreateStatic>
 8001c70:	4b2b      	ldr	r3, [pc, #172]	; (8001d20 <sem4_execute.lto_priv.87+0x100>)
 8001c72:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 8001c74:	1c20      	adds	r0, r4, #0
 8001c76:	f7fe ff03 	bl	8000a80 <chSemWait>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c7a:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8001c7c:	9b05      	ldr	r3, [sp, #20]
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8001c7e:	2002      	movs	r0, #2
 8001c80:	1e59      	subs	r1, r3, #1
 8001c82:	4319      	orrs	r1, r3
 8001c84:	0fc9      	lsrs	r1, r1, #31
 8001c86:	f7fe fcbb 	bl	8000600 <_test_assert>
 8001c8a:	2800      	cmp	r0, #0
 8001c8c:	d1e1      	bne.n	8001c52 <sem4_execute.lto_priv.87+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c8e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c90:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8001c92:	68a3      	ldr	r3, [r4, #8]
 8001c94:	2b00      	cmp	r3, #0
 8001c96:	dd35      	ble.n	8001d04 <sem4_execute.lto_priv.87+0xe4>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8001c98:	f7fe fdfa 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c9c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c9e:	b672      	cpsid	i

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 8001ca0:	9b05      	ldr	r3, [sp, #20]
 8001ca2:	2003      	movs	r0, #3
 8001ca4:	17d9      	asrs	r1, r3, #31
 8001ca6:	1ac9      	subs	r1, r1, r3
 8001ca8:	0fc9      	lsrs	r1, r1, #31
 8001caa:	f7fe fca9 	bl	8000600 <_test_assert>
 8001cae:	2800      	cmp	r0, #0
 8001cb0:	d1cf      	bne.n	8001c52 <sem4_execute.lto_priv.87+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cb2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cb4:	b672      	cpsid	i
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8001cb6:	9b05      	ldr	r3, [sp, #20]
 8001cb8:	2004      	movs	r0, #4
 8001cba:	1e59      	subs	r1, r3, #1
 8001cbc:	424a      	negs	r2, r1
 8001cbe:	414a      	adcs	r2, r1
 8001cc0:	b2d1      	uxtb	r1, r2
 8001cc2:	f7fe fc9d 	bl	8000600 <_test_assert>
 8001cc6:	2800      	cmp	r0, #0
 8001cc8:	d1c3      	bne.n	8001c52 <sem4_execute.lto_priv.87+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cca:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ccc:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8001cce:	68a3      	ldr	r3, [r4, #8]
 8001cd0:	2b00      	cmp	r3, #0
 8001cd2:	dd1b      	ble.n	8001d0c <sem4_execute.lto_priv.87+0xec>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8001cd4:	f7fe fddc 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cd8:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cda:	b672      	cpsid	i

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 8001cdc:	9b05      	ldr	r3, [sp, #20]
 8001cde:	2003      	movs	r0, #3
 8001ce0:	17d9      	asrs	r1, r3, #31
 8001ce2:	1ac9      	subs	r1, r1, r3
 8001ce4:	0fc9      	lsrs	r1, r1, #31
 8001ce6:	f7fe fc8b 	bl	8000600 <_test_assert>
 8001cea:	2800      	cmp	r0, #0
 8001cec:	d1b1      	bne.n	8001c52 <sem4_execute.lto_priv.87+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cee:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cf0:	b672      	cpsid	i
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8001cf2:	9b05      	ldr	r3, [sp, #20]
 8001cf4:	2005      	movs	r0, #5
 8001cf6:	1e59      	subs	r1, r3, #1
 8001cf8:	424a      	negs	r2, r1
 8001cfa:	414a      	adcs	r2, r1
 8001cfc:	b2d1      	uxtb	r1, r2
 8001cfe:	f7fe fc7f 	bl	8000600 <_test_assert>
 8001d02:	e7a6      	b.n	8001c52 <sem4_execute.lto_priv.87+0x32>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8001d04:	1c20      	adds	r0, r4, #0
 8001d06:	f7ff f9fb 	bl	8001100 <chSemSignalI>
 8001d0a:	e7c5      	b.n	8001c98 <sem4_execute.lto_priv.87+0x78>
 8001d0c:	1c20      	adds	r0, r4, #0
 8001d0e:	f7ff f9f7 	bl	8001100 <chSemSignalI>
 8001d12:	e7df      	b.n	8001cd4 <sem4_execute.lto_priv.87+0xb4>
 8001d14:	20000f20 	.word	0x20000f20
 8001d18:	200006c0 	.word	0x200006c0
 8001d1c:	08001be1 	.word	0x08001be1
 8001d20:	20001090 	.word	0x20001090
 8001d24:	46c0      	nop			; (mov r8, r8)
 8001d26:	46c0      	nop			; (mov r8, r8)
 8001d28:	46c0      	nop			; (mov r8, r8)
 8001d2a:	46c0      	nop			; (mov r8, r8)
 8001d2c:	46c0      	nop			; (mov r8, r8)
 8001d2e:	46c0      	nop			; (mov r8, r8)

08001d30 <sem3_execute.lto_priv.86>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001d30:	4b1d      	ldr	r3, [pc, #116]	; (8001da8 <sem3_execute.lto_priv.86+0x78>)
  chSemSignal(&sem1);
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001d32:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001d34:	699b      	ldr	r3, [r3, #24]
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8001d36:	b510      	push	{r4, lr}

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001d38:	689a      	ldr	r2, [r3, #8]
 8001d3a:	2300      	movs	r3, #0
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8001d3c:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001d3e:	3201      	adds	r2, #1
 8001d40:	0049      	lsls	r1, r1, #1
 8001d42:	9300      	str	r3, [sp, #0]
 8001d44:	4819      	ldr	r0, [pc, #100]	; (8001dac <sem3_execute.lto_priv.86+0x7c>)
 8001d46:	4b1a      	ldr	r3, [pc, #104]	; (8001db0 <sem3_execute.lto_priv.86+0x80>)
 8001d48:	f7fe fe3a 	bl	80009c0 <chThdCreateStatic>
 8001d4c:	4b19      	ldr	r3, [pc, #100]	; (8001db4 <sem3_execute.lto_priv.86+0x84>)
 8001d4e:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8001d50:	f000 fc66 	bl	8002620 <chSemSignalWait.constprop.52>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8001d54:	4c18      	ldr	r4, [pc, #96]	; (8001db8 <sem3_execute.lto_priv.86+0x88>)
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 8001d56:	2001      	movs	r0, #1
 8001d58:	6823      	ldr	r3, [r4, #0]
 8001d5a:	1b19      	subs	r1, r3, r4
 8001d5c:	424a      	negs	r2, r1
 8001d5e:	414a      	adcs	r2, r1
 8001d60:	b2d1      	uxtb	r1, r2
 8001d62:	f7fe fc4d 	bl	8000600 <_test_assert>
 8001d66:	2800      	cmp	r0, #0
 8001d68:	d001      	beq.n	8001d6e <sem3_execute.lto_priv.86+0x3e>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 8001d6a:	b002      	add	sp, #8
 8001d6c:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8001d6e:	68a1      	ldr	r1, [r4, #8]
 8001d70:	3002      	adds	r0, #2
 8001d72:	424b      	negs	r3, r1
 8001d74:	4159      	adcs	r1, r3
 8001d76:	b2c9      	uxtb	r1, r1
 8001d78:	f7fe fc42 	bl	8000600 <_test_assert>
 8001d7c:	2800      	cmp	r0, #0
 8001d7e:	d1f4      	bne.n	8001d6a <sem3_execute.lto_priv.86+0x3a>

  chSemSignalWait(&sem1, &sem1);
 8001d80:	f000 fc4e 	bl	8002620 <chSemSignalWait.constprop.52>
 8001d84:	6823      	ldr	r3, [r4, #0]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8001d86:	2003      	movs	r0, #3
 8001d88:	1b19      	subs	r1, r3, r4
 8001d8a:	424a      	negs	r2, r1
 8001d8c:	414a      	adcs	r2, r1
 8001d8e:	b2d1      	uxtb	r1, r2
 8001d90:	f7fe fc36 	bl	8000600 <_test_assert>
 8001d94:	2800      	cmp	r0, #0
 8001d96:	d1e8      	bne.n	8001d6a <sem3_execute.lto_priv.86+0x3a>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8001d98:	68a3      	ldr	r3, [r4, #8]
 8001d9a:	3004      	adds	r0, #4
 8001d9c:	4259      	negs	r1, r3
 8001d9e:	4159      	adcs	r1, r3
 8001da0:	b2c9      	uxtb	r1, r1
 8001da2:	f7fe fc2d 	bl	8000600 <_test_assert>
 8001da6:	e7e0      	b.n	8001d6a <sem3_execute.lto_priv.86+0x3a>
 8001da8:	20000f20 	.word	0x20000f20
 8001dac:	200006c0 	.word	0x200006c0
 8001db0:	08001dc1 	.word	0x08001dc1
 8001db4:	20001090 	.word	0x20001090
 8001db8:	20000600 	.word	0x20000600
 8001dbc:	46c0      	nop			; (mov r8, r8)
 8001dbe:	46c0      	nop			; (mov r8, r8)

08001dc0 <thread3>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 8001dc0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8001dc2:	4c04      	ldr	r4, [pc, #16]	; (8001dd4 <thread3+0x14>)
 8001dc4:	1c20      	adds	r0, r4, #0
 8001dc6:	f7fe fe5b 	bl	8000a80 <chSemWait>
  chSemSignal(&sem1);
 8001dca:	1c20      	adds	r0, r4, #0
 8001dcc:	f7fe fde0 	bl	8000990 <chSemSignal>
}
 8001dd0:	bd10      	pop	{r4, pc}
 8001dd2:	46c0      	nop			; (mov r8, r8)
 8001dd4:	20000600 	.word	0x20000600
 8001dd8:	46c0      	nop			; (mov r8, r8)
 8001dda:	46c0      	nop			; (mov r8, r8)
 8001ddc:	46c0      	nop			; (mov r8, r8)
 8001dde:	46c0      	nop			; (mov r8, r8)

08001de0 <sem2_execute.lto_priv.84>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8001de0:	b570      	push	{r4, r5, r6, lr}
 8001de2:	b082      	sub	sp, #8
 8001de4:	b672      	cpsid	i
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 8001de6:	4c4c      	ldr	r4, [pc, #304]	; (8001f18 <sem2_execute.lto_priv.84+0x138>)
 8001de8:	2100      	movs	r1, #0
 8001dea:	1c20      	adds	r0, r4, #0
 8001dec:	f7ff fa88 	bl	8001300 <chSemWaitTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001df0:	b662      	cpsie	i

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 8001df2:	3001      	adds	r0, #1
 8001df4:	4241      	negs	r1, r0
 8001df6:	4141      	adcs	r1, r0
 8001df8:	2001      	movs	r0, #1
 8001dfa:	b2c9      	uxtb	r1, r1
 8001dfc:	f7fe fc00 	bl	8000600 <_test_assert>
 8001e00:	2800      	cmp	r0, #0
 8001e02:	d001      	beq.n	8001e08 <sem2_execute.lto_priv.84+0x28>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 8001e04:	b002      	add	sp, #8
 8001e06:	bd70      	pop	{r4, r5, r6, pc}
 8001e08:	6823      	ldr	r3, [r4, #0]
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 8001e0a:	3002      	adds	r0, #2
 8001e0c:	1b19      	subs	r1, r3, r4
 8001e0e:	424a      	negs	r2, r1
 8001e10:	414a      	adcs	r2, r1
 8001e12:	b2d1      	uxtb	r1, r2
 8001e14:	f7fe fbf4 	bl	8000600 <_test_assert>
 8001e18:	2800      	cmp	r0, #0
 8001e1a:	d1f3      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8001e1c:	68a1      	ldr	r1, [r4, #8]
 8001e1e:	3003      	adds	r0, #3
 8001e20:	424b      	negs	r3, r1
 8001e22:	4159      	adcs	r1, r3
 8001e24:	b2c9      	uxtb	r1, r1
 8001e26:	f7fe fbeb 	bl	8000600 <_test_assert>
 8001e2a:	2800      	cmp	r0, #0
 8001e2c:	d1ea      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001e2e:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001e30:	4b3a      	ldr	r3, [pc, #232]	; (8001f1c <sem2_execute.lto_priv.84+0x13c>)
 8001e32:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001e34:	699b      	ldr	r3, [r3, #24]
 8001e36:	689a      	ldr	r2, [r3, #8]
 8001e38:	9000      	str	r0, [sp, #0]
 8001e3a:	3a01      	subs	r2, #1
 8001e3c:	4b38      	ldr	r3, [pc, #224]	; (8001f20 <sem2_execute.lto_priv.84+0x140>)
 8001e3e:	4839      	ldr	r0, [pc, #228]	; (8001f24 <sem2_execute.lto_priv.84+0x144>)
 8001e40:	f7fe fdbe 	bl	80009c0 <chThdCreateStatic>
 8001e44:	4b38      	ldr	r3, [pc, #224]	; (8001f28 <sem2_execute.lto_priv.84+0x148>)
 8001e46:	6018      	str	r0, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e48:	b672      	cpsid	i
 8001e4a:	21fa      	movs	r1, #250	; 0xfa
 8001e4c:	1c20      	adds	r0, r4, #0
 8001e4e:	0049      	lsls	r1, r1, #1
 8001e50:	f7ff fa56 	bl	8001300 <chSemWaitTimeoutS>
 8001e54:	1c05      	adds	r5, r0, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001e56:	b662      	cpsie	i
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
  test_wait_threads();
 8001e58:	f7ff f8f2 	bl	8001040 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 8001e5c:	4269      	negs	r1, r5
 8001e5e:	4169      	adcs	r1, r5
 8001e60:	2004      	movs	r0, #4
 8001e62:	b2c9      	uxtb	r1, r1
 8001e64:	f7fe fbcc 	bl	8000600 <_test_assert>
 8001e68:	2800      	cmp	r0, #0
 8001e6a:	d1cb      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>
 8001e6c:	6823      	ldr	r3, [r4, #0]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 8001e6e:	3005      	adds	r0, #5
 8001e70:	1b19      	subs	r1, r3, r4
 8001e72:	424a      	negs	r2, r1
 8001e74:	414a      	adcs	r2, r1
 8001e76:	b2d1      	uxtb	r1, r2
 8001e78:	f7fe fbc2 	bl	8000600 <_test_assert>
 8001e7c:	2800      	cmp	r0, #0
 8001e7e:	d1c1      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 8001e80:	68a1      	ldr	r1, [r4, #8]
 8001e82:	3006      	adds	r0, #6
 8001e84:	424b      	negs	r3, r1
 8001e86:	4159      	adcs	r1, r3
 8001e88:	b2c9      	uxtb	r1, r1
 8001e8a:	f7fe fbb9 	bl	8000600 <_test_assert>
 8001e8e:	2800      	cmp	r0, #0
 8001e90:	d1b8      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8001e92:	f7ff fb75 	bl	8001580 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e96:	b672      	cpsid	i
 8001e98:	4b24      	ldr	r3, [pc, #144]	; (8001f2c <sem2_execute.lto_priv.84+0x14c>)
 8001e9a:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001e9c:	b662      	cpsie	i
 8001e9e:	2541      	movs	r5, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8001ea0:	1c28      	adds	r0, r5, #0
 8001ea2:	f7fe fbc5 	bl	8000630 <test_emit_token>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ea6:	b672      	cpsid	i
 8001ea8:	2132      	movs	r1, #50	; 0x32
 8001eaa:	1c20      	adds	r0, r4, #0
 8001eac:	f7ff fa28 	bl	8001300 <chSemWaitTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001eb0:	b662      	cpsie	i
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8001eb2:	3001      	adds	r0, #1
 8001eb4:	4241      	negs	r1, r0
 8001eb6:	4141      	adcs	r1, r0
 8001eb8:	2007      	movs	r0, #7
 8001eba:	b2c9      	uxtb	r1, r1
 8001ebc:	f7fe fba0 	bl	8000600 <_test_assert>
 8001ec0:	2800      	cmp	r0, #0
 8001ec2:	d19f      	bne.n	8001e04 <sem2_execute.lto_priv.84+0x24>
 8001ec4:	6823      	ldr	r3, [r4, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8001ec6:	3008      	adds	r0, #8
 8001ec8:	1b19      	subs	r1, r3, r4
 8001eca:	424a      	negs	r2, r1
 8001ecc:	414a      	adcs	r2, r1
 8001ece:	b2d1      	uxtb	r1, r2
 8001ed0:	f7fe fb96 	bl	8000600 <_test_assert>
 8001ed4:	2800      	cmp	r0, #0
 8001ed6:	d000      	beq.n	8001eda <sem2_execute.lto_priv.84+0xfa>
 8001ed8:	e794      	b.n	8001e04 <sem2_execute.lto_priv.84+0x24>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8001eda:	68a1      	ldr	r1, [r4, #8]
 8001edc:	3009      	adds	r0, #9
 8001ede:	424b      	negs	r3, r1
 8001ee0:	4159      	adcs	r1, r3
 8001ee2:	b2c9      	uxtb	r1, r1
 8001ee4:	f7fe fb8c 	bl	8000600 <_test_assert>
 8001ee8:	2800      	cmp	r0, #0
 8001eea:	d000      	beq.n	8001eee <sem2_execute.lto_priv.84+0x10e>
 8001eec:	e78a      	b.n	8001e04 <sem2_execute.lto_priv.84+0x24>
 8001eee:	3501      	adds	r5, #1
 8001ef0:	b2ed      	uxtb	r5, r5
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 8001ef2:	2d46      	cmp	r5, #70	; 0x46
 8001ef4:	d1d4      	bne.n	8001ea0 <sem2_execute.lto_priv.84+0xc0>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8001ef6:	300a      	adds	r0, #10
 8001ef8:	490d      	ldr	r1, [pc, #52]	; (8001f30 <sem2_execute.lto_priv.84+0x150>)
 8001efa:	f7fe fb51 	bl	80005a0 <_test_assert_sequence>
 8001efe:	2800      	cmp	r0, #0
 8001f00:	d000      	beq.n	8001f04 <sem2_execute.lto_priv.84+0x124>
 8001f02:	e77f      	b.n	8001e04 <sem2_execute.lto_priv.84+0x24>
 8001f04:	b2b6      	uxth	r6, r6

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8001f06:	1c31      	adds	r1, r6, #0
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8001f08:	36fc      	adds	r6, #252	; 0xfc

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8001f0a:	31fa      	adds	r1, #250	; 0xfa
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8001f0c:	b289      	uxth	r1, r1
 8001f0e:	b2b2      	uxth	r2, r6
 8001f10:	300b      	adds	r0, #11
 8001f12:	f7fe fb25 	bl	8000560 <_test_assert_time_window>
 8001f16:	e775      	b.n	8001e04 <sem2_execute.lto_priv.84+0x24>
 8001f18:	20000600 	.word	0x20000600
 8001f1c:	20000f20 	.word	0x20000f20
 8001f20:	08001c01 	.word	0x08001c01
 8001f24:	200006c0 	.word	0x200006c0
 8001f28:	20001090 	.word	0x20001090
 8001f2c:	40000400 	.word	0x40000400
 8001f30:	08005600 	.word	0x08005600
 8001f34:	46c0      	nop			; (mov r8, r8)
 8001f36:	46c0      	nop			; (mov r8, r8)
 8001f38:	46c0      	nop			; (mov r8, r8)
 8001f3a:	46c0      	nop			; (mov r8, r8)
 8001f3c:	46c0      	nop			; (mov r8, r8)
 8001f3e:	46c0      	nop			; (mov r8, r8)

08001f40 <sem1_execute.lto_priv.82>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8001f40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f42:	464f      	mov	r7, r9
 8001f44:	4646      	mov	r6, r8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8001f46:	21a4      	movs	r1, #164	; 0xa4

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8001f48:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001f4a:	4b4f      	ldr	r3, [pc, #316]	; (8002088 <sem1_execute.lto_priv.82+0x148>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8001f4c:	4f4f      	ldr	r7, [pc, #316]	; (800208c <sem1_execute.lto_priv.82+0x14c>)
 8001f4e:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001f50:	699b      	ldr	r3, [r3, #24]
 8001f52:	4e4f      	ldr	r6, [pc, #316]	; (8002090 <sem1_execute.lto_priv.82+0x150>)
 8001f54:	689a      	ldr	r2, [r3, #8]
 8001f56:	4b4f      	ldr	r3, [pc, #316]	; (8002094 <sem1_execute.lto_priv.82+0x154>)

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8001f58:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8001f5a:	3205      	adds	r2, #5
 8001f5c:	9300      	str	r3, [sp, #0]
 8001f5e:	0049      	lsls	r1, r1, #1
 8001f60:	4699      	mov	r9, r3
 8001f62:	1c38      	adds	r0, r7, #0
 8001f64:	1c33      	adds	r3, r6, #0
 8001f66:	f7fe fd2b 	bl	80009c0 <chThdCreateStatic>
 8001f6a:	4643      	mov	r3, r8
 8001f6c:	4d4a      	ldr	r5, [pc, #296]	; (8002098 <sem1_execute.lto_priv.82+0x158>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8001f6e:	21a4      	movs	r1, #164	; 0xa4
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8001f70:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8001f72:	1c38      	adds	r0, r7, #0
 8001f74:	699b      	ldr	r3, [r3, #24]
 8001f76:	3049      	adds	r0, #73	; 0x49
 8001f78:	689a      	ldr	r2, [r3, #8]
 8001f7a:	4b48      	ldr	r3, [pc, #288]	; (800209c <sem1_execute.lto_priv.82+0x15c>)
 8001f7c:	3201      	adds	r2, #1
 8001f7e:	9300      	str	r3, [sp, #0]
 8001f80:	0049      	lsls	r1, r1, #1
 8001f82:	1c33      	adds	r3, r6, #0
 8001f84:	30ff      	adds	r0, #255	; 0xff
 8001f86:	f7fe fd1b 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8001f8a:	23a4      	movs	r3, #164	; 0xa4
 8001f8c:	009b      	lsls	r3, r3, #2
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8001f8e:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8001f90:	18f8      	adds	r0, r7, r3
 8001f92:	4643      	mov	r3, r8
 8001f94:	21a4      	movs	r1, #164	; 0xa4
 8001f96:	699b      	ldr	r3, [r3, #24]
 8001f98:	0049      	lsls	r1, r1, #1
 8001f9a:	689a      	ldr	r2, [r3, #8]
 8001f9c:	4b40      	ldr	r3, [pc, #256]	; (80020a0 <sem1_execute.lto_priv.82+0x160>)
 8001f9e:	3203      	adds	r2, #3
 8001fa0:	9300      	str	r3, [sp, #0]
 8001fa2:	1c33      	adds	r3, r6, #0
 8001fa4:	f7fe fd0c 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8001fa8:	23f6      	movs	r3, #246	; 0xf6
 8001faa:	009b      	lsls	r3, r3, #2

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8001fac:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8001fae:	18f8      	adds	r0, r7, r3
 8001fb0:	4643      	mov	r3, r8
 8001fb2:	21a4      	movs	r1, #164	; 0xa4
 8001fb4:	699b      	ldr	r3, [r3, #24]
 8001fb6:	0049      	lsls	r1, r1, #1
 8001fb8:	689a      	ldr	r2, [r3, #8]
 8001fba:	4b3a      	ldr	r3, [pc, #232]	; (80020a4 <sem1_execute.lto_priv.82+0x164>)
 8001fbc:	3204      	adds	r2, #4
 8001fbe:	9300      	str	r3, [sp, #0]
 8001fc0:	1c33      	adds	r3, r6, #0
 8001fc2:	f7fe fcfd 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001fc6:	23a4      	movs	r3, #164	; 0xa4
 8001fc8:	00db      	lsls	r3, r3, #3
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8001fca:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001fcc:	18f8      	adds	r0, r7, r3
 8001fce:	4643      	mov	r3, r8
 8001fd0:	21a4      	movs	r1, #164	; 0xa4
 8001fd2:	699b      	ldr	r3, [r3, #24]
 8001fd4:	0049      	lsls	r1, r1, #1
 8001fd6:	689a      	ldr	r2, [r3, #8]
 8001fd8:	4b33      	ldr	r3, [pc, #204]	; (80020a8 <sem1_execute.lto_priv.82+0x168>)
 8001fda:	3202      	adds	r2, #2
 8001fdc:	9300      	str	r3, [sp, #0]
 8001fde:	1c33      	adds	r3, r6, #0
 8001fe0:	f7fe fcee 	bl	80009c0 <chThdCreateStatic>
  chSemSignal(&sem1);
 8001fe4:	4c31      	ldr	r4, [pc, #196]	; (80020ac <sem1_execute.lto_priv.82+0x16c>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001fe6:	6128      	str	r0, [r5, #16]
  chSemSignal(&sem1);
 8001fe8:	1c20      	adds	r0, r4, #0
 8001fea:	f7fe fcd1 	bl	8000990 <chSemSignal>
  chSemSignal(&sem1);
 8001fee:	1c20      	adds	r0, r4, #0
 8001ff0:	f7fe fcce 	bl	8000990 <chSemSignal>
  chSemSignal(&sem1);
 8001ff4:	1c20      	adds	r0, r4, #0
 8001ff6:	f7fe fccb 	bl	8000990 <chSemSignal>
  chSemSignal(&sem1);
 8001ffa:	1c20      	adds	r0, r4, #0
 8001ffc:	f7fe fcc8 	bl	8000990 <chSemSignal>
  chSemSignal(&sem1);
 8002000:	1c20      	adds	r0, r4, #0
 8002002:	f7fe fcc5 	bl	8000990 <chSemSignal>
  test_wait_threads();
 8002006:	f7ff f81b 	bl	8001040 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 800200a:	2001      	movs	r0, #1
 800200c:	4928      	ldr	r1, [pc, #160]	; (80020b0 <sem1_execute.lto_priv.82+0x170>)
 800200e:	f7fe fac7 	bl	80005a0 <_test_assert_sequence>
 8002012:	2800      	cmp	r0, #0
 8002014:	d004      	beq.n	8002020 <sem1_execute.lto_priv.82+0xe0>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 8002016:	b003      	add	sp, #12
 8002018:	bc0c      	pop	{r2, r3}
 800201a:	4690      	mov	r8, r2
 800201c:	4699      	mov	r9, r3
 800201e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002020:	4643      	mov	r3, r8
 8002022:	699b      	ldr	r3, [r3, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002024:	21a4      	movs	r1, #164	; 0xa4
 8002026:	689a      	ldr	r2, [r3, #8]
 8002028:	464b      	mov	r3, r9
 800202a:	3205      	adds	r2, #5
 800202c:	9300      	str	r3, [sp, #0]
 800202e:	1c38      	adds	r0, r7, #0
 8002030:	0049      	lsls	r1, r1, #1
 8002032:	1c33      	adds	r3, r6, #0
 8002034:	f7fe fcc4 	bl	80009c0 <chThdCreateStatic>
 8002038:	6028      	str	r0, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800203a:	b672      	cpsid	i
 800203c:	2502      	movs	r5, #2
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 800203e:	1c26      	adds	r6, r4, #0
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002040:	2700      	movs	r7, #0
 8002042:	e002      	b.n	800204a <sem1_execute.lto_priv.82+0x10a>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002044:	2d01      	cmp	r5, #1
 8002046:	d00e      	beq.n	8002066 <sem1_execute.lto_priv.82+0x126>
 8002048:	2501      	movs	r5, #1
    if (++sp->s_cnt <= (cnt_t)0) {
 800204a:	68a3      	ldr	r3, [r4, #8]
 800204c:	3301      	adds	r3, #1
 800204e:	60a3      	str	r3, [r4, #8]
 8002050:	2b00      	cmp	r3, #0
 8002052:	dcf7      	bgt.n	8002044 <sem1_execute.lto_priv.82+0x104>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8002054:	6830      	ldr	r0, [r6, #0]

  tqp->p_next = tp->p_next;
 8002056:	6803      	ldr	r3, [r0, #0]
 8002058:	6033      	str	r3, [r6, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800205a:	605e      	str	r6, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 800205c:	f7fe fd30 	bl	8000ac0 <chSchReadyI>
 8002060:	6207      	str	r7, [r0, #32]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002062:	2d01      	cmp	r5, #1
 8002064:	d1f0      	bne.n	8002048 <sem1_execute.lto_priv.82+0x108>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
 8002066:	f7fe fc13 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800206a:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 800206c:	f7fe ffe8 	bl	8001040 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002070:	b672      	cpsid	i
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8002072:	68a1      	ldr	r1, [r4, #8]
 8002074:	2002      	movs	r0, #2
 8002076:	3901      	subs	r1, #1
 8002078:	424a      	negs	r2, r1
 800207a:	414a      	adcs	r2, r1
 800207c:	b2d1      	uxtb	r1, r2
 800207e:	f7fe fabf 	bl	8000600 <_test_assert>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002082:	b662      	cpsie	i
 8002084:	e7c7      	b.n	8002016 <sem1_execute.lto_priv.82+0xd6>
 8002086:	46c0      	nop			; (mov r8, r8)
 8002088:	20000f20 	.word	0x20000f20
 800208c:	200006c0 	.word	0x200006c0
 8002090:	08001bc1 	.word	0x08001bc1
 8002094:	080055f4 	.word	0x080055f4
 8002098:	20001090 	.word	0x20001090
 800209c:	080055f0 	.word	0x080055f0
 80020a0:	080055fc 	.word	0x080055fc
 80020a4:	080055f8 	.word	0x080055f8
 80020a8:	08005604 	.word	0x08005604
 80020ac:	20000600 	.word	0x20000600
 80020b0:	08005600 	.word	0x08005600
 80020b4:	46c0      	nop			; (mov r8, r8)
 80020b6:	46c0      	nop			; (mov r8, r8)
 80020b8:	46c0      	nop			; (mov r8, r8)
 80020ba:	46c0      	nop			; (mov r8, r8)
 80020bc:	46c0      	nop			; (mov r8, r8)
 80020be:	46c0      	nop			; (mov r8, r8)

080020c0 <thd2_execute.lto_priv.78>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 80020c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020c2:	464f      	mov	r7, r9
 80020c4:	4646      	mov	r6, r8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80020c6:	23a4      	movs	r3, #164	; 0xa4
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 80020c8:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80020ca:	4e45      	ldr	r6, [pc, #276]	; (80021e0 <thd2_execute.lto_priv.78+0x120>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80020cc:	005b      	lsls	r3, r3, #1
 80020ce:	4699      	mov	r9, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80020d0:	69b3      	ldr	r3, [r6, #24]
 80020d2:	4d44      	ldr	r5, [pc, #272]	; (80021e4 <thd2_execute.lto_priv.78+0x124>)
 80020d4:	689a      	ldr	r2, [r3, #8]
 80020d6:	4b44      	ldr	r3, [pc, #272]	; (80021e8 <thd2_execute.lto_priv.78+0x128>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 80020d8:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80020da:	4698      	mov	r8, r3
 80020dc:	4b43      	ldr	r3, [pc, #268]	; (80021ec <thd2_execute.lto_priv.78+0x12c>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80020de:	1c2c      	adds	r4, r5, #0
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80020e0:	9300      	str	r3, [sp, #0]
 80020e2:	4649      	mov	r1, r9
 80020e4:	4643      	mov	r3, r8
 80020e6:	3a04      	subs	r2, #4
 80020e8:	1c28      	adds	r0, r5, #0
 80020ea:	f7fe fc69 	bl	80009c0 <chThdCreateStatic>
 80020ee:	69b3      	ldr	r3, [r6, #24]
 80020f0:	4f3f      	ldr	r7, [pc, #252]	; (80021f0 <thd2_execute.lto_priv.78+0x130>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80020f2:	689a      	ldr	r2, [r3, #8]
 80020f4:	3c49      	subs	r4, #73	; 0x49
 80020f6:	4b3f      	ldr	r3, [pc, #252]	; (80021f4 <thd2_execute.lto_priv.78+0x134>)
 80020f8:	3cff      	subs	r4, #255	; 0xff
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80020fa:	6078      	str	r0, [r7, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80020fc:	4649      	mov	r1, r9
 80020fe:	9300      	str	r3, [sp, #0]
 8002100:	3a05      	subs	r2, #5
 8002102:	4643      	mov	r3, r8
 8002104:	1c20      	adds	r0, r4, #0
 8002106:	f7fe fc5b 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800210a:	23f6      	movs	r3, #246	; 0xf6
 800210c:	009b      	lsls	r3, r3, #2
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800210e:	6038      	str	r0, [r7, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002110:	18e8      	adds	r0, r5, r3
 8002112:	69b3      	ldr	r3, [r6, #24]
 8002114:	4649      	mov	r1, r9
 8002116:	689a      	ldr	r2, [r3, #8]
 8002118:	4b37      	ldr	r3, [pc, #220]	; (80021f8 <thd2_execute.lto_priv.78+0x138>)
 800211a:	3a01      	subs	r2, #1
 800211c:	9300      	str	r3, [sp, #0]
 800211e:	4643      	mov	r3, r8
 8002120:	f7fe fc4e 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002124:	23a4      	movs	r3, #164	; 0xa4
 8002126:	009b      	lsls	r3, r3, #2

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002128:	6138      	str	r0, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800212a:	18e8      	adds	r0, r5, r3
 800212c:	69b3      	ldr	r3, [r6, #24]
 800212e:	4649      	mov	r1, r9
 8002130:	689a      	ldr	r2, [r3, #8]
 8002132:	4b32      	ldr	r3, [pc, #200]	; (80021fc <thd2_execute.lto_priv.78+0x13c>)
 8002134:	3a02      	subs	r2, #2
 8002136:	9300      	str	r3, [sp, #0]
 8002138:	4643      	mov	r3, r8
 800213a:	f7fe fc41 	bl	80009c0 <chThdCreateStatic>
 800213e:	60f8      	str	r0, [r7, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002140:	b672      	cpsid	i
 8002142:	69b3      	ldr	r3, [r6, #24]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8002144:	689a      	ldr	r2, [r3, #8]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002146:	239b      	movs	r3, #155	; 0x9b
 8002148:	009b      	lsls	r3, r3, #2
 800214a:	18e9      	adds	r1, r5, r3
 800214c:	3330      	adds	r3, #48	; 0x30
 800214e:	50e1      	str	r1, [r4, r3]
 8002150:	4641      	mov	r1, r8
 8002152:	3329      	adds	r3, #41	; 0x29
 8002154:	33ff      	adds	r3, #255	; 0xff
 8002156:	50e1      	str	r1, [r4, r3]
 8002158:	4929      	ldr	r1, [pc, #164]	; (8002200 <thd2_execute.lto_priv.78+0x140>)
 800215a:	3304      	adds	r3, #4
 800215c:	50e1      	str	r1, [r4, r3]
 800215e:	4929      	ldr	r1, [pc, #164]	; (8002204 <thd2_execute.lto_priv.78+0x144>)
 8002160:	330c      	adds	r3, #12
 8002162:	50e1      	str	r1, [r4, r3]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002164:	2102      	movs	r1, #2
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002166:	3b3d      	subs	r3, #61	; 0x3d
 8002168:	3a03      	subs	r2, #3
 800216a:	3bff      	subs	r3, #255	; 0xff
 800216c:	50e2      	str	r2, [r4, r3]
  tp->p_state = CH_STATE_WTSTART;
 800216e:	3314      	adds	r3, #20
 8002170:	54e1      	strb	r1, [r4, r3]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002172:	2300      	movs	r3, #0
 8002174:	4924      	ldr	r1, [pc, #144]	; (8002208 <thd2_execute.lto_priv.78+0x148>)
 8002176:	5463      	strb	r3, [r4, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002178:	311f      	adds	r1, #31
 800217a:	5062      	str	r2, [r4, r1]
  tp->p_mtxlist = NULL;
 800217c:	22b2      	movs	r2, #178	; 0xb2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800217e:	2101      	movs	r1, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002180:	0092      	lsls	r2, r2, #2
 8002182:	50a3      	str	r3, [r4, r2]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002184:	3a04      	subs	r2, #4
 8002186:	50a3      	str	r3, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002188:	4a20      	ldr	r2, [pc, #128]	; (800220c <thd2_execute.lto_priv.78+0x14c>)
 800218a:	54a1      	strb	r1, [r4, r2]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800218c:	3a06      	subs	r2, #6
 800218e:	50a3      	str	r3, [r4, r2]
  REG_INSERT(tp);
 8002190:	23a8      	movs	r3, #168	; 0xa8
 8002192:	6972      	ldr	r2, [r6, #20]
 8002194:	009b      	lsls	r3, r3, #2
 8002196:	50e6      	str	r6, [r4, r3]
 8002198:	3304      	adds	r3, #4
 800219a:	50e2      	str	r2, [r4, r3]
 800219c:	1c2b      	adds	r3, r5, #0
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800219e:	1c29      	adds	r1, r5, #0
 80021a0:	444b      	add	r3, r9
 80021a2:	6113      	str	r3, [r2, #16]
 80021a4:	22ad      	movs	r2, #173	; 0xad
 80021a6:	316d      	adds	r1, #109	; 0x6d
 80021a8:	31ff      	adds	r1, #255	; 0xff
 80021aa:	0092      	lsls	r2, r2, #2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80021ac:	3571      	adds	r5, #113	; 0x71
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80021ae:	50a1      	str	r1, [r4, r2]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80021b0:	35ff      	adds	r5, #255	; 0xff
 80021b2:	3204      	adds	r2, #4
 80021b4:	50a5      	str	r5, [r4, r2]
  tqp->p_prev = (thread_t *)tqp;
 80021b6:	3204      	adds	r2, #4
 80021b8:	6173      	str	r3, [r6, #20]
 80021ba:	50a5      	str	r5, [r4, r2]
 80021bc:	60bb      	str	r3, [r7, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80021be:	b662      	cpsie	i
  chSysUnlock();
  chThdStart(threads[2]);
 80021c0:	68b8      	ldr	r0, [r7, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80021c2:	b672      	cpsid	i
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80021c4:	f7fe fc7c 	bl	8000ac0 <chSchReadyI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80021c8:	b662      	cpsie	i
  test_wait_threads();
 80021ca:	f7fe ff39 	bl	8001040 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 80021ce:	4910      	ldr	r1, [pc, #64]	; (8002210 <thd2_execute.lto_priv.78+0x150>)
 80021d0:	2001      	movs	r0, #1
 80021d2:	f7fe f9e5 	bl	80005a0 <_test_assert_sequence>
}
 80021d6:	b003      	add	sp, #12
 80021d8:	bc0c      	pop	{r2, r3}
 80021da:	4690      	mov	r8, r2
 80021dc:	4699      	mov	r9, r3
 80021de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80021e0:	20000f20 	.word	0x20000f20
 80021e4:	20000808 	.word	0x20000808
 80021e8:	08000651 	.word	0x08000651
 80021ec:	080055f8 	.word	0x080055f8
 80021f0:	20001090 	.word	0x20001090
 80021f4:	08005604 	.word	0x08005604
 80021f8:	080055f4 	.word	0x080055f4
 80021fc:	080055f0 	.word	0x080055f0
 8002200:	080055fc 	.word	0x080055fc
 8002204:	080001a1 	.word	0x080001a1
 8002208:	000002ad 	.word	0x000002ad
 800220c:	000002ae 	.word	0x000002ae
 8002210:	08005600 	.word	0x08005600
 8002214:	46c0      	nop			; (mov r8, r8)
 8002216:	46c0      	nop			; (mov r8, r8)
 8002218:	46c0      	nop			; (mov r8, r8)
 800221a:	46c0      	nop			; (mov r8, r8)
 800221c:	46c0      	nop			; (mov r8, r8)
 800221e:	46c0      	nop			; (mov r8, r8)

08002220 <thd4_execute.lto_priv.80>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8002220:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 8002222:	f7ff f9ad 	bl	8001580 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002226:	b672      	cpsid	i
 8002228:	4d27      	ldr	r5, [pc, #156]	; (80022c8 <thd4_execute.lto_priv.80+0xa8>)
 800222a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 800222c:	b2a4      	uxth	r4, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800222e:	b662      	cpsie	i

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8002230:	2064      	movs	r0, #100	; 0x64
 8002232:	f7ff f99d 	bl	8001570 <chThdSleep>
  test_assert_time_window(1,
 8002236:	1c21      	adds	r1, r4, #0
 8002238:	3467      	adds	r4, #103	; 0x67
 800223a:	3164      	adds	r1, #100	; 0x64
 800223c:	b289      	uxth	r1, r1
 800223e:	b2a2      	uxth	r2, r4
 8002240:	2001      	movs	r0, #1
 8002242:	f7fe f98d 	bl	8000560 <_test_assert_time_window>
 8002246:	2800      	cmp	r0, #0
 8002248:	d000      	beq.n	800224c <thd4_execute.lto_priv.80+0x2c>
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800224a:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800224c:	b672      	cpsid	i
 800224e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8002250:	b2a4      	uxth	r4, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002252:	b662      	cpsie	i
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 8002254:	3064      	adds	r0, #100	; 0x64
 8002256:	f7ff f98b 	bl	8001570 <chThdSleep>
  test_assert_time_window(2,
 800225a:	1c21      	adds	r1, r4, #0
 800225c:	3467      	adds	r4, #103	; 0x67
 800225e:	3164      	adds	r1, #100	; 0x64
 8002260:	b289      	uxth	r1, r1
 8002262:	b2a2      	uxth	r2, r4
 8002264:	2002      	movs	r0, #2
 8002266:	f7fe f97b 	bl	8000560 <_test_assert_time_window>
 800226a:	2800      	cmp	r0, #0
 800226c:	d1ed      	bne.n	800224a <thd4_execute.lto_priv.80+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800226e:	b672      	cpsid	i
 8002270:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8002272:	b2a4      	uxth	r4, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002274:	b662      	cpsie	i
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 8002276:	20fa      	movs	r0, #250	; 0xfa
 8002278:	0080      	lsls	r0, r0, #2
 800227a:	f7ff f979 	bl	8001570 <chThdSleep>
  test_assert_time_window(3,
 800227e:	23fa      	movs	r3, #250	; 0xfa
 8002280:	009b      	lsls	r3, r3, #2
 8002282:	18e1      	adds	r1, r4, r3
 8002284:	4b11      	ldr	r3, [pc, #68]	; (80022cc <thd4_execute.lto_priv.80+0xac>)
 8002286:	b289      	uxth	r1, r1
 8002288:	18e2      	adds	r2, r4, r3
 800228a:	b292      	uxth	r2, r2
 800228c:	2003      	movs	r0, #3
 800228e:	f7fe f967 	bl	8000560 <_test_assert_time_window>
 8002292:	2800      	cmp	r0, #0
 8002294:	d1d9      	bne.n	800224a <thd4_execute.lto_priv.80+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002296:	b672      	cpsid	i
 8002298:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 800229a:	b2a4      	uxth	r4, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800229c:	b662      	cpsie	i
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800229e:	1c26      	adds	r6, r4, #0
 80022a0:	3664      	adds	r6, #100	; 0x64
 80022a2:	b2b6      	uxth	r6, r6
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022a4:	b672      	cpsid	i
 80022a6:	6a69      	ldr	r1, [r5, #36]	; 0x24
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
 80022a8:	1a71      	subs	r1, r6, r1
 80022aa:	b289      	uxth	r1, r1
  if (time > (systime_t)0) {
 80022ac:	2900      	cmp	r1, #0
 80022ae:	d107      	bne.n	80022c0 <thd4_execute.lto_priv.80+0xa0>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80022b0:	b662      	cpsie	i
  chThdSleepUntil(time);
  test_assert_time_window(4,
 80022b2:	3467      	adds	r4, #103	; 0x67
 80022b4:	b2a2      	uxth	r2, r4
 80022b6:	1c31      	adds	r1, r6, #0
 80022b8:	2004      	movs	r0, #4
 80022ba:	f7fe f951 	bl	8000560 <_test_assert_time_window>
 80022be:	e7c4      	b.n	800224a <thd4_execute.lto_priv.80+0x2a>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80022c0:	3008      	adds	r0, #8
 80022c2:	f7fe fff5 	bl	80012b0 <chSchGoSleepTimeoutS>
 80022c6:	e7f3      	b.n	80022b0 <thd4_execute.lto_priv.80+0x90>
 80022c8:	40000400 	.word	0x40000400
 80022cc:	000003eb 	.word	0x000003eb

080022d0 <thd3_execute.lto_priv.79>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 80022d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80022d2:	4e49      	ldr	r6, [pc, #292]	; (80023f8 <thd3_execute.lto_priv.79+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80022d4:	69b3      	ldr	r3, [r6, #24]
 80022d6:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80022d8:	1c65      	adds	r5, r4, #1
 80022da:	1c28      	adds	r0, r5, #0
 80022dc:	f7fe fae8 	bl	80008b0 <chThdSetPriority>
  test_assert(1, p1 == prio,
 80022e0:	1b01      	subs	r1, r0, r4
 80022e2:	424a      	negs	r2, r1
 80022e4:	414a      	adcs	r2, r1

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80022e6:	1c07      	adds	r7, r0, #0
  test_assert(1, p1 == prio,
 80022e8:	b2d1      	uxtb	r1, r2
 80022ea:	2001      	movs	r0, #1
 80022ec:	f7fe f988 	bl	8000600 <_test_assert>
 80022f0:	2800      	cmp	r0, #0
 80022f2:	d000      	beq.n	80022f6 <thd3_execute.lto_priv.79+0x26>
  chSysLock();
  chThdGetSelfX()->p_prio = prio;
  chThdGetSelfX()->p_realprio = prio;
  chSysUnlock();
#endif
}
 80022f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80022f6:	69b3      	ldr	r3, [r6, #24]

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 80022f8:	3002      	adds	r0, #2
 80022fa:	6899      	ldr	r1, [r3, #8]
 80022fc:	1a69      	subs	r1, r5, r1
 80022fe:	424a      	negs	r2, r1
 8002300:	414a      	adcs	r2, r1
 8002302:	b2d1      	uxtb	r1, r2
 8002304:	f7fe f97c 	bl	8000600 <_test_assert>
 8002308:	2800      	cmp	r0, #0
 800230a:	d1f3      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800230c:	1c38      	adds	r0, r7, #0
 800230e:	f7fe facf 	bl	80008b0 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 8002312:	1a29      	subs	r1, r5, r0
 8002314:	424b      	negs	r3, r1
 8002316:	414b      	adcs	r3, r1
 8002318:	2003      	movs	r0, #3
 800231a:	b2d9      	uxtb	r1, r3
 800231c:	f7fe f970 	bl	8000600 <_test_assert>
 8002320:	2800      	cmp	r0, #0
 8002322:	d1e7      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
 8002324:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8002326:	3004      	adds	r0, #4
 8002328:	6899      	ldr	r1, [r3, #8]
 800232a:	1a61      	subs	r1, r4, r1
 800232c:	424a      	negs	r2, r1
 800232e:	414a      	adcs	r2, r1
 8002330:	b2d1      	uxtb	r1, r2
 8002332:	f7fe f965 	bl	8000600 <_test_assert>
 8002336:	2800      	cmp	r0, #0
 8002338:	d1dc      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800233a:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800233c:	69b2      	ldr	r2, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 800233e:	6893      	ldr	r3, [r2, #8]
 8002340:	3302      	adds	r3, #2
 8002342:	6093      	str	r3, [r2, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002344:	b662      	cpsie	i
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002346:	69b3      	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8002348:	1ca7      	adds	r7, r4, #2
 800234a:	6899      	ldr	r1, [r3, #8]
 800234c:	3005      	adds	r0, #5
 800234e:	1a79      	subs	r1, r7, r1
 8002350:	424a      	negs	r2, r1
 8002352:	414a      	adcs	r2, r1
 8002354:	b2d1      	uxtb	r1, r2
 8002356:	f7fe f953 	bl	8000600 <_test_assert>
 800235a:	2800      	cmp	r0, #0
 800235c:	d1ca      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800235e:	1c28      	adds	r0, r5, #0
 8002360:	f7fe faa6 	bl	80008b0 <chThdSetPriority>
  test_assert(6, p1 == prio,
 8002364:	1b01      	subs	r1, r0, r4
 8002366:	424b      	negs	r3, r1
 8002368:	414b      	adcs	r3, r1
 800236a:	2006      	movs	r0, #6
 800236c:	b2d9      	uxtb	r1, r3
 800236e:	f7fe f947 	bl	8000600 <_test_assert>
 8002372:	2800      	cmp	r0, #0
 8002374:	d1be      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8002376:	69b3      	ldr	r3, [r6, #24]
 8002378:	3007      	adds	r0, #7
 800237a:	6899      	ldr	r1, [r3, #8]
 800237c:	1a79      	subs	r1, r7, r1
 800237e:	424b      	negs	r3, r1
 8002380:	414b      	adcs	r3, r1
 8002382:	b2d9      	uxtb	r1, r3
 8002384:	f7fe f93c 	bl	8000600 <_test_assert>
 8002388:	2800      	cmp	r0, #0
 800238a:	d1b3      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800238c:	69b3      	ldr	r3, [r6, #24]
 800238e:	3008      	adds	r0, #8
 8002390:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8002392:	1a69      	subs	r1, r5, r1
 8002394:	424a      	negs	r2, r1
 8002396:	414a      	adcs	r2, r1
 8002398:	b2d1      	uxtb	r1, r2
 800239a:	f7fe f931 	bl	8000600 <_test_assert>
 800239e:	2800      	cmp	r0, #0
 80023a0:	d1a8      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 80023a2:	1ce7      	adds	r7, r4, #3
 80023a4:	1c38      	adds	r0, r7, #0
 80023a6:	f7fe fa83 	bl	80008b0 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 80023aa:	1a29      	subs	r1, r5, r0
 80023ac:	424b      	negs	r3, r1
 80023ae:	414b      	adcs	r3, r1
 80023b0:	2009      	movs	r0, #9
 80023b2:	b2d9      	uxtb	r1, r3
 80023b4:	f7fe f924 	bl	8000600 <_test_assert>
 80023b8:	2800      	cmp	r0, #0
 80023ba:	d19b      	bne.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 80023bc:	69b3      	ldr	r3, [r6, #24]
 80023be:	300a      	adds	r0, #10
 80023c0:	6899      	ldr	r1, [r3, #8]
 80023c2:	1a79      	subs	r1, r7, r1
 80023c4:	424a      	negs	r2, r1
 80023c6:	414a      	adcs	r2, r1
 80023c8:	b2d1      	uxtb	r1, r2
 80023ca:	f7fe f919 	bl	8000600 <_test_assert>
 80023ce:	2800      	cmp	r0, #0
 80023d0:	d000      	beq.n	80023d4 <thd3_execute.lto_priv.79+0x104>
 80023d2:	e78f      	b.n	80022f4 <thd3_execute.lto_priv.79+0x24>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 80023d4:	69b3      	ldr	r3, [r6, #24]
 80023d6:	300b      	adds	r0, #11
 80023d8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80023da:	1a79      	subs	r1, r7, r1
 80023dc:	424b      	negs	r3, r1
 80023de:	414b      	adcs	r3, r1
 80023e0:	b2d9      	uxtb	r1, r3
 80023e2:	f7fe f90d 	bl	8000600 <_test_assert>
 80023e6:	2800      	cmp	r0, #0
 80023e8:	d000      	beq.n	80023ec <thd3_execute.lto_priv.79+0x11c>
 80023ea:	e783      	b.n	80022f4 <thd3_execute.lto_priv.79+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80023ec:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80023ee:	69b3      	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 80023f0:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 80023f2:	63dc      	str	r4, [r3, #60]	; 0x3c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80023f4:	b662      	cpsie	i
 80023f6:	e77d      	b.n	80022f4 <thd3_execute.lto_priv.79+0x24>
 80023f8:	20000f20 	.word	0x20000f20
 80023fc:	46c0      	nop			; (mov r8, r8)
 80023fe:	46c0      	nop			; (mov r8, r8)

08002400 <Thread1>:

/*
 * Red LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002400:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8002402:	2490      	movs	r4, #144	; 0x90
 8002404:	2620      	movs	r6, #32
 8002406:	2520      	movs	r5, #32
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
 8002408:	4b07      	ldr	r3, [pc, #28]	; (8002428 <Thread1+0x28>)
 800240a:	4a08      	ldr	r2, [pc, #32]	; (800242c <Thread1+0x2c>)
 800240c:	699b      	ldr	r3, [r3, #24]
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 800240e:	05e4      	lsls	r4, r4, #23
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
 8002410:	619a      	str	r2, [r3, #24]
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
    chThdSleepMilliseconds(500);
 8002412:	20fa      	movs	r0, #250	; 0xfa
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8002414:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 8002416:	0040      	lsls	r0, r0, #1
 8002418:	f7ff f8aa 	bl	8001570 <chThdSleep>
    palSetPad(GPIOA, GPIOA_LED_GREEN);
    chThdSleepMilliseconds(500);
 800241c:	20fa      	movs	r0, #250	; 0xfa
  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED_GREEN);
 800241e:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 8002420:	0040      	lsls	r0, r0, #1
 8002422:	f7ff f8a5 	bl	8001570 <chThdSleep>
 8002426:	e7f4      	b.n	8002412 <Thread1+0x12>
 8002428:	20000f20 	.word	0x20000f20
 800242c:	08005a30 	.word	0x08005a30

08002430 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8002430:	b510      	push	{r4, lr}

  test_print("--- System: ");
 8002432:	482e      	ldr	r0, [pc, #184]	; (80024ec <bmk13_execute+0xbc>)
 8002434:	f7fe f934 	bl	80006a0 <test_print>
  test_printn(sizeof(ch_system_t));
 8002438:	20a4      	movs	r0, #164	; 0xa4
 800243a:	0040      	lsls	r0, r0, #1
 800243c:	f7fe f948 	bl	80006d0 <test_printn>
  test_println(" bytes");
 8002440:	4c2b      	ldr	r4, [pc, #172]	; (80024f0 <bmk13_execute+0xc0>)
 8002442:	1c20      	adds	r0, r4, #0
 8002444:	f7fe f90c 	bl	8000660 <test_println>
  test_print("--- Thread: ");
 8002448:	482a      	ldr	r0, [pc, #168]	; (80024f4 <bmk13_execute+0xc4>)
 800244a:	f7fe f929 	bl	80006a0 <test_print>
  test_printn(sizeof(thread_t));
 800244e:	2044      	movs	r0, #68	; 0x44
 8002450:	f7fe f93e 	bl	80006d0 <test_printn>
  test_println(" bytes");
 8002454:	1c20      	adds	r0, r4, #0
 8002456:	f7fe f903 	bl	8000660 <test_println>
  test_print("--- Timer : ");
 800245a:	4827      	ldr	r0, [pc, #156]	; (80024f8 <bmk13_execute+0xc8>)
 800245c:	f7fe f920 	bl	80006a0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8002460:	2014      	movs	r0, #20
 8002462:	f7fe f935 	bl	80006d0 <test_printn>
  test_println(" bytes");
 8002466:	1c20      	adds	r0, r4, #0
 8002468:	f7fe f8fa 	bl	8000660 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 800246c:	4823      	ldr	r0, [pc, #140]	; (80024fc <bmk13_execute+0xcc>)
 800246e:	f7fe f917 	bl	80006a0 <test_print>
  test_printn(sizeof(semaphore_t));
 8002472:	200c      	movs	r0, #12
 8002474:	f7fe f92c 	bl	80006d0 <test_printn>
  test_println(" bytes");
 8002478:	1c20      	adds	r0, r4, #0
 800247a:	f7fe f8f1 	bl	8000660 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 800247e:	4820      	ldr	r0, [pc, #128]	; (8002500 <bmk13_execute+0xd0>)
 8002480:	f7fe f90e 	bl	80006a0 <test_print>
  test_printn(sizeof(event_source_t));
 8002484:	2004      	movs	r0, #4
 8002486:	f7fe f923 	bl	80006d0 <test_printn>
  test_println(" bytes");
 800248a:	1c20      	adds	r0, r4, #0
 800248c:	f7fe f8e8 	bl	8000660 <test_println>
  test_print("--- EventL: ");
 8002490:	481c      	ldr	r0, [pc, #112]	; (8002504 <bmk13_execute+0xd4>)
 8002492:	f7fe f905 	bl	80006a0 <test_print>
  test_printn(sizeof(event_listener_t));
 8002496:	2014      	movs	r0, #20
 8002498:	f7fe f91a 	bl	80006d0 <test_printn>
  test_println(" bytes");
 800249c:	1c20      	adds	r0, r4, #0
 800249e:	f7fe f8df 	bl	8000660 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 80024a2:	4819      	ldr	r0, [pc, #100]	; (8002508 <bmk13_execute+0xd8>)
 80024a4:	f7fe f8fc 	bl	80006a0 <test_print>
  test_printn(sizeof(mutex_t));
 80024a8:	2010      	movs	r0, #16
 80024aa:	f7fe f911 	bl	80006d0 <test_printn>
  test_println(" bytes");
 80024ae:	1c20      	adds	r0, r4, #0
 80024b0:	f7fe f8d6 	bl	8000660 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 80024b4:	4815      	ldr	r0, [pc, #84]	; (800250c <bmk13_execute+0xdc>)
 80024b6:	f7fe f8f3 	bl	80006a0 <test_print>
  test_printn(sizeof(condition_variable_t));
 80024ba:	2008      	movs	r0, #8
 80024bc:	f7fe f908 	bl	80006d0 <test_printn>
  test_println(" bytes");
 80024c0:	1c20      	adds	r0, r4, #0
 80024c2:	f7fe f8cd 	bl	8000660 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 80024c6:	4812      	ldr	r0, [pc, #72]	; (8002510 <bmk13_execute+0xe0>)
 80024c8:	f7fe f8ea 	bl	80006a0 <test_print>
  test_printn(sizeof(io_queue_t));
 80024cc:	2024      	movs	r0, #36	; 0x24
 80024ce:	f7fe f8ff 	bl	80006d0 <test_printn>
  test_println(" bytes");
 80024d2:	1c20      	adds	r0, r4, #0
 80024d4:	f7fe f8c4 	bl	8000660 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 80024d8:	480e      	ldr	r0, [pc, #56]	; (8002514 <bmk13_execute+0xe4>)
 80024da:	f7fe f8e1 	bl	80006a0 <test_print>
  test_printn(sizeof(mailbox_t));
 80024de:	2028      	movs	r0, #40	; 0x28
 80024e0:	f7fe f8f6 	bl	80006d0 <test_printn>
  test_println(" bytes");
 80024e4:	1c20      	adds	r0, r4, #0
 80024e6:	f7fe f8bb 	bl	8000660 <test_println>
#endif
}
 80024ea:	bd10      	pop	{r4, pc}
 80024ec:	08005a38 	.word	0x08005a38
 80024f0:	08005a48 	.word	0x08005a48
 80024f4:	08005a50 	.word	0x08005a50
 80024f8:	08005a60 	.word	0x08005a60
 80024fc:	08005a70 	.word	0x08005a70
 8002500:	08005a80 	.word	0x08005a80
 8002504:	08005a90 	.word	0x08005a90
 8002508:	08005aa0 	.word	0x08005aa0
 800250c:	08005ab0 	.word	0x08005ab0
 8002510:	08005ac0 	.word	0x08005ac0
 8002514:	08005ad0 	.word	0x08005ad0
 8002518:	46c0      	nop			; (mov r8, r8)
 800251a:	46c0      	nop			; (mov r8, r8)
 800251c:	46c0      	nop			; (mov r8, r8)
 800251e:	46c0      	nop			; (mov r8, r8)

08002520 <chThdCreateFromHeap.constprop.57>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8002520:	b570      	push	{r4, r5, r6, lr}
 8002522:	1c0e      	adds	r6, r1, #0
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 8002524:	21a4      	movs	r1, #164	; 0xa4
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8002526:	1c05      	adds	r5, r0, #0
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 8002528:	0049      	lsls	r1, r1, #1
 800252a:	4816      	ldr	r0, [pc, #88]	; (8002584 <chThdCreateFromHeap.constprop.57+0x64>)
 800252c:	f7fe fda0 	bl	8001070 <chHeapAlloc>
 8002530:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 8002532:	d024      	beq.n	800257e <chThdCreateFromHeap.constprop.57+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002534:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002536:	1c03      	adds	r3, r0, #0
 8002538:	4a13      	ldr	r2, [pc, #76]	; (8002588 <chThdCreateFromHeap.constprop.57+0x68>)
 800253a:	3325      	adds	r3, #37	; 0x25
 800253c:	33ff      	adds	r3, #255	; 0xff
 800253e:	60c3      	str	r3, [r0, #12]
 8002540:	611a      	str	r2, [r3, #16]
 8002542:	4a12      	ldr	r2, [pc, #72]	; (800258c <chThdCreateFromHeap.constprop.57+0x6c>)
 8002544:	615e      	str	r6, [r3, #20]
 8002546:	621a      	str	r2, [r3, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002548:	2302      	movs	r3, #2
 800254a:	7703      	strb	r3, [r0, #28]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800254c:	2300      	movs	r3, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800254e:	2201      	movs	r2, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002550:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002552:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002554:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 8002556:	4b0e      	ldr	r3, [pc, #56]	; (8002590 <chThdCreateFromHeap.constprop.57+0x70>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002558:	6085      	str	r5, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800255a:	6959      	ldr	r1, [r3, #20]
 800255c:	6103      	str	r3, [r0, #16]
 800255e:	6141      	str	r1, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002560:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002562:	7782      	strb	r2, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002564:	6108      	str	r0, [r1, #16]
 8002566:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002568:	1c03      	adds	r3, r0, #0
 800256a:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800256c:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800256e:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002570:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8002572:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8002574:	7742      	strb	r2, [r0, #29]
  chSchWakeupS(tp, MSG_OK);
 8002576:	2100      	movs	r1, #0
 8002578:	f7fe f9b2 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800257c:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800257e:	1c20      	adds	r0, r4, #0
 8002580:	bd70      	pop	{r4, r5, r6, pc}
 8002582:	46c0      	nop			; (mov r8, r8)
 8002584:	20000e70 	.word	0x20000e70
 8002588:	08004741 	.word	0x08004741
 800258c:	080001a1 	.word	0x080001a1
 8002590:	20000f20 	.word	0x20000f20
 8002594:	46c0      	nop			; (mov r8, r8)
 8002596:	46c0      	nop			; (mov r8, r8)
 8002598:	46c0      	nop			; (mov r8, r8)
 800259a:	46c0      	nop			; (mov r8, r8)
 800259c:	46c0      	nop			; (mov r8, r8)
 800259e:	46c0      	nop			; (mov r8, r8)

080025a0 <chThdCreateFromMemoryPool.constprop.56>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80025a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80025a2:	4d18      	ldr	r5, [pc, #96]	; (8002604 <chThdCreateFromMemoryPool.constprop.56+0x64>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80025a4:	1c06      	adds	r6, r0, #0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80025a6:	1c28      	adds	r0, r5, #0
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 80025a8:	1c0f      	adds	r7, r1, #0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80025aa:	f7fe f921 	bl	80007f0 <chPoolAlloc>
 80025ae:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 80025b0:	d025      	beq.n	80025fe <chThdCreateFromMemoryPool.constprop.56+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025b2:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80025b4:	686b      	ldr	r3, [r5, #4]
 80025b6:	4a14      	ldr	r2, [pc, #80]	; (8002608 <chThdCreateFromMemoryPool.constprop.56+0x68>)
 80025b8:	3b24      	subs	r3, #36	; 0x24
 80025ba:	18c3      	adds	r3, r0, r3
 80025bc:	60c3      	str	r3, [r0, #12]
 80025be:	611a      	str	r2, [r3, #16]
 80025c0:	4a12      	ldr	r2, [pc, #72]	; (800260c <chThdCreateFromMemoryPool.constprop.56+0x6c>)
 80025c2:	615f      	str	r7, [r3, #20]
 80025c4:	621a      	str	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80025c6:	2300      	movs	r3, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80025c8:	2101      	movs	r1, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80025ca:	2202      	movs	r2, #2
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80025cc:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80025ce:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80025d0:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 80025d2:	4b0f      	ldr	r3, [pc, #60]	; (8002610 <chThdCreateFromMemoryPool.constprop.56+0x70>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80025d4:	7781      	strb	r1, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80025d6:	6959      	ldr	r1, [r3, #20]
 80025d8:	6103      	str	r3, [r0, #16]
 80025da:	6141      	str	r1, [r0, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80025dc:	6086      	str	r6, [r0, #8]
  tp->p_state = CH_STATE_WTSTART;
 80025de:	7702      	strb	r2, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80025e0:	63c6      	str	r6, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80025e2:	6108      	str	r0, [r1, #16]
 80025e4:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80025e6:	1c03      	adds	r3, r0, #0
 80025e8:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80025ea:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80025ec:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80025ee:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 80025f0:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 80025f2:	7742      	strb	r2, [r0, #29]
  tp->p_mpool = mp;
 80025f4:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80025f6:	2100      	movs	r1, #0
 80025f8:	f7fe f972 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80025fc:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 80025fe:	1c20      	adds	r0, r4, #0
 8002600:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002602:	46c0      	nop			; (mov r8, r8)
 8002604:	20000f14 	.word	0x20000f14
 8002608:	08004741 	.word	0x08004741
 800260c:	080001a1 	.word	0x080001a1
 8002610:	20000f20 	.word	0x20000f20
 8002614:	46c0      	nop			; (mov r8, r8)
 8002616:	46c0      	nop			; (mov r8, r8)
 8002618:	46c0      	nop			; (mov r8, r8)
 800261a:	46c0      	nop			; (mov r8, r8)
 800261c:	46c0      	nop			; (mov r8, r8)
 800261e:	46c0      	nop			; (mov r8, r8)

08002620 <chSemSignalWait.constprop.52>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8002620:	b538      	push	{r3, r4, r5, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002622:	b672      	cpsid	i
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 8002624:	4c12      	ldr	r4, [pc, #72]	; (8002670 <chSemSignalWait.constprop.52+0x50>)
 8002626:	68a3      	ldr	r3, [r4, #8]
 8002628:	3301      	adds	r3, #1
 800262a:	60a3      	str	r3, [r4, #8]
 800262c:	2b00      	cmp	r3, #0
 800262e:	dd15      	ble.n	800265c <chSemSignalWait.constprop.52+0x3c>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8002630:	3b01      	subs	r3, #1
 8002632:	60a3      	str	r3, [r4, #8]
 8002634:	2b00      	cmp	r3, #0
 8002636:	db04      	blt.n	8002642 <chSemSignalWait.constprop.52+0x22>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8002638:	f7fe f92a 	bl	8000890 <chSchRescheduleS>
    msg = MSG_OK;
 800263c:	2000      	movs	r0, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800263e:	b662      	cpsie	i
  }
  chSysUnlock();

  return msg;
}
 8002640:	bd38      	pop	{r3, r4, r5, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8002642:	4b0c      	ldr	r3, [pc, #48]	; (8002674 <chSemSignalWait.constprop.52+0x54>)
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8002644:	2005      	movs	r0, #5
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8002646:	699d      	ldr	r5, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8002648:	6863      	ldr	r3, [r4, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800264a:	602c      	str	r4, [r5, #0]
  tp->p_prev = tqp->p_prev;
 800264c:	606b      	str	r3, [r5, #4]
  tp->p_prev->p_next = tp;
 800264e:	601d      	str	r5, [r3, #0]
  tqp->p_prev = tp;
 8002650:	6065      	str	r5, [r4, #4]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 8002652:	622c      	str	r4, [r5, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8002654:	f7fe f9e4 	bl	8000a20 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8002658:	6a28      	ldr	r0, [r5, #32]
 800265a:	e7f0      	b.n	800263e <chSemSignalWait.constprop.52+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800265c:	6820      	ldr	r0, [r4, #0]

  tqp->p_next = tp->p_next;
 800265e:	6803      	ldr	r3, [r0, #0]
 8002660:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002662:	605c      	str	r4, [r3, #4]
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8002664:	f7fe fa2c 	bl	8000ac0 <chSchReadyI>
 8002668:	2300      	movs	r3, #0
 800266a:	6203      	str	r3, [r0, #32]
 800266c:	68a3      	ldr	r3, [r4, #8]
 800266e:	e7df      	b.n	8002630 <chSemSignalWait.constprop.52+0x10>
 8002670:	20000600 	.word	0x20000600
 8002674:	20000f20 	.word	0x20000f20
 8002678:	46c0      	nop			; (mov r8, r8)
 800267a:	46c0      	nop			; (mov r8, r8)
 800267c:	46c0      	nop			; (mov r8, r8)
 800267e:	46c0      	nop			; (mov r8, r8)

08002680 <chCondSignal.constprop.48>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002680:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002682:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002684:	4b05      	ldr	r3, [pc, #20]	; (800269c <chCondSignal.constprop.48+0x1c>)
 8002686:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 8002688:	4298      	cmp	r0, r3
 800268a:	d005      	beq.n	8002698 <chCondSignal.constprop.48+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800268c:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 800268e:	2100      	movs	r1, #0
 8002690:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002692:	6053      	str	r3, [r2, #4]
 8002694:	f7fe f924 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002698:	b662      	cpsie	i
  }
  chSysUnlock();
}
 800269a:	bd08      	pop	{r3, pc}
 800269c:	20000634 	.word	0x20000634

080026a0 <chCondSignalI.constprop.47>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80026a0:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80026a2:	4b06      	ldr	r3, [pc, #24]	; (80026bc <chCondSignalI.constprop.47+0x1c>)
 80026a4:	6818      	ldr	r0, [r3, #0]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80026a6:	4298      	cmp	r0, r3
 80026a8:	d006      	beq.n	80026b8 <chCondSignalI.constprop.47+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80026aa:	6802      	ldr	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80026ac:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80026ae:	601a      	str	r2, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 80026b0:	2300      	movs	r3, #0
 80026b2:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 80026b4:	f7fe fa04 	bl	8000ac0 <chSchReadyI>
  }
}
 80026b8:	bd08      	pop	{r3, pc}
 80026ba:	46c0      	nop			; (mov r8, r8)
 80026bc:	20000634 	.word	0x20000634

080026c0 <chEvtGetAndClearEvents.constprop.39>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80026c0:	b672      	cpsid	i
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
  currp->p_epending &= ~events;
 80026c2:	2200      	movs	r2, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 80026c4:	4b02      	ldr	r3, [pc, #8]	; (80026d0 <chEvtGetAndClearEvents.constprop.39+0x10>)
 80026c6:	699b      	ldr	r3, [r3, #24]
 80026c8:	6b58      	ldr	r0, [r3, #52]	; 0x34
  currp->p_epending &= ~events;
 80026ca:	635a      	str	r2, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80026cc:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80026ce:	4770      	bx	lr
 80026d0:	20000f20 	.word	0x20000f20
 80026d4:	46c0      	nop			; (mov r8, r8)
 80026d6:	46c0      	nop			; (mov r8, r8)
 80026d8:	46c0      	nop			; (mov r8, r8)
 80026da:	46c0      	nop			; (mov r8, r8)
 80026dc:	46c0      	nop			; (mov r8, r8)
 80026de:	46c0      	nop			; (mov r8, r8)

080026e0 <chEvtWaitOne.constprop.35>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80026e0:	4b09      	ldr	r3, [pc, #36]	; (8002708 <chEvtWaitOne.constprop.35+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80026e2:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 80026e4:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80026e6:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80026e8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80026ea:	2b00      	cmp	r3, #0
 80026ec:	d105      	bne.n	80026fa <chEvtWaitOne.constprop.35+0x1a>
    ctp->p_u.ewmask = events;
 80026ee:	3b01      	subs	r3, #1
 80026f0:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80026f2:	200a      	movs	r0, #10
 80026f4:	f7fe f994 	bl	8000a20 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80026f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80026fa:	4258      	negs	r0, r3
 80026fc:	4018      	ands	r0, r3
  ctp->p_epending &= ~m;
 80026fe:	4383      	bics	r3, r0
 8002700:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002702:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8002704:	bd10      	pop	{r4, pc}
 8002706:	46c0      	nop			; (mov r8, r8)
 8002708:	20000f20 	.word	0x20000f20
 800270c:	46c0      	nop			; (mov r8, r8)
 800270e:	46c0      	nop			; (mov r8, r8)

08002710 <chEvtWaitAny.constprop.34>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8002710:	4b09      	ldr	r3, [pc, #36]	; (8002738 <chEvtWaitAny.constprop.34+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002712:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8002714:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002716:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8002718:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800271a:	2800      	cmp	r0, #0
 800271c:	d106      	bne.n	800272c <chEvtWaitAny.constprop.34+0x1c>
    ctp->p_u.ewmask = events;
 800271e:	2301      	movs	r3, #1
 8002720:	425b      	negs	r3, r3
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002722:	300a      	adds	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
    ctp->p_u.ewmask = events;
 8002724:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002726:	f7fe f97b 	bl	8000a20 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800272a:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 800272c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800272e:	4383      	bics	r3, r0
 8002730:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002732:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8002734:	bd10      	pop	{r4, pc}
 8002736:	46c0      	nop			; (mov r8, r8)
 8002738:	20000f20 	.word	0x20000f20
 800273c:	00000000 	.word	0x00000000

08002740 <chMBPost.constprop.20>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002740:	b570      	push	{r4, r5, r6, lr}
 8002742:	1c06      	adds	r6, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002744:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002746:	4c0d      	ldr	r4, [pc, #52]	; (800277c <chMBPost.constprop.20+0x3c>)
 8002748:	1c20      	adds	r0, r4, #0
 800274a:	301c      	adds	r0, #28
 800274c:	f7fe fdd8 	bl	8001300 <chSemWaitTimeoutS>
 8002750:	1e05      	subs	r5, r0, #0
  if (rdymsg == MSG_OK) {
 8002752:	d10c      	bne.n	800276e <chMBPost.constprop.20+0x2e>
    *mbp->mb_wrptr++ = msg;
 8002754:	68a2      	ldr	r2, [r4, #8]
 8002756:	1d13      	adds	r3, r2, #4
 8002758:	60a3      	str	r3, [r4, #8]
 800275a:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800275c:	6862      	ldr	r2, [r4, #4]
 800275e:	4293      	cmp	r3, r2
 8002760:	d208      	bcs.n	8002774 <chMBPost.constprop.20+0x34>
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002762:	1c20      	adds	r0, r4, #0
 8002764:	3010      	adds	r0, #16
 8002766:	f7fe fccb 	bl	8001100 <chSemSignalI>
    chSchRescheduleS();
 800276a:	f7fe f891 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800276e:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002770:	1c28      	adds	r0, r5, #0
 8002772:	bd70      	pop	{r4, r5, r6, pc}

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8002774:	6823      	ldr	r3, [r4, #0]
 8002776:	60a3      	str	r3, [r4, #8]
 8002778:	e7f3      	b.n	8002762 <chMBPost.constprop.20+0x22>
 800277a:	46c0      	nop			; (mov r8, r8)
 800277c:	2000060c 	.word	0x2000060c

08002780 <chMBPostI.constprop.19>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002780:	b508      	push	{r3, lr}
 8002782:	4b0c      	ldr	r3, [pc, #48]	; (80027b4 <chMBPostI.constprop.19+0x34>)
 8002784:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002786:	2a00      	cmp	r2, #0
 8002788:	dd11      	ble.n	80027ae <chMBPostI.constprop.19+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800278a:	6899      	ldr	r1, [r3, #8]
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 800278c:	3a01      	subs	r2, #1
 800278e:	625a      	str	r2, [r3, #36]	; 0x24
 8002790:	1d0a      	adds	r2, r1, #4
 8002792:	609a      	str	r2, [r3, #8]
 8002794:	6008      	str	r0, [r1, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002796:	6859      	ldr	r1, [r3, #4]
 8002798:	428a      	cmp	r2, r1
 800279a:	d205      	bcs.n	80027a8 <chMBPostI.constprop.19+0x28>
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800279c:	3310      	adds	r3, #16
 800279e:	1c18      	adds	r0, r3, #0
 80027a0:	f7fe fcae 	bl	8001100 <chSemSignalI>

  return MSG_OK;
 80027a4:	2000      	movs	r0, #0
}
 80027a6:	bd08      	pop	{r3, pc}
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 80027a8:	681a      	ldr	r2, [r3, #0]
 80027aa:	609a      	str	r2, [r3, #8]
 80027ac:	e7f6      	b.n	800279c <chMBPostI.constprop.19+0x1c>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80027ae:	2001      	movs	r0, #1
 80027b0:	4240      	negs	r0, r0
 80027b2:	e7f8      	b.n	80027a6 <chMBPostI.constprop.19+0x26>
 80027b4:	2000060c 	.word	0x2000060c
 80027b8:	46c0      	nop			; (mov r8, r8)
 80027ba:	46c0      	nop			; (mov r8, r8)
 80027bc:	46c0      	nop			; (mov r8, r8)
 80027be:	46c0      	nop			; (mov r8, r8)

080027c0 <chMBPostAhead.constprop.18>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80027c0:	b570      	push	{r4, r5, r6, lr}
 80027c2:	1c06      	adds	r6, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80027c4:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80027c6:	4c0d      	ldr	r4, [pc, #52]	; (80027fc <chMBPostAhead.constprop.18+0x3c>)
 80027c8:	1c20      	adds	r0, r4, #0
 80027ca:	301c      	adds	r0, #28
 80027cc:	f7fe fd98 	bl	8001300 <chSemWaitTimeoutS>
 80027d0:	1e05      	subs	r5, r0, #0
  if (rdymsg == MSG_OK) {
 80027d2:	d10c      	bne.n	80027ee <chMBPostAhead.constprop.18+0x2e>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80027d4:	68e3      	ldr	r3, [r4, #12]
 80027d6:	6822      	ldr	r2, [r4, #0]
 80027d8:	3b04      	subs	r3, #4
 80027da:	60e3      	str	r3, [r4, #12]
 80027dc:	4293      	cmp	r3, r2
 80027de:	d309      	bcc.n	80027f4 <chMBPostAhead.constprop.18+0x34>
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
    chSemSignalI(&mbp->mb_fullsem);
 80027e0:	1c20      	adds	r0, r4, #0
  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
 80027e2:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80027e4:	3010      	adds	r0, #16
 80027e6:	f7fe fc8b 	bl	8001100 <chSemSignalI>
    chSchRescheduleS();
 80027ea:	f7fe f851 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80027ee:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80027f0:	1c28      	adds	r0, r5, #0
 80027f2:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
 80027f4:	6863      	ldr	r3, [r4, #4]
 80027f6:	3b04      	subs	r3, #4
 80027f8:	60e3      	str	r3, [r4, #12]
 80027fa:	e7f1      	b.n	80027e0 <chMBPostAhead.constprop.18+0x20>
 80027fc:	2000060c 	.word	0x2000060c

08002800 <chMBPostAheadI.constprop.17>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002800:	b508      	push	{r3, lr}
 8002802:	4b0d      	ldr	r3, [pc, #52]	; (8002838 <chMBPostAheadI.constprop.17+0x38>)
 8002804:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002806:	2a00      	cmp	r2, #0
 8002808:	dd12      	ble.n	8002830 <chMBPostAheadI.constprop.17+0x30>
 800280a:	3a01      	subs	r2, #1
 800280c:	625a      	str	r2, [r3, #36]	; 0x24
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 800280e:	68da      	ldr	r2, [r3, #12]
 8002810:	6819      	ldr	r1, [r3, #0]
 8002812:	3a04      	subs	r2, #4
 8002814:	60da      	str	r2, [r3, #12]
 8002816:	428a      	cmp	r2, r1
 8002818:	d306      	bcc.n	8002828 <chMBPostAheadI.constprop.17+0x28>
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
  chSemSignalI(&mbp->mb_fullsem);
 800281a:	3310      	adds	r3, #16
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
 800281c:	6010      	str	r0, [r2, #0]
  chSemSignalI(&mbp->mb_fullsem);
 800281e:	1c18      	adds	r0, r3, #0
 8002820:	f7fe fc6e 	bl	8001100 <chSemSignalI>

  return MSG_OK;
 8002824:	2000      	movs	r0, #0
}
 8002826:	bd08      	pop	{r3, pc}
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002828:	685a      	ldr	r2, [r3, #4]
 800282a:	3a04      	subs	r2, #4
 800282c:	60da      	str	r2, [r3, #12]
 800282e:	e7f4      	b.n	800281a <chMBPostAheadI.constprop.17+0x1a>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8002830:	2001      	movs	r0, #1
 8002832:	4240      	negs	r0, r0
 8002834:	e7f7      	b.n	8002826 <chMBPostAheadI.constprop.17+0x26>
 8002836:	46c0      	nop			; (mov r8, r8)
 8002838:	2000060c 	.word	0x2000060c
 800283c:	46c0      	nop			; (mov r8, r8)
 800283e:	46c0      	nop			; (mov r8, r8)

08002840 <chMBFetch.constprop.16>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002840:	b570      	push	{r4, r5, r6, lr}
 8002842:	1c06      	adds	r6, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002844:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002846:	4c0d      	ldr	r4, [pc, #52]	; (800287c <chMBFetch.constprop.16+0x3c>)
 8002848:	1c20      	adds	r0, r4, #0
 800284a:	3010      	adds	r0, #16
 800284c:	f7fe fd58 	bl	8001300 <chSemWaitTimeoutS>
 8002850:	1c05      	adds	r5, r0, #0
 8002852:	1c20      	adds	r0, r4, #0
  if (rdymsg == MSG_OK) {
 8002854:	2d00      	cmp	r5, #0
 8002856:	d10e      	bne.n	8002876 <chMBFetch.constprop.16+0x36>
    *msgp = *mbp->mb_rdptr++;
 8002858:	68e2      	ldr	r2, [r4, #12]
 800285a:	1d13      	adds	r3, r2, #4
 800285c:	6812      	ldr	r2, [r2, #0]
 800285e:	60e3      	str	r3, [r4, #12]
 8002860:	6032      	str	r2, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002862:	6862      	ldr	r2, [r4, #4]
 8002864:	4293      	cmp	r3, r2
 8002866:	d301      	bcc.n	800286c <chMBFetch.constprop.16+0x2c>
      mbp->mb_rdptr = mbp->mb_buffer;
 8002868:	6823      	ldr	r3, [r4, #0]
 800286a:	60e3      	str	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 800286c:	301c      	adds	r0, #28
 800286e:	f7fe fc47 	bl	8001100 <chSemSignalI>
    chSchRescheduleS();
 8002872:	f7fe f80d 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002876:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002878:	1c28      	adds	r0, r5, #0
 800287a:	bd70      	pop	{r4, r5, r6, pc}
 800287c:	2000060c 	.word	0x2000060c

08002880 <chMBFetchI.constprop.15>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002880:	b508      	push	{r3, lr}
 8002882:	4b0c      	ldr	r3, [pc, #48]	; (80028b4 <chMBFetchI.constprop.15+0x34>)
 8002884:	699a      	ldr	r2, [r3, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8002886:	2a00      	cmp	r2, #0
 8002888:	dd11      	ble.n	80028ae <chMBFetchI.constprop.15+0x2e>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 800288a:	68d9      	ldr	r1, [r3, #12]
 800288c:	3a01      	subs	r2, #1
 800288e:	619a      	str	r2, [r3, #24]
 8002890:	1d0a      	adds	r2, r1, #4
 8002892:	6809      	ldr	r1, [r1, #0]
 8002894:	60da      	str	r2, [r3, #12]
 8002896:	6001      	str	r1, [r0, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8002898:	6859      	ldr	r1, [r3, #4]
 800289a:	428a      	cmp	r2, r1
 800289c:	d301      	bcc.n	80028a2 <chMBFetchI.constprop.15+0x22>
    mbp->mb_rdptr = mbp->mb_buffer;
 800289e:	681a      	ldr	r2, [r3, #0]
 80028a0:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 80028a2:	331c      	adds	r3, #28
 80028a4:	1c18      	adds	r0, r3, #0
 80028a6:	f7fe fc2b 	bl	8001100 <chSemSignalI>

  return MSG_OK;
 80028aa:	2000      	movs	r0, #0
 80028ac:	e001      	b.n	80028b2 <chMBFetchI.constprop.15+0x32>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80028ae:	2001      	movs	r0, #1
 80028b0:	4240      	negs	r0, r0
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);

  return MSG_OK;
}
 80028b2:	bd08      	pop	{r3, pc}
 80028b4:	2000060c 	.word	0x2000060c
	...

080028c0 <test_start_timer.constprop.2>:
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 80028c0:	2200      	movs	r2, #0
 80028c2:	4b0a      	ldr	r3, [pc, #40]	; (80028ec <test_start_timer.constprop.2+0x2c>)
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 80028c4:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 80028c6:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80028c8:	b672      	cpsid	i
 80028ca:	4c09      	ldr	r4, [pc, #36]	; (80028f0 <test_start_timer.constprop.2+0x30>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 80028cc:	68e3      	ldr	r3, [r4, #12]
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d002      	beq.n	80028d8 <test_start_timer.constprop.2+0x18>
    chVTDoResetI(vtp);
 80028d2:	1c20      	adds	r0, r4, #0
 80028d4:	f7fe fc64 	bl	80011a0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 80028d8:	21fa      	movs	r1, #250	; 0xfa
 80028da:	1c20      	adds	r0, r4, #0
 80028dc:	0089      	lsls	r1, r1, #2
 80028de:	4a05      	ldr	r2, [pc, #20]	; (80028f4 <test_start_timer.constprop.2+0x34>)
 80028e0:	2300      	movs	r3, #0
 80028e2:	f7fe fc9d 	bl	8001220 <chVTDoSetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80028e6:	b662      	cpsie	i
  chVTSet(&vt, duration, tmr, NULL);
}
 80028e8:	bd10      	pop	{r4, pc}
 80028ea:	46c0      	nop			; (mov r8, r8)
 80028ec:	20000e96 	.word	0x20000e96
 80028f0:	200010a8 	.word	0x200010a8
 80028f4:	080002f1 	.word	0x080002f1
 80028f8:	46c0      	nop			; (mov r8, r8)
 80028fa:	46c0      	nop			; (mov r8, r8)
 80028fc:	46c0      	nop			; (mov r8, r8)
 80028fe:	46c0      	nop			; (mov r8, r8)

08002900 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8002900:	4ba2      	ldr	r3, [pc, #648]	; (8002b8c <main+0x28c>)
 8002902:	2101      	movs	r1, #1
}

/*
 * Application entry point.
 */
int main(void) {
 8002904:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002906:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002908:	4644      	mov	r4, r8
 800290a:	2200      	movs	r2, #0
 800290c:	465f      	mov	r7, fp
 800290e:	4656      	mov	r6, sl
 8002910:	464d      	mov	r5, r9
 8002912:	4249      	negs	r1, r1
 8002914:	b4f0      	push	{r4, r5, r6, r7}
 8002916:	6299      	str	r1, [r3, #40]	; 0x28
 8002918:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 800291a:	6918      	ldr	r0, [r3, #16]
 800291c:	6119      	str	r1, [r3, #16]
 800291e:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8002920:	68d9      	ldr	r1, [r3, #12]
 8002922:	489b      	ldr	r0, [pc, #620]	; (8002b90 <main+0x290>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002924:	2480      	movs	r4, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8002926:	4301      	orrs	r1, r0

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002928:	2080      	movs	r0, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 800292a:	60d9      	str	r1, [r3, #12]
 800292c:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800292e:	69d9      	ldr	r1, [r3, #28]
 8002930:	0540      	lsls	r0, r0, #21
 8002932:	4301      	orrs	r1, r0
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002934:	4897      	ldr	r0, [pc, #604]	; (8002b94 <main+0x294>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002936:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002938:	6801      	ldr	r1, [r0, #0]
 800293a:	0064      	lsls	r4, r4, #1
 800293c:	4321      	orrs	r1, r4
 800293e:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8002940:	21c0      	movs	r1, #192	; 0xc0
 8002942:	6a18      	ldr	r0, [r3, #32]
 8002944:	0089      	lsls	r1, r1, #2
 8002946:	4001      	ands	r1, r0
 8002948:	2080      	movs	r0, #128	; 0x80
 800294a:	b085      	sub	sp, #20
 800294c:	0080      	lsls	r0, r0, #2
 800294e:	4281      	cmp	r1, r0
 8002950:	d003      	beq.n	800295a <main+0x5a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002952:	2180      	movs	r1, #128	; 0x80
 8002954:	0249      	lsls	r1, r1, #9
 8002956:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8002958:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800295a:	2080      	movs	r0, #128	; 0x80
 800295c:	4b8b      	ldr	r3, [pc, #556]	; (8002b8c <main+0x28c>)
 800295e:	0200      	lsls	r0, r0, #8
 8002960:	6a1a      	ldr	r2, [r3, #32]
 8002962:	4202      	tst	r2, r0
 8002964:	d107      	bne.n	8002976 <main+0x76>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8002966:	2280      	movs	r2, #128	; 0x80
 8002968:	6a19      	ldr	r1, [r3, #32]
 800296a:	0092      	lsls	r2, r2, #2
 800296c:	4311      	orrs	r1, r2
 800296e:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8002970:	6a1a      	ldr	r2, [r3, #32]
 8002972:	4302      	orrs	r2, r0
 8002974:	621a      	str	r2, [r3, #32]
   */
#if defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002976:	22bc      	movs	r2, #188	; 0xbc
 8002978:	4c84      	ldr	r4, [pc, #528]	; (8002b8c <main+0x28c>)
 800297a:	03d2      	lsls	r2, r2, #15
 800297c:	6963      	ldr	r3, [r4, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800297e:	4986      	ldr	r1, [pc, #536]	; (8002b98 <main+0x298>)
   */
#if defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002980:	4313      	orrs	r3, r2
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002982:	2290      	movs	r2, #144	; 0x90
   */
#if defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002984:	6163      	str	r3, [r4, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002986:	2300      	movs	r3, #0
 8002988:	05d2      	lsls	r2, r2, #23
 800298a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800298c:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800298e:	4983      	ldr	r1, [pc, #524]	; (8002b9c <main+0x29c>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002990:	2701      	movs	r7, #1
  gpiop->PUPDR   = config->pupdr;
 8002992:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8002994:	4982      	ldr	r1, [pc, #520]	; (8002ba0 <main+0x2a0>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8002996:	2680      	movs	r6, #128	; 0x80
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8002998:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800299a:	2188      	movs	r1, #136	; 0x88
 800299c:	0149      	lsls	r1, r1, #5
 800299e:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80029a0:	21aa      	movs	r1, #170	; 0xaa
 80029a2:	0309      	lsls	r1, r1, #12
 80029a4:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80029a6:	497f      	ldr	r1, [pc, #508]	; (8002ba4 <main+0x2a4>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80029a8:	487f      	ldr	r0, [pc, #508]	; (8002ba8 <main+0x2a8>)
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80029aa:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80029ac:	4a7f      	ldr	r2, [pc, #508]	; (8002bac <main+0x2ac>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80029ae:	4980      	ldr	r1, [pc, #512]	; (8002bb0 <main+0x2b0>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80029b0:	427f      	negs	r7, r7
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80029b2:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80029b4:	4d7f      	ldr	r5, [pc, #508]	; (8002bb4 <main+0x2b4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80029b6:	6097      	str	r7, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80029b8:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80029ba:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80029bc:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80029be:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80029c0:	6016      	str	r6, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80029c2:	4a7d      	ldr	r2, [pc, #500]	; (8002bb8 <main+0x2b8>)
 80029c4:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80029c6:	6097      	str	r7, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80029c8:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 80029ca:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80029cc:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80029ce:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80029d0:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80029d2:	4a7a      	ldr	r2, [pc, #488]	; (8002bbc <main+0x2bc>)
 80029d4:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80029d6:	6097      	str	r7, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80029d8:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80029da:	6150      	str	r0, [r2, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80029dc:	4978      	ldr	r1, [pc, #480]	; (8002bc0 <main+0x2c0>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80029de:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80029e0:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80029e2:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80029e4:	4a77      	ldr	r2, [pc, #476]	; (8002bc4 <main+0x2c4>)
 80029e6:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80029e8:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80029ea:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 80029ec:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80029ee:	6213      	str	r3, [r2, #32]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80029f0:	4975      	ldr	r1, [pc, #468]	; (8002bc8 <main+0x2c8>)
  gpiop->AFRH    = config->afrh;
 80029f2:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80029f4:	6013      	str	r3, [r2, #0]
 80029f6:	4a75      	ldr	r2, [pc, #468]	; (8002bcc <main+0x2cc>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80029f8:	4d74      	ldr	r5, [pc, #464]	; (8002bcc <main+0x2cc>)
 80029fa:	c202      	stmia	r2!, {r1}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80029fc:	4973      	ldr	r1, [pc, #460]	; (8002bcc <main+0x2cc>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80029fe:	616b      	str	r3, [r5, #20]
 8002a00:	604a      	str	r2, [r1, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8002a02:	2201      	movs	r2, #1
 8002a04:	4690      	mov	r8, r2
 8002a06:	1c0a      	adds	r2, r1, #0
 8002a08:	4641      	mov	r1, r8
 8002a0a:	7211      	strb	r1, [r2, #8]
 8002a0c:	320c      	adds	r2, #12
 8002a0e:	60ea      	str	r2, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002a10:	612a      	str	r2, [r5, #16]
 8002a12:	1c2a      	adds	r2, r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8002a14:	1c29      	adds	r1, r5, #0
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8002a16:	3254      	adds	r2, #84	; 0x54
 8002a18:	61aa      	str	r2, [r5, #24]
  iqp->q_rdptr   = bp;
 8002a1a:	626a      	str	r2, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8002a1c:	622a      	str	r2, [r5, #32]
  iqp->q_top     = bp + size;
 8002a1e:	3210      	adds	r2, #16
 8002a20:	61ea      	str	r2, [r5, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8002a22:	63ca      	str	r2, [r1, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8002a24:	648a      	str	r2, [r1, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8002a26:	644a      	str	r2, [r1, #68]	; 0x44
  oqp->q_top     = bp + size;
 8002a28:	3210      	adds	r2, #16
 8002a2a:	640a      	str	r2, [r1, #64]	; 0x40
  oqp->q_notify  = onfy;
 8002a2c:	4a68      	ldr	r2, [pc, #416]	; (8002bd0 <main+0x2d0>)
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8002a2e:	62ab      	str	r3, [r5, #40]	; 0x28
  iqp->q_link    = link;
 8002a30:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8002a32:	64ca      	str	r2, [r1, #76]	; 0x4c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a34:	3530      	adds	r5, #48	; 0x30
  SD1.clock = STM32_USART1CLK;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8002a36:	4a67      	ldr	r2, [pc, #412]	; (8002bd4 <main+0x2d4>)
 8002a38:	630d      	str	r5, [r1, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8002a3a:	634d      	str	r5, [r1, #52]	; 0x34
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8002a3c:	2510      	movs	r5, #16
 8002a3e:	674a      	str	r2, [r1, #116]	; 0x74
  SD2.clock = STM32_USART2CLK;
 8002a40:	4a65      	ldr	r2, [pc, #404]	; (8002bd8 <main+0x2d8>)
 8002a42:	638d      	str	r5, [r1, #56]	; 0x38
 8002a44:	678a      	str	r2, [r1, #120]	; 0x78

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002a46:	2202      	movs	r2, #2
 8002a48:	69e5      	ldr	r5, [r4, #28]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8002a4a:	6509      	str	r1, [r1, #80]	; 0x50
 8002a4c:	4315      	orrs	r5, r2
 8002a4e:	61e5      	str	r5, [r4, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002a50:	4d62      	ldr	r5, [pc, #392]	; (8002bdc <main+0x2dc>)
 8002a52:	68a9      	ldr	r1, [r5, #8]
 8002a54:	430a      	orrs	r2, r1
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002a56:	4641      	mov	r1, r8

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002a58:	60aa      	str	r2, [r5, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002a5a:	4a61      	ldr	r2, [pc, #388]	; (8002be0 <main+0x2e0>)
 8002a5c:	4d61      	ldr	r5, [pc, #388]	; (8002be4 <main+0x2e4>)
 8002a5e:	6295      	str	r5, [r2, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002a60:	62d0      	str	r0, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002a62:	6193      	str	r3, [r2, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002a64:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8002a66:	60d3      	str	r3, [r2, #12]
  STM32_ST_TIM->CR2    = 0;
 8002a68:	6053      	str	r3, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002a6a:	6151      	str	r1, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002a6c:	6011      	str	r1, [r2, #0]
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8002a6e:	22d0      	movs	r2, #208	; 0xd0
 8002a70:	4d5d      	ldr	r5, [pc, #372]	; (8002be8 <main+0x2e8>)
 8002a72:	0092      	lsls	r2, r2, #2
 8002a74:	50ae      	str	r6, [r5, r2]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002a76:	2280      	movs	r2, #128	; 0x80
 8002a78:	3601      	adds	r6, #1
 8002a7a:	0252      	lsls	r2, r2, #9
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
 8002a7c:	485b      	ldr	r0, [pc, #364]	; (8002bec <main+0x2ec>)
 8002a7e:	36ff      	adds	r6, #255	; 0xff
 8002a80:	51aa      	str	r2, [r5, r6]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8002a82:	602a      	str	r2, [r5, #0]
 8002a84:	6a02      	ldr	r2, [r0, #32]
 8002a86:	4694      	mov	ip, r2
 8002a88:	4661      	mov	r1, ip
 8002a8a:	4a59      	ldr	r2, [pc, #356]	; (8002bf0 <main+0x2f0>)
 8002a8c:	400a      	ands	r2, r1
 8002a8e:	6202      	str	r2, [r0, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a90:	4858      	ldr	r0, [pc, #352]	; (8002bf4 <main+0x2f4>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002a92:	4959      	ldr	r1, [pc, #356]	; (8002bf8 <main+0x2f8>)
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8002a94:	1c02      	adds	r2, r0, #0
 8002a96:	321c      	adds	r2, #28
 8002a98:	61c2      	str	r2, [r0, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002a9a:	6202      	str	r2, [r0, #32]
 8002a9c:	4a57      	ldr	r2, [pc, #348]	; (8002bfc <main+0x2fc>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8002a9e:	8487      	strh	r7, [r0, #36]	; 0x24
 8002aa0:	3207      	adds	r2, #7
 8002aa2:	3708      	adds	r7, #8
 8002aa4:	43ba      	bics	r2, r7
 8002aa6:	600a      	str	r2, [r1, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002aa8:	4a55      	ldr	r2, [pc, #340]	; (8002c00 <main+0x300>)
 8002aaa:	6000      	str	r0, [r0, #0]
 8002aac:	43ba      	bics	r2, r7
 8002aae:	4f55      	ldr	r7, [pc, #340]	; (8002c04 <main+0x304>)
  tqp->p_prev = (thread_t *)tqp;
 8002ab0:	6040      	str	r0, [r0, #4]
 8002ab2:	603a      	str	r2, [r7, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002ab4:	4a54      	ldr	r2, [pc, #336]	; (8002c08 <main+0x308>)
 8002ab6:	4f55      	ldr	r7, [pc, #340]	; (8002c0c <main+0x30c>)
  default_heap.h_free.h.u.next = NULL;
 8002ab8:	6093      	str	r3, [r2, #8]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002aba:	6017      	str	r7, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002abc:	1c17      	adds	r7, r2, #0
 8002abe:	3710      	adds	r7, #16
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8002ac0:	6083      	str	r3, [r0, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8002ac2:	84c3      	strh	r3, [r0, #38]	; 0x26
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002ac4:	2100      	movs	r1, #0
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
 8002ac6:	60d3      	str	r3, [r2, #12]
 8002ac8:	6117      	str	r7, [r2, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002aca:	6157      	str	r7, [r2, #20]
 8002acc:	2749      	movs	r7, #73	; 0x49
 8002ace:	6193      	str	r3, [r2, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002ad0:	2240      	movs	r2, #64	; 0x40
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002ad2:	55c1      	strb	r1, [r0, r7]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002ad4:	4641      	mov	r1, r8
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002ad6:	6342      	str	r2, [r0, #52]	; 0x34
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002ad8:	6682      	str	r2, [r0, #104]	; 0x68
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002ada:	1c07      	adds	r7, r0, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002adc:	320a      	adds	r2, #10
 8002ade:	5481      	strb	r1, [r0, r2]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002ae0:	1c02      	adds	r2, r0, #0
 8002ae2:	3750      	adds	r7, #80	; 0x50
 8002ae4:	322c      	adds	r2, #44	; 0x2c
 8002ae6:	6507      	str	r7, [r0, #80]	; 0x50
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002ae8:	1c07      	adds	r7, r0, #0
 8002aea:	6102      	str	r2, [r0, #16]
 8002aec:	6142      	str	r2, [r0, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8002aee:	6182      	str	r2, [r0, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002af0:	2248      	movs	r2, #72	; 0x48
 8002af2:	3754      	adds	r7, #84	; 0x54
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002af4:	6643      	str	r3, [r0, #100]	; 0x64
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002af6:	6603      	str	r3, [r0, #96]	; 0x60
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002af8:	6443      	str	r3, [r0, #68]	; 0x44
  REG_INSERT(tp);
 8002afa:	63c0      	str	r0, [r0, #60]	; 0x3c
 8002afc:	6400      	str	r0, [r0, #64]	; 0x40
 8002afe:	6547      	str	r7, [r0, #84]	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 8002b00:	6587      	str	r7, [r0, #88]	; 0x58
 8002b02:	5481      	strb	r1, [r0, r2]
 8002b04:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8002b06:	4942      	ldr	r1, [pc, #264]	; (8002c10 <main+0x310>)
 8002b08:	6982      	ldr	r2, [r0, #24]

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  (void) chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa),
 8002b0a:	3070      	adds	r0, #112	; 0x70
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8002b0c:	6191      	str	r1, [r2, #24]

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  (void) chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa),
 8002b0e:	9300      	str	r3, [sp, #0]
 8002b10:	21d8      	movs	r1, #216	; 0xd8
 8002b12:	2201      	movs	r2, #1
 8002b14:	4b3f      	ldr	r3, [pc, #252]	; (8002c14 <main+0x314>)
 8002b16:	f7fd ff53 	bl	80009c0 <chThdCreateStatic>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b1a:	b672      	cpsid	i
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8002b1c:	4b2b      	ldr	r3, [pc, #172]	; (8002bcc <main+0x2cc>)
 8002b1e:	7a1b      	ldrb	r3, [r3, #8]
 8002b20:	2b01      	cmp	r3, #1
 8002b22:	d10c      	bne.n	8002b3e <main+0x23e>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 8002b24:	2280      	movs	r2, #128	; 0x80
 8002b26:	69e3      	ldr	r3, [r4, #28]
 8002b28:	0292      	lsls	r2, r2, #10
 8002b2a:	4313      	orrs	r3, r2
 8002b2c:	61e3      	str	r3, [r4, #28]
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8002b2e:	23dc      	movs	r3, #220	; 0xdc
 8002b30:	22c0      	movs	r2, #192	; 0xc0
 8002b32:	009b      	lsls	r3, r3, #2
 8002b34:	50ea      	str	r2, [r5, r3]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002b36:	2380      	movs	r3, #128	; 0x80
 8002b38:	055b      	lsls	r3, r3, #21
 8002b3a:	51ab      	str	r3, [r5, r6]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8002b3c:	602b      	str	r3, [r5, #0]
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8002b3e:	2196      	movs	r1, #150	; 0x96
 8002b40:	4b22      	ldr	r3, [pc, #136]	; (8002bcc <main+0x2cc>)
 8002b42:	0209      	lsls	r1, r1, #8
 8002b44:	6f5c      	ldr	r4, [r3, #116]	; 0x74
 8002b46:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8002b48:	1c18      	adds	r0, r3, #0
 8002b4a:	9302      	str	r3, [sp, #8]
 8002b4c:	f7fd fb38 	bl	80001c0 <__aeabi_uidiv>

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002b50:	4b31      	ldr	r3, [pc, #196]	; (8002c18 <main+0x318>)
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8002b52:	b280      	uxth	r0, r0
 8002b54:	81a0      	strh	r0, [r4, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002b56:	6063      	str	r3, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002b58:	2301      	movs	r3, #1
 8002b5a:	60a3      	str	r3, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002b5c:	232e      	movs	r3, #46	; 0x2e
 8002b5e:	33ff      	adds	r3, #255	; 0xff
 8002b60:	6023      	str	r3, [r4, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFF;
 8002b62:	3b2f      	subs	r3, #47	; 0x2f
 8002b64:	3bff      	subs	r3, #255	; 0xff

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8002b66:	4a19      	ldr	r2, [pc, #100]	; (8002bcc <main+0x2cc>)
 8002b68:	6223      	str	r3, [r4, #32]
 8002b6a:	3303      	adds	r3, #3
 8002b6c:	7213      	strb	r3, [r2, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b6e:	b662      	cpsie	i
  sdStart(&SD2, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8002b70:	2300      	movs	r3, #0
 8002b72:	21a4      	movs	r1, #164	; 0xa4
 8002b74:	9300      	str	r3, [sp, #0]
 8002b76:	4829      	ldr	r0, [pc, #164]	; (8002c1c <main+0x31c>)
 8002b78:	4b29      	ldr	r3, [pc, #164]	; (8002c20 <main+0x320>)
 8002b7a:	0049      	lsls	r1, r1, #1
 8002b7c:	2240      	movs	r2, #64	; 0x40
 8002b7e:	f7fd ff1f 	bl	80009c0 <chThdCreateStatic>
 8002b82:	4b28      	ldr	r3, [pc, #160]	; (8002c24 <main+0x324>)
 8002b84:	4c28      	ldr	r4, [pc, #160]	; (8002c28 <main+0x328>)
 8002b86:	4f29      	ldr	r7, [pc, #164]	; (8002c2c <main+0x32c>)
 8002b88:	4699      	mov	r9, r3
 8002b8a:	e055      	b.n	8002c38 <main+0x338>
 8002b8c:	40021000 	.word	0x40021000
 8002b90:	ffbfffff 	.word	0xffbfffff
 8002b94:	40007000 	.word	0x40007000
 8002b98:	fffff75f 	.word	0xfffff75f
 8002b9c:	64155105 	.word	0x64155105
 8002ba0:	0000ffdf 	.word	0x0000ffdf
 8002ba4:	2a8004a0 	.word	0x2a8004a0
 8002ba8:	0000ffff 	.word	0x0000ffff
 8002bac:	48000400 	.word	0x48000400
 8002bb0:	55555555 	.word	0x55555555
 8002bb4:	51555555 	.word	0x51555555
 8002bb8:	48000800 	.word	0x48000800
 8002bbc:	48000c00 	.word	0x48000c00
 8002bc0:	55555550 	.word	0x55555550
 8002bc4:	48001400 	.word	0x48001400
 8002bc8:	08005700 	.word	0x08005700
 8002bcc:	20000e98 	.word	0x20000e98
 8002bd0:	08000301 	.word	0x08000301
 8002bd4:	40004400 	.word	0x40004400
 8002bd8:	02dc6c00 	.word	0x02dc6c00
 8002bdc:	40015800 	.word	0x40015800
 8002be0:	40000400 	.word	0x40000400
 8002be4:	0000bb7f 	.word	0x0000bb7f
 8002be8:	e000e100 	.word	0xe000e100
 8002bec:	e000ed00 	.word	0xe000ed00
 8002bf0:	ff00ffff 	.word	0xff00ffff
 8002bf4:	20000f20 	.word	0x20000f20
 8002bf8:	20000e90 	.word	0x20000e90
 8002bfc:	20001168 	.word	0x20001168
 8002c00:	20002000 	.word	0x20002000
 8002c04:	200010cc 	.word	0x200010cc
 8002c08:	20001070 	.word	0x20001070
 8002c0c:	08000361 	.word	0x08000361
 8002c10:	08005690 	.word	0x08005690
 8002c14:	080003f1 	.word	0x080003f1
 8002c18:	00004040 	.word	0x00004040
 8002c1c:	20000d28 	.word	0x20000d28
 8002c20:	08002401 	.word	0x08002401
 8002c24:	20001090 	.word	0x20001090
 8002c28:	20001068 	.word	0x20001068
 8002c2c:	200010a4 	.word	0x200010a4
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadPad(GPIOC, GPIOC_BUTTON))
      TestThread(&SD2);
    chThdSleepMilliseconds(500);
 8002c30:	20fa      	movs	r0, #250	; 0xfa
 8002c32:	0040      	lsls	r0, r0, #1
 8002c34:	f7fe fc9c 	bl	8001570 <chThdSleep>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadPad(GPIOC, GPIOC_BUTTON))
 8002c38:	2280      	movs	r2, #128	; 0x80
 8002c3a:	4ba2      	ldr	r3, [pc, #648]	; (8002ec4 <main+0x5c4>)
 8002c3c:	0192      	lsls	r2, r2, #6
 8002c3e:	691b      	ldr	r3, [r3, #16]
 8002c40:	4213      	tst	r3, r2
 8002c42:	d1f5      	bne.n	8002c30 <main+0x330>
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8002c44:	4ba0      	ldr	r3, [pc, #640]	; (8002ec8 <main+0x5c8>)
  test_println("");
 8002c46:	48a1      	ldr	r0, [pc, #644]	; (8002ecc <main+0x5cc>)
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8002c48:	6023      	str	r3, [r4, #0]
  test_println("");
 8002c4a:	f7fd fd09 	bl	8000660 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8002c4e:	48a0      	ldr	r0, [pc, #640]	; (8002ed0 <main+0x5d0>)
 8002c50:	f7fd fd06 	bl	8000660 <test_println>
  test_println("***");
 8002c54:	489f      	ldr	r0, [pc, #636]	; (8002ed4 <main+0x5d4>)
 8002c56:	f7fd fd03 	bl	8000660 <test_println>
 8002c5a:	212a      	movs	r1, #42	; 0x2a
 8002c5c:	4d9e      	ldr	r5, [pc, #632]	; (8002ed8 <main+0x5d8>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002c5e:	6820      	ldr	r0, [r4, #0]
 8002c60:	3501      	adds	r5, #1
 8002c62:	6803      	ldr	r3, [r0, #0]
 8002c64:	689b      	ldr	r3, [r3, #8]
 8002c66:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002c68:	7829      	ldrb	r1, [r5, #0]
 8002c6a:	2900      	cmp	r1, #0
 8002c6c:	d1f7      	bne.n	8002c5e <main+0x35e>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8002c6e:	489b      	ldr	r0, [pc, #620]	; (8002edc <main+0x5dc>)
 8002c70:	f7fd fcf6 	bl	8000660 <test_println>
 8002c74:	212a      	movs	r1, #42	; 0x2a
 8002c76:	4d9a      	ldr	r5, [pc, #616]	; (8002ee0 <main+0x5e0>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002c78:	6820      	ldr	r0, [r4, #0]
 8002c7a:	3501      	adds	r5, #1
 8002c7c:	6803      	ldr	r3, [r0, #0]
 8002c7e:	689b      	ldr	r3, [r3, #8]
 8002c80:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002c82:	7829      	ldrb	r1, [r5, #0]
 8002c84:	2900      	cmp	r1, #0
 8002c86:	d1f7      	bne.n	8002c78 <main+0x378>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8002c88:	4896      	ldr	r0, [pc, #600]	; (8002ee4 <main+0x5e4>)
 8002c8a:	f7fd fce9 	bl	8000660 <test_println>
 8002c8e:	212a      	movs	r1, #42	; 0x2a
 8002c90:	4d95      	ldr	r5, [pc, #596]	; (8002ee8 <main+0x5e8>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002c92:	6820      	ldr	r0, [r4, #0]
 8002c94:	3501      	adds	r5, #1
 8002c96:	6803      	ldr	r3, [r0, #0]
 8002c98:	689b      	ldr	r3, [r3, #8]
 8002c9a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002c9c:	7829      	ldrb	r1, [r5, #0]
 8002c9e:	2900      	cmp	r1, #0
 8002ca0:	d1f7      	bne.n	8002c92 <main+0x392>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 8002ca2:	4892      	ldr	r0, [pc, #584]	; (8002eec <main+0x5ec>)
 8002ca4:	f7fd fcdc 	bl	8000660 <test_println>
 8002ca8:	212a      	movs	r1, #42	; 0x2a
 8002caa:	4d91      	ldr	r5, [pc, #580]	; (8002ef0 <main+0x5f0>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002cac:	6820      	ldr	r0, [r4, #0]
 8002cae:	3501      	adds	r5, #1
 8002cb0:	6803      	ldr	r3, [r0, #0]
 8002cb2:	689b      	ldr	r3, [r3, #8]
 8002cb4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002cb6:	7829      	ldrb	r1, [r5, #0]
 8002cb8:	2900      	cmp	r1, #0
 8002cba:	d1f7      	bne.n	8002cac <main+0x3ac>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 8002cbc:	488d      	ldr	r0, [pc, #564]	; (8002ef4 <main+0x5f4>)
 8002cbe:	f7fd fccf 	bl	8000660 <test_println>
 8002cc2:	212a      	movs	r1, #42	; 0x2a
 8002cc4:	4d8c      	ldr	r5, [pc, #560]	; (8002ef8 <main+0x5f8>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002cc6:	6820      	ldr	r0, [r4, #0]
 8002cc8:	3501      	adds	r5, #1
 8002cca:	6803      	ldr	r3, [r0, #0]
 8002ccc:	689b      	ldr	r3, [r3, #8]
 8002cce:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002cd0:	7829      	ldrb	r1, [r5, #0]
 8002cd2:	2900      	cmp	r1, #0
 8002cd4:	d1f7      	bne.n	8002cc6 <main+0x3c6>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8002cd6:	4889      	ldr	r0, [pc, #548]	; (8002efc <main+0x5fc>)
 8002cd8:	f7fd fcc2 	bl	8000660 <test_println>
 8002cdc:	212a      	movs	r1, #42	; 0x2a
 8002cde:	4d88      	ldr	r5, [pc, #544]	; (8002f00 <main+0x600>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002ce0:	6820      	ldr	r0, [r4, #0]
 8002ce2:	3501      	adds	r5, #1
 8002ce4:	6803      	ldr	r3, [r0, #0]
 8002ce6:	689b      	ldr	r3, [r3, #8]
 8002ce8:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002cea:	7829      	ldrb	r1, [r5, #0]
 8002cec:	2900      	cmp	r1, #0
 8002cee:	d1f7      	bne.n	8002ce0 <main+0x3e0>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 8002cf0:	4884      	ldr	r0, [pc, #528]	; (8002f04 <main+0x604>)
 8002cf2:	f7fd fcb5 	bl	8000660 <test_println>
 8002cf6:	212a      	movs	r1, #42	; 0x2a
 8002cf8:	4d83      	ldr	r5, [pc, #524]	; (8002f08 <main+0x608>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002cfa:	6820      	ldr	r0, [r4, #0]
 8002cfc:	3501      	adds	r5, #1
 8002cfe:	6803      	ldr	r3, [r0, #0]
 8002d00:	689b      	ldr	r3, [r3, #8]
 8002d02:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d04:	7829      	ldrb	r1, [r5, #0]
 8002d06:	2900      	cmp	r1, #0
 8002d08:	d1f7      	bne.n	8002cfa <main+0x3fa>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8002d0a:	252a      	movs	r5, #42	; 0x2a
 8002d0c:	487f      	ldr	r0, [pc, #508]	; (8002f0c <main+0x60c>)
 8002d0e:	f7fd fca7 	bl	8000660 <test_println>
 8002d12:	1c29      	adds	r1, r5, #0
 8002d14:	4e7e      	ldr	r6, [pc, #504]	; (8002f10 <main+0x610>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d16:	6820      	ldr	r0, [r4, #0]
 8002d18:	3601      	adds	r6, #1
 8002d1a:	6803      	ldr	r3, [r0, #0]
 8002d1c:	689b      	ldr	r3, [r3, #8]
 8002d1e:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d20:	7831      	ldrb	r1, [r6, #0]
 8002d22:	2900      	cmp	r1, #0
 8002d24:	d1f7      	bne.n	8002d16 <main+0x416>
 8002d26:	1c0d      	adds	r5, r1, #0
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8002d28:	487a      	ldr	r0, [pc, #488]	; (8002f14 <main+0x614>)
 8002d2a:	f7fd fc99 	bl	8000660 <test_println>
#endif
  test_println("");
 8002d2e:	4867      	ldr	r0, [pc, #412]	; (8002ecc <main+0x5cc>)
 8002d30:	f7fd fc96 	bl	8000660 <test_println>

  test_global_fail = FALSE;
 8002d34:	4b78      	ldr	r3, [pc, #480]	; (8002f18 <main+0x618>)
 8002d36:	701d      	strb	r5, [r3, #0]
 8002d38:	4b78      	ldr	r3, [pc, #480]	; (8002f1c <main+0x61c>)
 8002d3a:	469b      	mov	fp, r3
 8002d3c:	4b78      	ldr	r3, [pc, #480]	; (8002f20 <main+0x620>)
 8002d3e:	9302      	str	r3, [sp, #8]
 8002d40:	2300      	movs	r3, #0
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002d42:	4698      	mov	r8, r3
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");

  test_global_fail = FALSE;
 8002d44:	9303      	str	r3, [sp, #12]
 8002d46:	9b03      	ldr	r3, [sp, #12]
 8002d48:	3301      	adds	r3, #1
 8002d4a:	9303      	str	r3, [sp, #12]
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002d4c:	2300      	movs	r3, #0
 8002d4e:	469a      	mov	sl, r3
 8002d50:	4653      	mov	r3, sl
 8002d52:	009e      	lsls	r6, r3, #2

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8002d54:	9b02      	ldr	r3, [sp, #8]
 8002d56:	469c      	mov	ip, r3
 8002d58:	4466      	add	r6, ip
 8002d5a:	6833      	ldr	r3, [r6, #0]
 8002d5c:	2b00      	cmp	r3, #0
 8002d5e:	d100      	bne.n	8002d62 <main+0x462>
 8002d60:	e088      	b.n	8002e74 <main+0x574>
      print_line();
 8002d62:	f7fd fbcd 	bl	8000500 <print_line.lto_priv.138>
 8002d66:	212d      	movs	r1, #45	; 0x2d
 8002d68:	4d6e      	ldr	r5, [pc, #440]	; (8002f24 <main+0x624>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d6a:	6820      	ldr	r0, [r4, #0]
 8002d6c:	3501      	adds	r5, #1
 8002d6e:	6803      	ldr	r3, [r0, #0]
 8002d70:	689b      	ldr	r3, [r3, #8]
 8002d72:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002d74:	7829      	ldrb	r1, [r5, #0]
 8002d76:	2900      	cmp	r1, #0
 8002d78:	d1f7      	bne.n	8002d6a <main+0x46a>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8002d7a:	9803      	ldr	r0, [sp, #12]
 8002d7c:	f7fd fca8 	bl	80006d0 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d80:	6820      	ldr	r0, [r4, #0]
 8002d82:	212e      	movs	r1, #46	; 0x2e
 8002d84:	6803      	ldr	r3, [r0, #0]
 8002d86:	689b      	ldr	r3, [r3, #8]
 8002d88:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8002d8a:	2301      	movs	r3, #1
 8002d8c:	469c      	mov	ip, r3
 8002d8e:	44e2      	add	sl, ip
 8002d90:	4650      	mov	r0, sl
 8002d92:	f7fd fc9d 	bl	80006d0 <test_printn>
 8002d96:	2120      	movs	r1, #32
 8002d98:	4d63      	ldr	r5, [pc, #396]	; (8002f28 <main+0x628>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002d9a:	6820      	ldr	r0, [r4, #0]
 8002d9c:	3501      	adds	r5, #1
 8002d9e:	6803      	ldr	r3, [r0, #0]
 8002da0:	689b      	ldr	r3, [r3, #8]
 8002da2:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002da4:	7829      	ldrb	r1, [r5, #0]
 8002da6:	2900      	cmp	r1, #0
 8002da8:	d1f7      	bne.n	8002d9a <main+0x49a>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 8002daa:	6833      	ldr	r3, [r6, #0]
 8002dac:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002dae:	7829      	ldrb	r1, [r5, #0]
 8002db0:	2900      	cmp	r1, #0
 8002db2:	d007      	beq.n	8002dc4 <main+0x4c4>
    chSequentialStreamPut(chp, *msgp++);
 8002db4:	6820      	ldr	r0, [r4, #0]
 8002db6:	3501      	adds	r5, #1
 8002db8:	6803      	ldr	r3, [r0, #0]
 8002dba:	689b      	ldr	r3, [r3, #8]
 8002dbc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002dbe:	7829      	ldrb	r1, [r5, #0]
 8002dc0:	2900      	cmp	r1, #0
 8002dc2:	d1f7      	bne.n	8002db4 <main+0x4b4>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8002dc4:	4859      	ldr	r0, [pc, #356]	; (8002f2c <main+0x62c>)
 8002dc6:	f7fd fc4b 	bl	8000660 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8002dca:	20c8      	movs	r0, #200	; 0xc8
 8002dcc:	f7fe fbd0 	bl	8001570 <chThdSleep>
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8002dd0:	4642      	mov	r2, r8
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002dd2:	4b57      	ldr	r3, [pc, #348]	; (8002f30 <main+0x630>)
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 8002dd4:	6835      	ldr	r5, [r6, #0]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002dd6:	603b      	str	r3, [r7, #0]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8002dd8:	4b56      	ldr	r3, [pc, #344]	; (8002f34 <main+0x634>)
 8002dda:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8002ddc:	464b      	mov	r3, r9
 8002dde:	4642      	mov	r2, r8
 8002de0:	601a      	str	r2, [r3, #0]
 8002de2:	605a      	str	r2, [r3, #4]
 8002de4:	609a      	str	r2, [r3, #8]
 8002de6:	60da      	str	r2, [r3, #12]
 8002de8:	611a      	str	r2, [r3, #16]

  if (tcp->setup != NULL)
 8002dea:	686b      	ldr	r3, [r5, #4]
 8002dec:	2b00      	cmp	r3, #0
 8002dee:	d000      	beq.n	8002df2 <main+0x4f2>
    tcp->setup();
 8002df0:	4798      	blx	r3
  tcp->execute();
 8002df2:	68eb      	ldr	r3, [r5, #12]
 8002df4:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8002df6:	68ab      	ldr	r3, [r5, #8]
 8002df8:	2b00      	cmp	r3, #0
 8002dfa:	d000      	beq.n	8002dfe <main+0x4fe>
    tcp->teardown();
 8002dfc:	4798      	blx	r3

  test_wait_threads();
 8002dfe:	f7fe f91f 	bl	8001040 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8002e02:	4b4c      	ldr	r3, [pc, #304]	; (8002f34 <main+0x634>)
 8002e04:	781b      	ldrb	r3, [r3, #0]
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	d054      	beq.n	8002eb4 <main+0x5b4>
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8002e0a:	212d      	movs	r1, #45	; 0x2d
 8002e0c:	4d4a      	ldr	r5, [pc, #296]	; (8002f38 <main+0x638>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e0e:	6820      	ldr	r0, [r4, #0]
 8002e10:	3501      	adds	r5, #1
 8002e12:	6803      	ldr	r3, [r0, #0]
 8002e14:	689b      	ldr	r3, [r3, #8]
 8002e16:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e18:	7829      	ldrb	r1, [r5, #0]
 8002e1a:	2900      	cmp	r1, #0
 8002e1c:	d1f7      	bne.n	8002e0e <main+0x50e>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8002e1e:	4b47      	ldr	r3, [pc, #284]	; (8002f3c <main+0x63c>)
 8002e20:	6818      	ldr	r0, [r3, #0]
 8002e22:	f7fd fc55 	bl	80006d0 <test_printn>
 8002e26:	2120      	movs	r1, #32
 8002e28:	4d45      	ldr	r5, [pc, #276]	; (8002f40 <main+0x640>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e2a:	6820      	ldr	r0, [r4, #0]
 8002e2c:	3501      	adds	r5, #1
 8002e2e:	6803      	ldr	r3, [r0, #0]
 8002e30:	689b      	ldr	r3, [r3, #8]
 8002e32:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e34:	7829      	ldrb	r1, [r5, #0]
 8002e36:	2900      	cmp	r1, #0
 8002e38:	d1f7      	bne.n	8002e2a <main+0x52a>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002e3a:	4d3d      	ldr	r5, [pc, #244]	; (8002f30 <main+0x630>)
 8002e3c:	683b      	ldr	r3, [r7, #0]
 8002e3e:	42ab      	cmp	r3, r5
 8002e40:	d909      	bls.n	8002e56 <main+0x556>
    chSequentialStreamPut(chp, *cp++);
 8002e42:	6820      	ldr	r0, [r4, #0]
 8002e44:	3501      	adds	r5, #1
 8002e46:	6803      	ldr	r3, [r0, #0]
 8002e48:	1e6a      	subs	r2, r5, #1
 8002e4a:	689b      	ldr	r3, [r3, #8]
 8002e4c:	7811      	ldrb	r1, [r2, #0]
 8002e4e:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002e50:	683b      	ldr	r3, [r7, #0]
 8002e52:	429d      	cmp	r5, r3
 8002e54:	d3f5      	bcc.n	8002e42 <main+0x542>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8002e56:	483b      	ldr	r0, [pc, #236]	; (8002f44 <main+0x644>)
 8002e58:	f7fd fc02 	bl	8000660 <test_println>
 8002e5c:	465b      	mov	r3, fp
 8002e5e:	681b      	ldr	r3, [r3, #0]
 8002e60:	9302      	str	r3, [sp, #8]
 8002e62:	4653      	mov	r3, sl
 8002e64:	009e      	lsls	r6, r3, #2

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8002e66:	9b02      	ldr	r3, [sp, #8]
 8002e68:	469c      	mov	ip, r3
 8002e6a:	4466      	add	r6, ip
 8002e6c:	6833      	ldr	r3, [r6, #0]
 8002e6e:	2b00      	cmp	r3, #0
 8002e70:	d000      	beq.n	8002e74 <main+0x574>
 8002e72:	e776      	b.n	8002d62 <main+0x462>
 8002e74:	3304      	adds	r3, #4
 8002e76:	469c      	mov	ip, r3
 8002e78:	44e3      	add	fp, ip
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8002e7a:	465b      	mov	r3, fp
 8002e7c:	681b      	ldr	r3, [r3, #0]
 8002e7e:	9302      	str	r3, [sp, #8]
 8002e80:	2b00      	cmp	r3, #0
 8002e82:	d000      	beq.n	8002e86 <main+0x586>
 8002e84:	e75f      	b.n	8002d46 <main+0x446>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8002e86:	f7fd fb3b 	bl	8000500 <print_line.lto_priv.138>
  test_println("");
 8002e8a:	4810      	ldr	r0, [pc, #64]	; (8002ecc <main+0x5cc>)
 8002e8c:	f7fd fbe8 	bl	8000660 <test_println>
 8002e90:	2146      	movs	r1, #70	; 0x46
 8002e92:	4d2d      	ldr	r5, [pc, #180]	; (8002f48 <main+0x648>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002e94:	6820      	ldr	r0, [r4, #0]
 8002e96:	3501      	adds	r5, #1
 8002e98:	6803      	ldr	r3, [r0, #0]
 8002e9a:	689b      	ldr	r3, [r3, #8]
 8002e9c:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002e9e:	7829      	ldrb	r1, [r5, #0]
 8002ea0:	2900      	cmp	r1, #0
 8002ea2:	d1f7      	bne.n	8002e94 <main+0x594>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 8002ea4:	4b1c      	ldr	r3, [pc, #112]	; (8002f18 <main+0x618>)
 8002ea6:	781b      	ldrb	r3, [r3, #0]
 8002ea8:	2b00      	cmp	r3, #0
 8002eaa:	d107      	bne.n	8002ebc <main+0x5bc>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8002eac:	4827      	ldr	r0, [pc, #156]	; (8002f4c <main+0x64c>)
 8002eae:	f7fd fbd7 	bl	8000660 <test_println>
 8002eb2:	e6bd      	b.n	8002c30 <main+0x330>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 8002eb4:	4826      	ldr	r0, [pc, #152]	; (8002f50 <main+0x650>)
 8002eb6:	f7fd fbd3 	bl	8000660 <test_println>
 8002eba:	e749      	b.n	8002d50 <main+0x450>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8002ebc:	4825      	ldr	r0, [pc, #148]	; (8002f54 <main+0x654>)
 8002ebe:	f7fd fbcf 	bl	8000660 <test_println>
 8002ec2:	e6b5      	b.n	8002c30 <main+0x330>
 8002ec4:	48000800 	.word	0x48000800
 8002ec8:	20000e98 	.word	0x20000e98
 8002ecc:	08006260 	.word	0x08006260
 8002ed0:	08005bc0 	.word	0x08005bc0
 8002ed4:	08005bdc 	.word	0x08005bdc
 8002ed8:	08005ae0 	.word	0x08005ae0
 8002edc:	08005c04 	.word	0x08005c04
 8002ee0:	08005af4 	.word	0x08005af4
 8002ee4:	08005c0c 	.word	0x08005c0c
 8002ee8:	08005b08 	.word	0x08005b08
 8002eec:	08005c24 	.word	0x08005c24
 8002ef0:	08005b1c 	.word	0x08005b1c
 8002ef4:	08005c6c 	.word	0x08005c6c
 8002ef8:	08005b30 	.word	0x08005b30
 8002efc:	08005c74 	.word	0x08005c74
 8002f00:	08005b44 	.word	0x08005b44
 8002f04:	08005c80 	.word	0x08005c80
 8002f08:	08005b58 	.word	0x08005b58
 8002f0c:	08005c98 	.word	0x08005c98
 8002f10:	08005b6c 	.word	0x08005b6c
 8002f14:	08005cc4 	.word	0x08005cc4
 8002f18:	20000e94 	.word	0x20000e94
 8002f1c:	08005890 	.word	0x08005890
 8002f20:	08005820 	.word	0x08005820
 8002f24:	08005b80 	.word	0x08005b80
 8002f28:	08005b90 	.word	0x08005b90
 8002f2c:	08005be0 	.word	0x08005be0
 8002f30:	200010bc 	.word	0x200010bc
 8002f34:	20000e95 	.word	0x20000e95
 8002f38:	08005b94 	.word	0x08005b94
 8002f3c:	200006b8 	.word	0x200006b8
 8002f40:	08005bac 	.word	0x08005bac
 8002f44:	08005be4 	.word	0x08005be4
 8002f48:	08005bb0 	.word	0x08005bb0
 8002f4c:	08005bf4 	.word	0x08005bf4
 8002f50:	08005be8 	.word	0x08005be8
 8002f54:	08005bfc 	.word	0x08005bfc
 8002f58:	46c0      	nop			; (mov r8, r8)
 8002f5a:	46c0      	nop			; (mov r8, r8)
 8002f5c:	46c0      	nop			; (mov r8, r8)
 8002f5e:	46c0      	nop			; (mov r8, r8)

08002f60 <mbox1_setup.lto_priv.101>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8002f60:	4b09      	ldr	r3, [pc, #36]	; (8002f88 <mbox1_setup.lto_priv.101+0x28>)
 8002f62:	4a0a      	ldr	r2, [pc, #40]	; (8002f8c <mbox1_setup.lto_priv.101+0x2c>)
 8002f64:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8002f66:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8002f68:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8002f6a:	3214      	adds	r2, #20
 8002f6c:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f6e:	1c1a      	adds	r2, r3, #0
 8002f70:	321c      	adds	r2, #28
 8002f72:	61da      	str	r2, [r3, #28]
  tqp->p_prev = (thread_t *)tqp;
 8002f74:	621a      	str	r2, [r3, #32]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8002f76:	2205      	movs	r2, #5
 8002f78:	625a      	str	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f7a:	1c1a      	adds	r2, r3, #0
 8002f7c:	3210      	adds	r2, #16
 8002f7e:	611a      	str	r2, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8002f80:	615a      	str	r2, [r3, #20]
 8002f82:	2200      	movs	r2, #0
 8002f84:	619a      	str	r2, [r3, #24]
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}
 8002f86:	4770      	bx	lr
 8002f88:	2000060c 	.word	0x2000060c
 8002f8c:	200006c0 	.word	0x200006c0

08002f90 <mtx8_setup.lto_priv.98>:
 8002f90:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f92:	4b06      	ldr	r3, [pc, #24]	; (8002fac <mtx8_setup.lto_priv.98+0x1c>)
 8002f94:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002f96:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f98:	4b05      	ldr	r3, [pc, #20]	; (8002fb0 <mtx8_setup.lto_priv.98+0x20>)
 8002f9a:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002f9c:	605b      	str	r3, [r3, #4]
 8002f9e:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fa0:	4b04      	ldr	r3, [pc, #16]	; (8002fb4 <mtx8_setup.lto_priv.98+0x24>)
 8002fa2:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002fa4:	605b      	str	r3, [r3, #4]
 8002fa6:	609a      	str	r2, [r3, #8]
static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8002fa8:	4770      	bx	lr
 8002faa:	46c0      	nop			; (mov r8, r8)
 8002fac:	20000634 	.word	0x20000634
 8002fb0:	2000063c 	.word	0x2000063c
 8002fb4:	2000064c 	.word	0x2000064c
 8002fb8:	46c0      	nop			; (mov r8, r8)
 8002fba:	46c0      	nop			; (mov r8, r8)
 8002fbc:	46c0      	nop			; (mov r8, r8)
 8002fbe:	46c0      	nop			; (mov r8, r8)

08002fc0 <mtx7_setup.lto_priv.96>:
 8002fc0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fc2:	4b04      	ldr	r3, [pc, #16]	; (8002fd4 <mtx7_setup.lto_priv.96+0x14>)
 8002fc4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002fc6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fc8:	4b03      	ldr	r3, [pc, #12]	; (8002fd8 <mtx7_setup.lto_priv.96+0x18>)
 8002fca:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002fcc:	605b      	str	r3, [r3, #4]
 8002fce:	609a      	str	r2, [r3, #8]

static void mtx7_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8002fd0:	4770      	bx	lr
 8002fd2:	46c0      	nop			; (mov r8, r8)
 8002fd4:	20000634 	.word	0x20000634
 8002fd8:	2000063c 	.word	0x2000063c
 8002fdc:	46c0      	nop			; (mov r8, r8)
 8002fde:	46c0      	nop			; (mov r8, r8)

08002fe0 <mtx6_setup.lto_priv.94>:
 8002fe0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fe2:	4b04      	ldr	r3, [pc, #16]	; (8002ff4 <mtx6_setup.lto_priv.94+0x14>)
 8002fe4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002fe6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fe8:	4b03      	ldr	r3, [pc, #12]	; (8002ff8 <mtx6_setup.lto_priv.94+0x18>)
 8002fea:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002fec:	605b      	str	r3, [r3, #4]
 8002fee:	609a      	str	r2, [r3, #8]

static void mtx6_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8002ff0:	4770      	bx	lr
 8002ff2:	46c0      	nop			; (mov r8, r8)
 8002ff4:	20000634 	.word	0x20000634
 8002ff8:	2000063c 	.word	0x2000063c
 8002ffc:	46c0      	nop			; (mov r8, r8)
 8002ffe:	46c0      	nop			; (mov r8, r8)

08003000 <mbox1_execute.lto_priv.102>:

static void mbox1_execute(void) {
 8003000:	b570      	push	{r4, r5, r6, lr}
 8003002:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003004:	b672      	cpsid	i
 8003006:	4d16      	ldr	r5, [pc, #88]	; (8003060 <mbox1_execute.lto_priv.102+0x60>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8003008:	2001      	movs	r0, #1
 800300a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800300c:	1f59      	subs	r1, r3, #5
 800300e:	424a      	negs	r2, r1
 8003010:	414a      	adcs	r2, r1
 8003012:	b2d1      	uxtb	r1, r2
 8003014:	f7fd faf4 	bl	8000600 <_test_assert>
 8003018:	2800      	cmp	r0, #0
 800301a:	d000      	beq.n	800301e <mbox1_execute.lto_priv.102+0x1e>
 800301c:	e1f9      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800301e:	b662      	cpsie	i
 8003020:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8003022:	4910      	ldr	r1, [pc, #64]	; (8003064 <mbox1_execute.lto_priv.102+0x64>)
 8003024:	1c20      	adds	r0, r4, #0
 8003026:	f7ff fb8b 	bl	8002740 <chMBPost.constprop.20>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800302a:	4241      	negs	r1, r0
 800302c:	4141      	adcs	r1, r0
 800302e:	2002      	movs	r0, #2
 8003030:	b2c9      	uxtb	r1, r1
 8003032:	f7fd fae5 	bl	8000600 <_test_assert>
 8003036:	2800      	cmp	r0, #0
 8003038:	d10f      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
 800303a:	3401      	adds	r4, #1
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800303c:	2c46      	cmp	r4, #70	; 0x46
 800303e:	d1f0      	bne.n	8003022 <mbox1_execute.lto_priv.102+0x22>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 8003040:	4908      	ldr	r1, [pc, #32]	; (8003064 <mbox1_execute.lto_priv.102+0x64>)
 8003042:	3041      	adds	r0, #65	; 0x41
 8003044:	f7ff fbbc 	bl	80027c0 <chMBPostAhead.constprop.18>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 8003048:	4241      	negs	r1, r0
 800304a:	4141      	adcs	r1, r0
 800304c:	2003      	movs	r0, #3
 800304e:	b2c9      	uxtb	r1, r1
 8003050:	f7fd fad6 	bl	8000600 <_test_assert>
 8003054:	2800      	cmp	r0, #0
 8003056:	d100      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
 8003058:	e1dd      	b.n	8003416 <mbox1_execute.lto_priv.102+0x416>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 800305a:	b002      	add	sp, #8
 800305c:	bd70      	pop	{r4, r5, r6, pc}
 800305e:	46c0      	nop			; (mov r8, r8)
 8003060:	2000060c 	.word	0x2000060c
 8003064:	0000ffff 	.word	0x0000ffff
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 8003068:	4ed4      	ldr	r6, [pc, #848]	; (80033bc <mbox1_execute.lto_priv.102+0x3bc>)
 800306a:	200c      	movs	r0, #12
 800306c:	1c31      	adds	r1, r6, #0
 800306e:	f7fd fa97 	bl	80005a0 <_test_assert_sequence>
 8003072:	2800      	cmp	r0, #0
 8003074:	d1f1      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8003076:	49d2      	ldr	r1, [pc, #840]	; (80033c0 <mbox1_execute.lto_priv.102+0x3c0>)
 8003078:	3047      	adds	r0, #71	; 0x47
 800307a:	f7ff fb61 	bl	8002740 <chMBPost.constprop.20>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800307e:	4241      	negs	r1, r0
 8003080:	4141      	adcs	r1, r0
 8003082:	200d      	movs	r0, #13
 8003084:	b2c9      	uxtb	r1, r1
 8003086:	f7fd fabb 	bl	8000600 <_test_assert>
 800308a:	2800      	cmp	r0, #0
 800308c:	d1e5      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800308e:	49cc      	ldr	r1, [pc, #816]	; (80033c0 <mbox1_execute.lto_priv.102+0x3c0>)
 8003090:	a801      	add	r0, sp, #4
 8003092:	f7ff fbd5 	bl	8002840 <chMBFetch.constprop.16>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 8003096:	4241      	negs	r1, r0
 8003098:	4141      	adcs	r1, r0
 800309a:	200e      	movs	r0, #14
 800309c:	b2c9      	uxtb	r1, r1
 800309e:	f7fd faaf 	bl	8000600 <_test_assert>
 80030a2:	2800      	cmp	r0, #0
 80030a4:	d1d9      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80030a6:	682b      	ldr	r3, [r5, #0]
 80030a8:	68aa      	ldr	r2, [r5, #8]
 80030aa:	300f      	adds	r0, #15
 80030ac:	1a99      	subs	r1, r3, r2
 80030ae:	424a      	negs	r2, r1
 80030b0:	414a      	adcs	r2, r1
 80030b2:	b2d1      	uxtb	r1, r2
 80030b4:	f7fd faa4 	bl	8000600 <_test_assert>
 80030b8:	2800      	cmp	r0, #0
 80030ba:	d1ce      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80030bc:	682b      	ldr	r3, [r5, #0]
 80030be:	68ea      	ldr	r2, [r5, #12]
 80030c0:	3010      	adds	r0, #16
 80030c2:	1a99      	subs	r1, r3, r2
 80030c4:	424a      	negs	r2, r1
 80030c6:	414a      	adcs	r2, r1
 80030c8:	b2d1      	uxtb	r1, r2
 80030ca:	f7fd fa99 	bl	8000600 <_test_assert>
 80030ce:	2800      	cmp	r0, #0
 80030d0:	d1c3      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 80030d2:	2101      	movs	r1, #1
 80030d4:	a801      	add	r0, sp, #4
 80030d6:	f7ff fbb3 	bl	8002840 <chMBFetch.constprop.16>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80030da:	1c41      	adds	r1, r0, #1
 80030dc:	424b      	negs	r3, r1
 80030de:	414b      	adcs	r3, r1
 80030e0:	2011      	movs	r0, #17
 80030e2:	b2d9      	uxtb	r1, r3
 80030e4:	f7fd fa8c 	bl	8000600 <_test_assert>
 80030e8:	2800      	cmp	r0, #0
 80030ea:	d1b6      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80030ec:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 80030ee:	a801      	add	r0, sp, #4
 80030f0:	f7ff fbc6 	bl	8002880 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80030f4:	b662      	cpsie	i
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80030f6:	1c41      	adds	r1, r0, #1
 80030f8:	424b      	negs	r3, r1
 80030fa:	414b      	adcs	r3, r1
 80030fc:	2012      	movs	r0, #18
 80030fe:	b2d9      	uxtb	r1, r3
 8003100:	f7fd fa7e 	bl	8000600 <_test_assert>
 8003104:	2800      	cmp	r0, #0
 8003106:	d1a8      	bne.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003108:	b672      	cpsid	i

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800310a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800310c:	3013      	adds	r0, #19
 800310e:	1f59      	subs	r1, r3, #5
 8003110:	424a      	negs	r2, r1
 8003112:	414a      	adcs	r2, r1
 8003114:	b2d1      	uxtb	r1, r2
 8003116:	f7fd fa73 	bl	8000600 <_test_assert>
 800311a:	2800      	cmp	r0, #0
 800311c:	d000      	beq.n	8003120 <mbox1_execute.lto_priv.102+0x120>
 800311e:	e178      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003120:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003122:	b672      	cpsid	i
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 8003124:	69a9      	ldr	r1, [r5, #24]
 8003126:	2014      	movs	r0, #20
 8003128:	424b      	negs	r3, r1
 800312a:	4159      	adcs	r1, r3
 800312c:	b2c9      	uxtb	r1, r1
 800312e:	f7fd fa67 	bl	8000600 <_test_assert>
 8003132:	2800      	cmp	r0, #0
 8003134:	d000      	beq.n	8003138 <mbox1_execute.lto_priv.102+0x138>
 8003136:	e16c      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003138:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800313a:	b672      	cpsid	i
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800313c:	68eb      	ldr	r3, [r5, #12]
 800313e:	68aa      	ldr	r2, [r5, #8]
 8003140:	2015      	movs	r0, #21
 8003142:	1a99      	subs	r1, r3, r2
 8003144:	424a      	negs	r2, r1
 8003146:	414a      	adcs	r2, r1
 8003148:	b2d1      	uxtb	r1, r2
 800314a:	f7fd fa59 	bl	8000600 <_test_assert>
 800314e:	2800      	cmp	r0, #0
 8003150:	d000      	beq.n	8003154 <mbox1_execute.lto_priv.102+0x154>
 8003152:	e15e      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003154:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003156:	b672      	cpsid	i

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 8003158:	2041      	movs	r0, #65	; 0x41
 800315a:	f7ff fb11 	bl	8002780 <chMBPostI.constprop.19>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800315e:	4241      	negs	r1, r0
 8003160:	4141      	adcs	r1, r0
 8003162:	2016      	movs	r0, #22
 8003164:	b2c9      	uxtb	r1, r1
 8003166:	f7fd fa4b 	bl	8000600 <_test_assert>
 800316a:	2800      	cmp	r0, #0
 800316c:	d000      	beq.n	8003170 <mbox1_execute.lto_priv.102+0x170>
 800316e:	e774      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostI(&mb1, 'B');
 8003170:	3042      	adds	r0, #66	; 0x42
 8003172:	f7ff fb05 	bl	8002780 <chMBPostI.constprop.19>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 8003176:	4241      	negs	r1, r0
 8003178:	4141      	adcs	r1, r0
 800317a:	2017      	movs	r0, #23
 800317c:	b2c9      	uxtb	r1, r1
 800317e:	f7fd fa3f 	bl	8000600 <_test_assert>
 8003182:	2800      	cmp	r0, #0
 8003184:	d000      	beq.n	8003188 <mbox1_execute.lto_priv.102+0x188>
 8003186:	e768      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostI(&mb1, 'C');
 8003188:	3043      	adds	r0, #67	; 0x43
 800318a:	f7ff faf9 	bl	8002780 <chMBPostI.constprop.19>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800318e:	4241      	negs	r1, r0
 8003190:	4141      	adcs	r1, r0
 8003192:	2018      	movs	r0, #24
 8003194:	b2c9      	uxtb	r1, r1
 8003196:	f7fd fa33 	bl	8000600 <_test_assert>
 800319a:	2800      	cmp	r0, #0
 800319c:	d000      	beq.n	80031a0 <mbox1_execute.lto_priv.102+0x1a0>
 800319e:	e75c      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostI(&mb1, 'D');
 80031a0:	3044      	adds	r0, #68	; 0x44
 80031a2:	f7ff faed 	bl	8002780 <chMBPostI.constprop.19>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 80031a6:	4241      	negs	r1, r0
 80031a8:	4141      	adcs	r1, r0
 80031aa:	2019      	movs	r0, #25
 80031ac:	b2c9      	uxtb	r1, r1
 80031ae:	f7fd fa27 	bl	8000600 <_test_assert>
 80031b2:	2800      	cmp	r0, #0
 80031b4:	d000      	beq.n	80031b8 <mbox1_execute.lto_priv.102+0x1b8>
 80031b6:	e750      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostI(&mb1, 'E');
 80031b8:	3045      	adds	r0, #69	; 0x45
 80031ba:	f7ff fae1 	bl	8002780 <chMBPostI.constprop.19>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80031be:	b662      	cpsie	i
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 80031c0:	4241      	negs	r1, r0
 80031c2:	4141      	adcs	r1, r0
 80031c4:	201a      	movs	r0, #26
 80031c6:	b2c9      	uxtb	r1, r1
 80031c8:	f7fd fa1a 	bl	8000600 <_test_assert>
 80031cc:	2800      	cmp	r0, #0
 80031ce:	d000      	beq.n	80031d2 <mbox1_execute.lto_priv.102+0x1d2>
 80031d0:	e743      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80031d2:	68eb      	ldr	r3, [r5, #12]
 80031d4:	68aa      	ldr	r2, [r5, #8]
 80031d6:	301b      	adds	r0, #27
 80031d8:	1a99      	subs	r1, r3, r2
 80031da:	424a      	negs	r2, r1
 80031dc:	414a      	adcs	r2, r1
 80031de:	b2d1      	uxtb	r1, r2
 80031e0:	f7fd fa0e 	bl	8000600 <_test_assert>
 80031e4:	2800      	cmp	r0, #0
 80031e6:	d000      	beq.n	80031ea <mbox1_execute.lto_priv.102+0x1ea>
 80031e8:	e737      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
 80031ea:	2405      	movs	r4, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80031ec:	b672      	cpsid	i
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 80031ee:	a801      	add	r0, sp, #4
 80031f0:	f7ff fb46 	bl	8002880 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80031f4:	b662      	cpsie	i
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80031f6:	4241      	negs	r1, r0
 80031f8:	4141      	adcs	r1, r0
 80031fa:	201c      	movs	r0, #28
 80031fc:	b2c9      	uxtb	r1, r1
 80031fe:	f7fd f9ff 	bl	8000600 <_test_assert>
 8003202:	2800      	cmp	r0, #0
 8003204:	d000      	beq.n	8003208 <mbox1_execute.lto_priv.102+0x208>
 8003206:	e728      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
    test_emit_token(msg2);
 8003208:	9b01      	ldr	r3, [sp, #4]
 800320a:	3c01      	subs	r4, #1
 800320c:	b2d8      	uxtb	r0, r3
 800320e:	f7fd fa0f 	bl	8000630 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8003212:	2c00      	cmp	r4, #0
 8003214:	d1ea      	bne.n	80031ec <mbox1_execute.lto_priv.102+0x1ec>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 8003216:	201d      	movs	r0, #29
 8003218:	1c31      	adds	r1, r6, #0
 800321a:	f7fd f9c1 	bl	80005a0 <_test_assert_sequence>
 800321e:	2800      	cmp	r0, #0
 8003220:	d000      	beq.n	8003224 <mbox1_execute.lto_priv.102+0x224>
 8003222:	e71a      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003224:	b672      	cpsid	i
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8003226:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003228:	301e      	adds	r0, #30
 800322a:	1f59      	subs	r1, r3, #5
 800322c:	424a      	negs	r2, r1
 800322e:	414a      	adcs	r2, r1
 8003230:	b2d1      	uxtb	r1, r2
 8003232:	f7fd f9e5 	bl	8000600 <_test_assert>
 8003236:	2800      	cmp	r0, #0
 8003238:	d000      	beq.n	800323c <mbox1_execute.lto_priv.102+0x23c>
 800323a:	e0ea      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800323c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800323e:	b672      	cpsid	i
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 8003240:	69a9      	ldr	r1, [r5, #24]
 8003242:	201f      	movs	r0, #31
 8003244:	424b      	negs	r3, r1
 8003246:	4159      	adcs	r1, r3
 8003248:	b2c9      	uxtb	r1, r1
 800324a:	f7fd f9d9 	bl	8000600 <_test_assert>
 800324e:	2800      	cmp	r0, #0
 8003250:	d000      	beq.n	8003254 <mbox1_execute.lto_priv.102+0x254>
 8003252:	e0de      	b.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003254:	b662      	cpsie	i
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8003256:	68eb      	ldr	r3, [r5, #12]
 8003258:	68aa      	ldr	r2, [r5, #8]
 800325a:	2020      	movs	r0, #32
 800325c:	1a99      	subs	r1, r3, r2
 800325e:	424a      	negs	r2, r1
 8003260:	414a      	adcs	r2, r1
 8003262:	b2d1      	uxtb	r1, r2
 8003264:	f7fd f9cc 	bl	8000600 <_test_assert>
 8003268:	2800      	cmp	r0, #0
 800326a:	d000      	beq.n	800326e <mbox1_execute.lto_priv.102+0x26e>
 800326c:	e6f5      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800326e:	b672      	cpsid	i

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 8003270:	3045      	adds	r0, #69	; 0x45
 8003272:	f7ff fac5 	bl	8002800 <chMBPostAheadI.constprop.17>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8003276:	4241      	negs	r1, r0
 8003278:	4141      	adcs	r1, r0
 800327a:	2021      	movs	r0, #33	; 0x21
 800327c:	b2c9      	uxtb	r1, r1
 800327e:	f7fd f9bf 	bl	8000600 <_test_assert>
 8003282:	2800      	cmp	r0, #0
 8003284:	d000      	beq.n	8003288 <mbox1_execute.lto_priv.102+0x288>
 8003286:	e6e8      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8003288:	3044      	adds	r0, #68	; 0x44
 800328a:	f7ff fab9 	bl	8002800 <chMBPostAheadI.constprop.17>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800328e:	4241      	negs	r1, r0
 8003290:	4141      	adcs	r1, r0
 8003292:	2022      	movs	r0, #34	; 0x22
 8003294:	b2c9      	uxtb	r1, r1
 8003296:	f7fd f9b3 	bl	8000600 <_test_assert>
 800329a:	2800      	cmp	r0, #0
 800329c:	d000      	beq.n	80032a0 <mbox1_execute.lto_priv.102+0x2a0>
 800329e:	e6dc      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostAheadI(&mb1, 'C');
 80032a0:	3043      	adds	r0, #67	; 0x43
 80032a2:	f7ff faad 	bl	8002800 <chMBPostAheadI.constprop.17>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 80032a6:	4241      	negs	r1, r0
 80032a8:	4141      	adcs	r1, r0
 80032aa:	2023      	movs	r0, #35	; 0x23
 80032ac:	b2c9      	uxtb	r1, r1
 80032ae:	f7fd f9a7 	bl	8000600 <_test_assert>
 80032b2:	2800      	cmp	r0, #0
 80032b4:	d000      	beq.n	80032b8 <mbox1_execute.lto_priv.102+0x2b8>
 80032b6:	e6d0      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostAheadI(&mb1, 'B');
 80032b8:	3042      	adds	r0, #66	; 0x42
 80032ba:	f7ff faa1 	bl	8002800 <chMBPostAheadI.constprop.17>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 80032be:	4241      	negs	r1, r0
 80032c0:	4141      	adcs	r1, r0
 80032c2:	2024      	movs	r0, #36	; 0x24
 80032c4:	b2c9      	uxtb	r1, r1
 80032c6:	f7fd f99b 	bl	8000600 <_test_assert>
 80032ca:	2800      	cmp	r0, #0
 80032cc:	d000      	beq.n	80032d0 <mbox1_execute.lto_priv.102+0x2d0>
 80032ce:	e6c4      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostAheadI(&mb1, 'A');
 80032d0:	3041      	adds	r0, #65	; 0x41
 80032d2:	f7ff fa95 	bl	8002800 <chMBPostAheadI.constprop.17>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80032d6:	b662      	cpsie	i
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 80032d8:	4241      	negs	r1, r0
 80032da:	4141      	adcs	r1, r0
 80032dc:	2025      	movs	r0, #37	; 0x25
 80032de:	b2c9      	uxtb	r1, r1
 80032e0:	f7fd f98e 	bl	8000600 <_test_assert>
 80032e4:	2800      	cmp	r0, #0
 80032e6:	d000      	beq.n	80032ea <mbox1_execute.lto_priv.102+0x2ea>
 80032e8:	e6b7      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80032ea:	68eb      	ldr	r3, [r5, #12]
 80032ec:	68aa      	ldr	r2, [r5, #8]
 80032ee:	3026      	adds	r0, #38	; 0x26
 80032f0:	1a99      	subs	r1, r3, r2
 80032f2:	424a      	negs	r2, r1
 80032f4:	414a      	adcs	r2, r1
 80032f6:	b2d1      	uxtb	r1, r2
 80032f8:	f7fd f982 	bl	8000600 <_test_assert>
 80032fc:	2800      	cmp	r0, #0
 80032fe:	d000      	beq.n	8003302 <mbox1_execute.lto_priv.102+0x302>
 8003300:	e6ab      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
 8003302:	2405      	movs	r4, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003304:	b672      	cpsid	i
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8003306:	a801      	add	r0, sp, #4
 8003308:	f7ff faba 	bl	8002880 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800330c:	b662      	cpsie	i
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800330e:	4241      	negs	r1, r0
 8003310:	4141      	adcs	r1, r0
 8003312:	2027      	movs	r0, #39	; 0x27
 8003314:	b2c9      	uxtb	r1, r1
 8003316:	f7fd f973 	bl	8000600 <_test_assert>
 800331a:	2800      	cmp	r0, #0
 800331c:	d000      	beq.n	8003320 <mbox1_execute.lto_priv.102+0x320>
 800331e:	e69c      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
    test_emit_token(msg2);
 8003320:	9b01      	ldr	r3, [sp, #4]
 8003322:	3c01      	subs	r4, #1
 8003324:	b2d8      	uxtb	r0, r3
 8003326:	f7fd f983 	bl	8000630 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800332a:	2c00      	cmp	r4, #0
 800332c:	d1ea      	bne.n	8003304 <mbox1_execute.lto_priv.102+0x304>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 800332e:	2028      	movs	r0, #40	; 0x28
 8003330:	1c31      	adds	r1, r6, #0
 8003332:	f7fd f935 	bl	80005a0 <_test_assert_sequence>
 8003336:	2800      	cmp	r0, #0
 8003338:	d000      	beq.n	800333c <mbox1_execute.lto_priv.102+0x33c>
 800333a:	e68e      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800333c:	b672      	cpsid	i
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800333e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003340:	3029      	adds	r0, #41	; 0x29
 8003342:	1f59      	subs	r1, r3, #5
 8003344:	424a      	negs	r2, r1
 8003346:	414a      	adcs	r2, r1
 8003348:	b2d1      	uxtb	r1, r2
 800334a:	f7fd f959 	bl	8000600 <_test_assert>
 800334e:	2800      	cmp	r0, #0
 8003350:	d15f      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003352:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003354:	b672      	cpsid	i
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 8003356:	69a9      	ldr	r1, [r5, #24]
 8003358:	202a      	movs	r0, #42	; 0x2a
 800335a:	424b      	negs	r3, r1
 800335c:	4159      	adcs	r1, r3
 800335e:	b2c9      	uxtb	r1, r1
 8003360:	f7fd f94e 	bl	8000600 <_test_assert>
 8003364:	2800      	cmp	r0, #0
 8003366:	d154      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003368:	b662      	cpsie	i
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800336a:	68eb      	ldr	r3, [r5, #12]
 800336c:	68aa      	ldr	r2, [r5, #8]
 800336e:	202b      	movs	r0, #43	; 0x2b
 8003370:	1a99      	subs	r1, r3, r2
 8003372:	424a      	negs	r2, r1
 8003374:	414a      	adcs	r2, r1
 8003376:	b2d1      	uxtb	r1, r2
 8003378:	f7fd f942 	bl	8000600 <_test_assert>
 800337c:	2800      	cmp	r0, #0
 800337e:	d000      	beq.n	8003382 <mbox1_execute.lto_priv.102+0x382>
 8003380:	e66b      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003382:	b672      	cpsid	i
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8003384:	6829      	ldr	r1, [r5, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8003386:	686b      	ldr	r3, [r5, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8003388:	60a9      	str	r1, [r5, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 800338a:	60e9      	str	r1, [r5, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 800338c:	1a59      	subs	r1, r3, r1
 800338e:	1089      	asrs	r1, r1, #2
 8003390:	480c      	ldr	r0, [pc, #48]	; (80033c4 <mbox1_execute.lto_priv.102+0x3c4>)
 8003392:	f7fd fecd 	bl	8001130 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8003396:	480c      	ldr	r0, [pc, #48]	; (80033c8 <mbox1_execute.lto_priv.102+0x3c8>)
 8003398:	1c21      	adds	r1, r4, #0
 800339a:	f7fd fec9 	bl	8001130 <chSemResetI>
 */
void chMBReset(mailbox_t *mbp) {

  chSysLock();
  chMBResetI(mbp);
  chSchRescheduleS();
 800339e:	f7fd fa77 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033a2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033a4:	b672      	cpsid	i
  chMBReset(&mb1);

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80033a6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80033a8:	202c      	movs	r0, #44	; 0x2c
 80033aa:	1f59      	subs	r1, r3, #5
 80033ac:	424a      	negs	r2, r1
 80033ae:	414a      	adcs	r2, r1
 80033b0:	b2d1      	uxtb	r1, r2
 80033b2:	f7fd f925 	bl	8000600 <_test_assert>
 80033b6:	2800      	cmp	r0, #0
 80033b8:	d12b      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
 80033ba:	e007      	b.n	80033cc <mbox1_execute.lto_priv.102+0x3cc>
 80033bc:	08005600 	.word	0x08005600
 80033c0:	0000ffff 	.word	0x0000ffff
 80033c4:	20000628 	.word	0x20000628
 80033c8:	2000061c 	.word	0x2000061c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033cc:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033ce:	b672      	cpsid	i
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 80033d0:	69a9      	ldr	r1, [r5, #24]
 80033d2:	202d      	movs	r0, #45	; 0x2d
 80033d4:	424b      	negs	r3, r1
 80033d6:	4159      	adcs	r1, r3
 80033d8:	b2c9      	uxtb	r1, r1
 80033da:	f7fd f911 	bl	8000600 <_test_assert>
 80033de:	2800      	cmp	r0, #0
 80033e0:	d117      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033e2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033e4:	b672      	cpsid	i
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80033e6:	682b      	ldr	r3, [r5, #0]
 80033e8:	68aa      	ldr	r2, [r5, #8]
 80033ea:	202e      	movs	r0, #46	; 0x2e
 80033ec:	1a99      	subs	r1, r3, r2
 80033ee:	424a      	negs	r2, r1
 80033f0:	414a      	adcs	r2, r1
 80033f2:	b2d1      	uxtb	r1, r2
 80033f4:	f7fd f904 	bl	8000600 <_test_assert>
 80033f8:	2800      	cmp	r0, #0
 80033fa:	d10a      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033fc:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033fe:	b672      	cpsid	i
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8003400:	682b      	ldr	r3, [r5, #0]
 8003402:	68e9      	ldr	r1, [r5, #12]
 8003404:	202f      	movs	r0, #47	; 0x2f
 8003406:	1a59      	subs	r1, r3, r1
 8003408:	424a      	negs	r2, r1
 800340a:	414a      	adcs	r2, r1
 800340c:	b2d1      	uxtb	r1, r2
 800340e:	f7fd f8f7 	bl	8000600 <_test_assert>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003412:	b662      	cpsie	i
 8003414:	e621      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 8003416:	2101      	movs	r1, #1
 8003418:	3058      	adds	r0, #88	; 0x58
 800341a:	f7ff f991 	bl	8002740 <chMBPost.constprop.20>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800341e:	3001      	adds	r0, #1
 8003420:	4241      	negs	r1, r0
 8003422:	4141      	adcs	r1, r0
 8003424:	2004      	movs	r0, #4
 8003426:	b2c9      	uxtb	r1, r1
 8003428:	f7fd f8ea 	bl	8000600 <_test_assert>
 800342c:	2800      	cmp	r0, #0
 800342e:	d000      	beq.n	8003432 <mbox1_execute.lto_priv.102+0x432>
 8003430:	e613      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003432:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 8003434:	3058      	adds	r0, #88	; 0x58
 8003436:	f7ff f9a3 	bl	8002780 <chMBPostI.constprop.19>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800343a:	b662      	cpsie	i
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800343c:	3001      	adds	r0, #1
 800343e:	4241      	negs	r1, r0
 8003440:	4141      	adcs	r1, r0
 8003442:	2005      	movs	r0, #5
 8003444:	b2c9      	uxtb	r1, r1
 8003446:	f7fd f8db 	bl	8000600 <_test_assert>
 800344a:	2800      	cmp	r0, #0
 800344c:	d000      	beq.n	8003450 <mbox1_execute.lto_priv.102+0x450>
 800344e:	e604      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 8003450:	2101      	movs	r1, #1
 8003452:	3058      	adds	r0, #88	; 0x58
 8003454:	f7ff f9b4 	bl	80027c0 <chMBPostAhead.constprop.18>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003458:	1c41      	adds	r1, r0, #1
 800345a:	424b      	negs	r3, r1
 800345c:	414b      	adcs	r3, r1
 800345e:	2006      	movs	r0, #6
 8003460:	b2d9      	uxtb	r1, r3
 8003462:	f7fd f8cd 	bl	8000600 <_test_assert>
 8003466:	2800      	cmp	r0, #0
 8003468:	d000      	beq.n	800346c <mbox1_execute.lto_priv.102+0x46c>
 800346a:	e5f6      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800346c:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 800346e:	3058      	adds	r0, #88	; 0x58
 8003470:	f7ff f9c6 	bl	8002800 <chMBPostAheadI.constprop.17>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003474:	b662      	cpsie	i
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003476:	1c41      	adds	r1, r0, #1
 8003478:	424b      	negs	r3, r1
 800347a:	414b      	adcs	r3, r1
 800347c:	2007      	movs	r0, #7
 800347e:	b2d9      	uxtb	r1, r3
 8003480:	f7fd f8be 	bl	8000600 <_test_assert>
 8003484:	2800      	cmp	r0, #0
 8003486:	d000      	beq.n	800348a <mbox1_execute.lto_priv.102+0x48a>
 8003488:	e5e7      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800348a:	b672      	cpsid	i

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800348c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800348e:	3008      	adds	r0, #8
 8003490:	424b      	negs	r3, r1
 8003492:	4159      	adcs	r1, r3
 8003494:	b2c9      	uxtb	r1, r1
 8003496:	f7fd f8b3 	bl	8000600 <_test_assert>
 800349a:	2800      	cmp	r0, #0
 800349c:	d1b9      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800349e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80034a0:	b672      	cpsid	i
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80034a2:	69ab      	ldr	r3, [r5, #24]
 80034a4:	2009      	movs	r0, #9
 80034a6:	1f59      	subs	r1, r3, #5
 80034a8:	424a      	negs	r2, r1
 80034aa:	414a      	adcs	r2, r1
 80034ac:	b2d1      	uxtb	r1, r2
 80034ae:	f7fd f8a7 	bl	8000600 <_test_assert>
 80034b2:	2800      	cmp	r0, #0
 80034b4:	d1ad      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80034b6:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80034b8:	b672      	cpsid	i
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80034ba:	68eb      	ldr	r3, [r5, #12]
 80034bc:	68aa      	ldr	r2, [r5, #8]
 80034be:	200a      	movs	r0, #10
 80034c0:	1a99      	subs	r1, r3, r2
 80034c2:	424a      	negs	r2, r1
 80034c4:	414a      	adcs	r2, r1
 80034c6:	b2d1      	uxtb	r1, r2
 80034c8:	f7fd f89a 	bl	8000600 <_test_assert>
 80034cc:	2800      	cmp	r0, #0
 80034ce:	d1a0      	bne.n	8003412 <mbox1_execute.lto_priv.102+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80034d0:	b662      	cpsie	i
 80034d2:	2405      	movs	r4, #5
 80034d4:	e007      	b.n	80034e6 <mbox1_execute.lto_priv.102+0x4e6>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 80034d6:	9b01      	ldr	r3, [sp, #4]
 80034d8:	3c01      	subs	r4, #1
 80034da:	b2d8      	uxtb	r0, r3
 80034dc:	f7fd f8a8 	bl	8000630 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80034e0:	2c00      	cmp	r4, #0
 80034e2:	d100      	bne.n	80034e6 <mbox1_execute.lto_priv.102+0x4e6>
 80034e4:	e5c0      	b.n	8003068 <mbox1_execute.lto_priv.102+0x68>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80034e6:	4906      	ldr	r1, [pc, #24]	; (8003500 <mbox1_execute.lto_priv.102+0x500>)
 80034e8:	a801      	add	r0, sp, #4
 80034ea:	f7ff f9a9 	bl	8002840 <chMBFetch.constprop.16>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80034ee:	4241      	negs	r1, r0
 80034f0:	4141      	adcs	r1, r0
 80034f2:	200b      	movs	r0, #11
 80034f4:	b2c9      	uxtb	r1, r1
 80034f6:	f7fd f883 	bl	8000600 <_test_assert>
 80034fa:	2800      	cmp	r0, #0
 80034fc:	d0eb      	beq.n	80034d6 <mbox1_execute.lto_priv.102+0x4d6>
 80034fe:	e5ac      	b.n	800305a <mbox1_execute.lto_priv.102+0x5a>
 8003500:	0000ffff 	.word	0x0000ffff
 8003504:	46c0      	nop			; (mov r8, r8)
 8003506:	46c0      	nop			; (mov r8, r8)
 8003508:	46c0      	nop			; (mov r8, r8)
 800350a:	46c0      	nop			; (mov r8, r8)
 800350c:	46c0      	nop			; (mov r8, r8)
 800350e:	46c0      	nop			; (mov r8, r8)

08003510 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8003510:	b510      	push	{r4, lr}
 8003512:	1c04      	adds	r4, r0, #0

  chMsgSend(p, 'A');
 8003514:	2141      	movs	r1, #65	; 0x41
 8003516:	f7fd fb3b 	bl	8000b90 <chMsgSend>
  chMsgSend(p, 'B');
 800351a:	1c20      	adds	r0, r4, #0
 800351c:	2142      	movs	r1, #66	; 0x42
 800351e:	f7fd fb37 	bl	8000b90 <chMsgSend>
  chMsgSend(p, 'C');
 8003522:	1c20      	adds	r0, r4, #0
 8003524:	2143      	movs	r1, #67	; 0x43
 8003526:	f7fd fb33 	bl	8000b90 <chMsgSend>
}
 800352a:	bd10      	pop	{r4, pc}
 800352c:	46c0      	nop			; (mov r8, r8)
 800352e:	46c0      	nop			; (mov r8, r8)

08003530 <msg1_execute.lto_priv.100>:
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8003530:	21a4      	movs	r1, #164	; 0xa4
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 8003532:	b510      	push	{r4, lr}
 8003534:	4b19      	ldr	r3, [pc, #100]	; (800359c <msg1_execute.lto_priv.100+0x6c>)
 8003536:	b082      	sub	sp, #8
 8003538:	699b      	ldr	r3, [r3, #24]
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800353a:	0049      	lsls	r1, r1, #1
 800353c:	689a      	ldr	r2, [r3, #8]
 800353e:	4818      	ldr	r0, [pc, #96]	; (80035a0 <msg1_execute.lto_priv.100+0x70>)
 8003540:	3201      	adds	r2, #1
 8003542:	9300      	str	r3, [sp, #0]
 8003544:	4b17      	ldr	r3, [pc, #92]	; (80035a4 <msg1_execute.lto_priv.100+0x74>)
 8003546:	f7fd fa3b 	bl	80009c0 <chThdCreateStatic>
 800354a:	4b17      	ldr	r3, [pc, #92]	; (80035a8 <msg1_execute.lto_priv.100+0x78>)
 800354c:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800354e:	f7fd fa77 	bl	8000a40 <chMsgWait>
 8003552:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003554:	b672      	cpsid	i
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8003556:	1c21      	adds	r1, r4, #0
 8003558:	f7fd f9c2 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800355c:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 800355e:	b2e0      	uxtb	r0, r4
 8003560:	f7fd f866 	bl	8000630 <test_emit_token>
  tp = chMsgWait();
 8003564:	f7fd fa6c 	bl	8000a40 <chMsgWait>
 8003568:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800356a:	b672      	cpsid	i
 800356c:	1c21      	adds	r1, r4, #0
 800356e:	f7fd f9b7 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003572:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8003574:	b2e0      	uxtb	r0, r4
 8003576:	f7fd f85b 	bl	8000630 <test_emit_token>
  tp = chMsgWait();
 800357a:	f7fd fa61 	bl	8000a40 <chMsgWait>
 800357e:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003580:	b672      	cpsid	i
 8003582:	1c21      	adds	r1, r4, #0
 8003584:	f7fd f9ac 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003588:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 800358a:	b2e0      	uxtb	r0, r4
 800358c:	f7fd f850 	bl	8000630 <test_emit_token>
  test_assert_sequence(1, "ABC");
 8003590:	4906      	ldr	r1, [pc, #24]	; (80035ac <msg1_execute.lto_priv.100+0x7c>)
 8003592:	2001      	movs	r0, #1
 8003594:	f7fd f804 	bl	80005a0 <_test_assert_sequence>
}
 8003598:	b002      	add	sp, #8
 800359a:	bd10      	pop	{r4, pc}
 800359c:	20000f20 	.word	0x20000f20
 80035a0:	200006c0 	.word	0x200006c0
 80035a4:	08003511 	.word	0x08003511
 80035a8:	20001090 	.word	0x20001090
 80035ac:	080061e0 	.word	0x080061e0

080035b0 <mtx8_execute.lto_priv.99>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80035b0:	b5f0      	push	{r4, r5, r6, r7, lr}

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80035b2:	27a4      	movs	r7, #164	; 0xa4
 80035b4:	4b17      	ldr	r3, [pc, #92]	; (8003614 <mtx8_execute.lto_priv.99+0x64>)
 80035b6:	4d18      	ldr	r5, [pc, #96]	; (8003618 <mtx8_execute.lto_priv.99+0x68>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80035b8:	699b      	ldr	r3, [r3, #24]
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80035ba:	b083      	sub	sp, #12
 80035bc:	689c      	ldr	r4, [r3, #8]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80035be:	4b17      	ldr	r3, [pc, #92]	; (800361c <mtx8_execute.lto_priv.99+0x6c>)
 80035c0:	007f      	lsls	r7, r7, #1
 80035c2:	1c62      	adds	r2, r4, #1
 80035c4:	9300      	str	r3, [sp, #0]
 80035c6:	1c39      	adds	r1, r7, #0
 80035c8:	1c28      	adds	r0, r5, #0
 80035ca:	4b15      	ldr	r3, [pc, #84]	; (8003620 <mtx8_execute.lto_priv.99+0x70>)
 80035cc:	f7fd f9f8 	bl	80009c0 <chThdCreateStatic>
 80035d0:	4e14      	ldr	r6, [pc, #80]	; (8003624 <mtx8_execute.lto_priv.99+0x74>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80035d2:	4b15      	ldr	r3, [pc, #84]	; (8003628 <mtx8_execute.lto_priv.99+0x78>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80035d4:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80035d6:	1ca2      	adds	r2, r4, #2
 80035d8:	9300      	str	r3, [sp, #0]
 80035da:	1c39      	adds	r1, r7, #0
 80035dc:	19e8      	adds	r0, r5, r7
 80035de:	4b13      	ldr	r3, [pc, #76]	; (800362c <mtx8_execute.lto_priv.99+0x7c>)
 80035e0:	f7fd f9ee 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80035e4:	23a4      	movs	r3, #164	; 0xa4
 80035e6:	009b      	lsls	r3, r3, #2

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80035e8:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80035ea:	18e8      	adds	r0, r5, r3
 80035ec:	4b10      	ldr	r3, [pc, #64]	; (8003630 <mtx8_execute.lto_priv.99+0x80>)
 80035ee:	1ce2      	adds	r2, r4, #3
 80035f0:	1c39      	adds	r1, r7, #0
 80035f2:	9300      	str	r3, [sp, #0]
 80035f4:	4b0f      	ldr	r3, [pc, #60]	; (8003634 <mtx8_execute.lto_priv.99+0x84>)
 80035f6:	f7fd f9e3 	bl	80009c0 <chThdCreateStatic>
 80035fa:	60b0      	str	r0, [r6, #8]
  chCondSignal(&c1);
 80035fc:	f7ff f840 	bl	8002680 <chCondSignal.constprop.48>
  chCondSignal(&c1);
 8003600:	f7ff f83e 	bl	8002680 <chCondSignal.constprop.48>
  test_wait_threads();
 8003604:	f7fd fd1c 	bl	8001040 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 8003608:	490b      	ldr	r1, [pc, #44]	; (8003638 <mtx8_execute.lto_priv.99+0x88>)
 800360a:	2001      	movs	r0, #1
 800360c:	f7fc ffc8 	bl	80005a0 <_test_assert_sequence>
}
 8003610:	b003      	add	sp, #12
 8003612:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003614:	20000f20 	.word	0x20000f20
 8003618:	200006c0 	.word	0x200006c0
 800361c:	080055f4 	.word	0x080055f4
 8003620:	08003661 	.word	0x08003661
 8003624:	20001090 	.word	0x20001090
 8003628:	080055fc 	.word	0x080055fc
 800362c:	080036f1 	.word	0x080036f1
 8003630:	080055f0 	.word	0x080055f0
 8003634:	08003641 	.word	0x08003641
 8003638:	080061e0 	.word	0x080061e0
 800363c:	46c0      	nop			; (mov r8, r8)
 800363e:	46c0      	nop			; (mov r8, r8)

08003640 <thread12>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 8003640:	b538      	push	{r3, r4, r5, lr}
 8003642:	1c05      	adds	r5, r0, #0

  chMtxLock(&m2);
 8003644:	4c05      	ldr	r4, [pc, #20]	; (800365c <thread12+0x1c>)
 8003646:	1c20      	adds	r0, r4, #0
 8003648:	f7fd fc42 	bl	8000ed0 <chMtxLock>
  test_emit_token(*(char *)p);
 800364c:	7828      	ldrb	r0, [r5, #0]
 800364e:	f7fc ffef 	bl	8000630 <test_emit_token>
  chMtxUnlock(&m2);
 8003652:	1c20      	adds	r0, r4, #0
 8003654:	f7fd f96c 	bl	8000930 <chMtxUnlock>
}
 8003658:	bd38      	pop	{r3, r4, r5, pc}
 800365a:	46c0      	nop			; (mov r8, r8)
 800365c:	2000064c 	.word	0x2000064c

08003660 <thread11>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8003660:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003662:	4647      	mov	r7, r8

  chMtxLock(&m2);
 8003664:	4d1d      	ldr	r5, [pc, #116]	; (80036dc <thread11+0x7c>)
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8003666:	b480      	push	{r7}
 8003668:	4680      	mov	r8, r0

  chMtxLock(&m2);
 800366a:	1c28      	adds	r0, r5, #0
 800366c:	f7fd fc30 	bl	8000ed0 <chMtxLock>
  chMtxLock(&m1);
 8003670:	4e1b      	ldr	r6, [pc, #108]	; (80036e0 <thread11+0x80>)
 8003672:	1c30      	adds	r0, r6, #0
 8003674:	f7fd fc2c 	bl	8000ed0 <chMtxLock>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003678:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800367a:	4c1a      	ldr	r4, [pc, #104]	; (80036e4 <thread11+0x84>)
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 800367c:	69a3      	ldr	r3, [r4, #24]
 800367e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8003680:	1c38      	adds	r0, r7, #0
 8003682:	f7fd fb95 	bl	8000db0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8003686:	4918      	ldr	r1, [pc, #96]	; (80036e8 <thread11+0x88>)
 8003688:	69a2      	ldr	r2, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800368a:	1c0b      	adds	r3, r1, #0
 800368c:	6211      	str	r1, [r2, #32]
 800368e:	e004      	b.n	800369a <thread11+0x3a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8003690:	6898      	ldr	r0, [r3, #8]
 8003692:	4684      	mov	ip, r0
 8003694:	6890      	ldr	r0, [r2, #8]
 8003696:	4584      	cmp	ip, r0
 8003698:	d302      	bcc.n	80036a0 <thread11+0x40>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800369a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800369c:	428b      	cmp	r3, r1
 800369e:	d1f7      	bne.n	8003690 <thread11+0x30>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80036a0:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80036a2:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 80036a4:	6051      	str	r1, [r2, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80036a6:	2007      	movs	r0, #7
  tp->p_prev->p_next = tp;
 80036a8:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 80036aa:	605a      	str	r2, [r3, #4]
 80036ac:	f7fd f9b8 	bl	8000a20 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 80036b0:	69a3      	ldr	r3, [r4, #24]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 80036b2:	6a1b      	ldr	r3, [r3, #32]
 80036b4:	3301      	adds	r3, #1
 80036b6:	d002      	beq.n	80036be <thread11+0x5e>
    chMtxLockS(mp);
 80036b8:	1c38      	adds	r0, r7, #0
 80036ba:	f7fd fba1 	bl	8000e00 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036be:	b662      	cpsie	i
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 80036c0:	4643      	mov	r3, r8
 80036c2:	7818      	ldrb	r0, [r3, #0]
 80036c4:	f7fc ffb4 	bl	8000630 <test_emit_token>
  chMtxUnlock(&m1);
 80036c8:	1c30      	adds	r0, r6, #0
 80036ca:	f7fd f931 	bl	8000930 <chMtxUnlock>
  chMtxUnlock(&m2);
 80036ce:	1c28      	adds	r0, r5, #0
 80036d0:	f7fd f92e 	bl	8000930 <chMtxUnlock>
}
 80036d4:	bc04      	pop	{r2}
 80036d6:	4690      	mov	r8, r2
 80036d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036da:	46c0      	nop			; (mov r8, r8)
 80036dc:	2000064c 	.word	0x2000064c
 80036e0:	2000063c 	.word	0x2000063c
 80036e4:	20000f20 	.word	0x20000f20
 80036e8:	20000634 	.word	0x20000634
 80036ec:	46c0      	nop			; (mov r8, r8)
 80036ee:	46c0      	nop			; (mov r8, r8)

080036f0 <thread10>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 80036f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chMtxLock(&m1);
 80036f2:	4d15      	ldr	r5, [pc, #84]	; (8003748 <thread10+0x58>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 80036f4:	1c07      	adds	r7, r0, #0

  chMtxLock(&m1);
 80036f6:	1c28      	adds	r0, r5, #0
 80036f8:	f7fd fbea 	bl	8000ed0 <chMtxLock>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80036fc:	b672      	cpsid	i
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 80036fe:	4b13      	ldr	r3, [pc, #76]	; (800374c <thread10+0x5c>)
 8003700:	699c      	ldr	r4, [r3, #24]
 8003702:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8003704:	1c30      	adds	r0, r6, #0
 8003706:	f7fd fb53 	bl	8000db0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 800370a:	4a11      	ldr	r2, [pc, #68]	; (8003750 <thread10+0x60>)
 800370c:	6222      	str	r2, [r4, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800370e:	1c13      	adds	r3, r2, #0
 8003710:	e003      	b.n	800371a <thread10+0x2a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8003712:	6899      	ldr	r1, [r3, #8]
 8003714:	68a0      	ldr	r0, [r4, #8]
 8003716:	4281      	cmp	r1, r0
 8003718:	d302      	bcc.n	8003720 <thread10+0x30>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800371a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800371c:	4293      	cmp	r3, r2
 800371e:	d1f8      	bne.n	8003712 <thread10+0x22>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003720:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8003722:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8003724:	6062      	str	r2, [r4, #4]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8003726:	2007      	movs	r0, #7
  tp->p_prev->p_next = tp;
 8003728:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800372a:	605c      	str	r4, [r3, #4]
 800372c:	f7fd f978 	bl	8000a20 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
  chMtxLockS(mp);
 8003730:	1c30      	adds	r0, r6, #0
 8003732:	f7fd fb65 	bl	8000e00 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003736:	b662      	cpsie	i
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8003738:	7838      	ldrb	r0, [r7, #0]
 800373a:	f7fc ff79 	bl	8000630 <test_emit_token>
  chMtxUnlock(&m1);
 800373e:	1c28      	adds	r0, r5, #0
 8003740:	f7fd f8f6 	bl	8000930 <chMtxUnlock>
}
 8003744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003746:	46c0      	nop			; (mov r8, r8)
 8003748:	2000063c 	.word	0x2000063c
 800374c:	20000f20 	.word	0x20000f20
 8003750:	20000634 	.word	0x20000634
 8003754:	46c0      	nop			; (mov r8, r8)
 8003756:	46c0      	nop			; (mov r8, r8)
 8003758:	46c0      	nop			; (mov r8, r8)
 800375a:	46c0      	nop			; (mov r8, r8)
 800375c:	46c0      	nop			; (mov r8, r8)
 800375e:	46c0      	nop			; (mov r8, r8)

08003760 <mtx7_execute.lto_priv.97>:
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003760:	21a4      	movs	r1, #164	; 0xa4

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8003762:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003764:	4b2d      	ldr	r3, [pc, #180]	; (800381c <mtx7_execute.lto_priv.97+0xbc>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003766:	4d2e      	ldr	r5, [pc, #184]	; (8003820 <mtx7_execute.lto_priv.97+0xc0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003768:	699b      	ldr	r3, [r3, #24]
 800376a:	4f2e      	ldr	r7, [pc, #184]	; (8003824 <mtx7_execute.lto_priv.97+0xc4>)
 800376c:	689c      	ldr	r4, [r3, #8]
 800376e:	4b2e      	ldr	r3, [pc, #184]	; (8003828 <mtx7_execute.lto_priv.97+0xc8>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8003770:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003772:	1c62      	adds	r2, r4, #1
 8003774:	9300      	str	r3, [sp, #0]
 8003776:	1c28      	adds	r0, r5, #0
 8003778:	1c3b      	adds	r3, r7, #0
 800377a:	0049      	lsls	r1, r1, #1
 800377c:	f7fd f920 	bl	80009c0 <chThdCreateStatic>
 8003780:	4e2a      	ldr	r6, [pc, #168]	; (800382c <mtx7_execute.lto_priv.97+0xcc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003782:	21a4      	movs	r1, #164	; 0xa4
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003784:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003786:	1c28      	adds	r0, r5, #0
 8003788:	4b29      	ldr	r3, [pc, #164]	; (8003830 <mtx7_execute.lto_priv.97+0xd0>)
 800378a:	3049      	adds	r0, #73	; 0x49
 800378c:	1ca2      	adds	r2, r4, #2
 800378e:	9300      	str	r3, [sp, #0]
 8003790:	0049      	lsls	r1, r1, #1
 8003792:	1c3b      	adds	r3, r7, #0
 8003794:	30ff      	adds	r0, #255	; 0xff
 8003796:	f7fd f913 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800379a:	23a4      	movs	r3, #164	; 0xa4
 800379c:	21a4      	movs	r1, #164	; 0xa4
 800379e:	009b      	lsls	r3, r3, #2

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 80037a0:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80037a2:	18e8      	adds	r0, r5, r3
 80037a4:	4b23      	ldr	r3, [pc, #140]	; (8003834 <mtx7_execute.lto_priv.97+0xd4>)
 80037a6:	1ce2      	adds	r2, r4, #3
 80037a8:	9300      	str	r3, [sp, #0]
 80037aa:	0049      	lsls	r1, r1, #1
 80037ac:	1c3b      	adds	r3, r7, #0
 80037ae:	f7fd f907 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80037b2:	23f6      	movs	r3, #246	; 0xf6
 80037b4:	21a4      	movs	r1, #164	; 0xa4
 80037b6:	009b      	lsls	r3, r3, #2
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80037b8:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80037ba:	18e8      	adds	r0, r5, r3
 80037bc:	4b1e      	ldr	r3, [pc, #120]	; (8003838 <mtx7_execute.lto_priv.97+0xd8>)
 80037be:	1d22      	adds	r2, r4, #4
 80037c0:	9300      	str	r3, [sp, #0]
 80037c2:	0049      	lsls	r1, r1, #1
 80037c4:	1c3b      	adds	r3, r7, #0
 80037c6:	f7fd f8fb 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80037ca:	23a4      	movs	r3, #164	; 0xa4
 80037cc:	21a4      	movs	r1, #164	; 0xa4
 80037ce:	00db      	lsls	r3, r3, #3

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80037d0:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80037d2:	18e8      	adds	r0, r5, r3
 80037d4:	4b19      	ldr	r3, [pc, #100]	; (800383c <mtx7_execute.lto_priv.97+0xdc>)
 80037d6:	1d62      	adds	r2, r4, #5
 80037d8:	9300      	str	r3, [sp, #0]
 80037da:	0049      	lsls	r1, r1, #1
 80037dc:	1c3b      	adds	r3, r7, #0
 80037de:	f7fd f8ef 	bl	80009c0 <chThdCreateStatic>
 80037e2:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037e4:	b672      	cpsid	i

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 80037e6:	2502      	movs	r5, #2
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80037e8:	4c15      	ldr	r4, [pc, #84]	; (8003840 <mtx7_execute.lto_priv.97+0xe0>)
 80037ea:	426d      	negs	r5, r5
 80037ec:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 80037ee:	42a0      	cmp	r0, r4
 80037f0:	d008      	beq.n	8003804 <mtx7_execute.lto_priv.97+0xa4>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80037f2:	6803      	ldr	r3, [r0, #0]
 80037f4:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80037f6:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 80037f8:	f7fd f962 	bl	8000ac0 <chSchReadyI>
 80037fc:	6205      	str	r5, [r0, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80037fe:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8003800:	42a0      	cmp	r0, r4
 8003802:	d1f6      	bne.n	80037f2 <mtx7_execute.lto_priv.97+0x92>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8003804:	f7fd f844 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003808:	b662      	cpsie	i
  chCondBroadcast(&c1);
  test_wait_threads();
 800380a:	f7fd fc19 	bl	8001040 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800380e:	490d      	ldr	r1, [pc, #52]	; (8003844 <mtx7_execute.lto_priv.97+0xe4>)
 8003810:	2001      	movs	r0, #1
 8003812:	f7fc fec5 	bl	80005a0 <_test_assert_sequence>
}
 8003816:	b003      	add	sp, #12
 8003818:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800381a:	46c0      	nop			; (mov r8, r8)
 800381c:	20000f20 	.word	0x20000f20
 8003820:	200006c0 	.word	0x200006c0
 8003824:	080036f1 	.word	0x080036f1
 8003828:	08005604 	.word	0x08005604
 800382c:	20001090 	.word	0x20001090
 8003830:	080055f8 	.word	0x080055f8
 8003834:	080055fc 	.word	0x080055fc
 8003838:	080055f0 	.word	0x080055f0
 800383c:	080055f4 	.word	0x080055f4
 8003840:	20000634 	.word	0x20000634
 8003844:	08005600 	.word	0x08005600
 8003848:	46c0      	nop			; (mov r8, r8)
 800384a:	46c0      	nop			; (mov r8, r8)
 800384c:	46c0      	nop			; (mov r8, r8)
 800384e:	46c0      	nop			; (mov r8, r8)

08003850 <mtx6_execute.lto_priv.95>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003850:	4b2c      	ldr	r3, [pc, #176]	; (8003904 <mtx6_execute.lto_priv.95+0xb4>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8003852:	b5f0      	push	{r4, r5, r6, r7, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003854:	699b      	ldr	r3, [r3, #24]
 8003856:	4647      	mov	r7, r8
 8003858:	689c      	ldr	r4, [r3, #8]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800385a:	23a4      	movs	r3, #164	; 0xa4
 800385c:	005b      	lsls	r3, r3, #1
 800385e:	4698      	mov	r8, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8003860:	b480      	push	{r7}

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8003862:	4d29      	ldr	r5, [pc, #164]	; (8003908 <mtx6_execute.lto_priv.95+0xb8>)
 8003864:	4f29      	ldr	r7, [pc, #164]	; (800390c <mtx6_execute.lto_priv.95+0xbc>)
 8003866:	4b2a      	ldr	r3, [pc, #168]	; (8003910 <mtx6_execute.lto_priv.95+0xc0>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8003868:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800386a:	1c62      	adds	r2, r4, #1
 800386c:	9300      	str	r3, [sp, #0]
 800386e:	4641      	mov	r1, r8
 8003870:	1c3b      	adds	r3, r7, #0
 8003872:	1c28      	adds	r0, r5, #0
 8003874:	f7fd f8a4 	bl	80009c0 <chThdCreateStatic>
 8003878:	4e26      	ldr	r6, [pc, #152]	; (8003914 <mtx6_execute.lto_priv.95+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800387a:	4b27      	ldr	r3, [pc, #156]	; (8003918 <mtx6_execute.lto_priv.95+0xc8>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800387c:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800387e:	1c28      	adds	r0, r5, #0
 8003880:	1ca2      	adds	r2, r4, #2
 8003882:	9300      	str	r3, [sp, #0]
 8003884:	4641      	mov	r1, r8
 8003886:	1c3b      	adds	r3, r7, #0
 8003888:	4440      	add	r0, r8
 800388a:	f7fd f899 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800388e:	23a4      	movs	r3, #164	; 0xa4
 8003890:	009b      	lsls	r3, r3, #2

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8003892:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8003894:	18e8      	adds	r0, r5, r3
 8003896:	4b21      	ldr	r3, [pc, #132]	; (800391c <mtx6_execute.lto_priv.95+0xcc>)
 8003898:	1ce2      	adds	r2, r4, #3
 800389a:	9300      	str	r3, [sp, #0]
 800389c:	4641      	mov	r1, r8
 800389e:	1c3b      	adds	r3, r7, #0
 80038a0:	f7fd f88e 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80038a4:	23f6      	movs	r3, #246	; 0xf6
 80038a6:	009b      	lsls	r3, r3, #2
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80038a8:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80038aa:	18e8      	adds	r0, r5, r3
 80038ac:	4b1c      	ldr	r3, [pc, #112]	; (8003920 <mtx6_execute.lto_priv.95+0xd0>)
 80038ae:	1d22      	adds	r2, r4, #4
 80038b0:	9300      	str	r3, [sp, #0]
 80038b2:	4641      	mov	r1, r8
 80038b4:	1c3b      	adds	r3, r7, #0
 80038b6:	f7fd f883 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80038ba:	23a4      	movs	r3, #164	; 0xa4
 80038bc:	00db      	lsls	r3, r3, #3

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80038be:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80038c0:	18e8      	adds	r0, r5, r3
 80038c2:	4b18      	ldr	r3, [pc, #96]	; (8003924 <mtx6_execute.lto_priv.95+0xd4>)
 80038c4:	1d62      	adds	r2, r4, #5
 80038c6:	9300      	str	r3, [sp, #0]
 80038c8:	4641      	mov	r1, r8
 80038ca:	1c3b      	adds	r3, r7, #0
 80038cc:	f7fd f878 	bl	80009c0 <chThdCreateStatic>
 80038d0:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038d2:	b672      	cpsid	i
  chSysLock();
  chCondSignalI(&c1);
 80038d4:	f7fe fee4 	bl	80026a0 <chCondSignalI.constprop.47>
  chCondSignalI(&c1);
 80038d8:	f7fe fee2 	bl	80026a0 <chCondSignalI.constprop.47>
  chCondSignalI(&c1);
 80038dc:	f7fe fee0 	bl	80026a0 <chCondSignalI.constprop.47>
  chCondSignalI(&c1);
 80038e0:	f7fe fede 	bl	80026a0 <chCondSignalI.constprop.47>
  chCondSignalI(&c1);
 80038e4:	f7fe fedc 	bl	80026a0 <chCondSignalI.constprop.47>
  chSchRescheduleS();
 80038e8:	f7fc ffd2 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038ec:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 80038ee:	f7fd fba7 	bl	8001040 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 80038f2:	490d      	ldr	r1, [pc, #52]	; (8003928 <mtx6_execute.lto_priv.95+0xd8>)
 80038f4:	2001      	movs	r0, #1
 80038f6:	f7fc fe53 	bl	80005a0 <_test_assert_sequence>
}
 80038fa:	b002      	add	sp, #8
 80038fc:	bc04      	pop	{r2}
 80038fe:	4690      	mov	r8, r2
 8003900:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003902:	46c0      	nop			; (mov r8, r8)
 8003904:	20000f20 	.word	0x20000f20
 8003908:	200006c0 	.word	0x200006c0
 800390c:	080036f1 	.word	0x080036f1
 8003910:	08005604 	.word	0x08005604
 8003914:	20001090 	.word	0x20001090
 8003918:	080055f8 	.word	0x080055f8
 800391c:	080055fc 	.word	0x080055fc
 8003920:	080055f0 	.word	0x080055f0
 8003924:	080055f4 	.word	0x080055f4
 8003928:	08005600 	.word	0x08005600
 800392c:	46c0      	nop			; (mov r8, r8)
 800392e:	46c0      	nop			; (mov r8, r8)

08003930 <mtx5_execute.lto_priv.93>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8003930:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003932:	4d31      	ldr	r5, [pc, #196]	; (80039f8 <mtx5_execute.lto_priv.93+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003934:	69ab      	ldr	r3, [r5, #24]
 8003936:	689e      	ldr	r6, [r3, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003938:	b672      	cpsid	i
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 800393a:	4c30      	ldr	r4, [pc, #192]	; (80039fc <mtx5_execute.lto_priv.93+0xcc>)
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800393c:	2100      	movs	r1, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 800393e:	68a3      	ldr	r3, [r4, #8]
 8003940:	2b00      	cmp	r3, #0
 8003942:	d04b      	beq.n	80039dc <mtx5_execute.lto_priv.93+0xac>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003944:	b662      	cpsie	i
#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");
 8003946:	2001      	movs	r0, #1
 8003948:	f7fc fe5a 	bl	8000600 <_test_assert>
 800394c:	1e01      	subs	r1, r0, #0
 800394e:	d000      	beq.n	8003952 <mtx5_execute.lto_priv.93+0x22>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
}
 8003950:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003952:	b672      	cpsid	i
 8003954:	68a3      	ldr	r3, [r4, #8]
 8003956:	2b00      	cmp	r3, #0
 8003958:	d047      	beq.n	80039ea <mtx5_execute.lto_priv.93+0xba>
 800395a:	2101      	movs	r1, #1
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800395c:	b662      	cpsie	i

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
  test_assert(2, !b, "not locked");
 800395e:	2002      	movs	r0, #2
 8003960:	f7fc fe4e 	bl	8000600 <_test_assert>
 8003964:	2800      	cmp	r0, #0
 8003966:	d1f3      	bne.n	8003950 <mtx5_execute.lto_priv.93+0x20>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003968:	b672      	cpsid	i

  chSysLock();
  chMtxUnlockS(&m1);
 800396a:	1c20      	adds	r0, r4, #0
 800396c:	f7fd fa20 	bl	8000db0 <chMtxUnlockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003970:	b662      	cpsie	i
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8003972:	6823      	ldr	r3, [r4, #0]
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8003974:	2003      	movs	r0, #3
 8003976:	1b19      	subs	r1, r3, r4
 8003978:	424a      	negs	r2, r1
 800397a:	414a      	adcs	r2, r1
 800397c:	b2d1      	uxtb	r1, r2
 800397e:	f7fc fe3f 	bl	8000600 <_test_assert>
 8003982:	2800      	cmp	r0, #0
 8003984:	d1e4      	bne.n	8003950 <mtx5_execute.lto_priv.93+0x20>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8003986:	68a1      	ldr	r1, [r4, #8]
 8003988:	3004      	adds	r0, #4
 800398a:	424b      	negs	r3, r1
 800398c:	4159      	adcs	r1, r3
 800398e:	b2c9      	uxtb	r1, r1
 8003990:	f7fc fe36 	bl	8000600 <_test_assert>
 8003994:	2800      	cmp	r0, #0
 8003996:	d1db      	bne.n	8003950 <mtx5_execute.lto_priv.93+0x20>
 8003998:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800399a:	3005      	adds	r0, #5
 800399c:	6899      	ldr	r1, [r3, #8]
 800399e:	1a71      	subs	r1, r6, r1
 80039a0:	424b      	negs	r3, r1
 80039a2:	414b      	adcs	r3, r1
 80039a4:	b2d9      	uxtb	r1, r3
 80039a6:	f7fc fe2b 	bl	8000600 <_test_assert>
 80039aa:	2800      	cmp	r0, #0
 80039ac:	d1d0      	bne.n	8003950 <mtx5_execute.lto_priv.93+0x20>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 80039ae:	1c20      	adds	r0, r4, #0
 80039b0:	f7fd fa8e 	bl	8000ed0 <chMtxLock>
  chMtxUnlockAll();
 80039b4:	f7fd f9d4 	bl	8000d60 <chMtxUnlockAll>
 80039b8:	6823      	ldr	r3, [r4, #0]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 80039ba:	2006      	movs	r0, #6
 80039bc:	1b19      	subs	r1, r3, r4
 80039be:	424a      	negs	r2, r1
 80039c0:	414a      	adcs	r2, r1
 80039c2:	b2d1      	uxtb	r1, r2
 80039c4:	f7fc fe1c 	bl	8000600 <_test_assert>
 80039c8:	2800      	cmp	r0, #0
 80039ca:	d1c1      	bne.n	8003950 <mtx5_execute.lto_priv.93+0x20>
  test_assert(7, m1.m_owner == NULL, "still owned");
 80039cc:	68a3      	ldr	r3, [r4, #8]
 80039ce:	3007      	adds	r0, #7
 80039d0:	4259      	negs	r1, r3
 80039d2:	4159      	adcs	r1, r3
 80039d4:	b2c9      	uxtb	r1, r1
 80039d6:	f7fc fe13 	bl	8000600 <_test_assert>
 80039da:	e7b9      	b.n	8003950 <mtx5_execute.lto_priv.93+0x20>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80039dc:	69ab      	ldr	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
 80039de:	3101      	adds	r1, #1
  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
  mp->m_next = currp->p_mtxlist;
 80039e0:	6b9a      	ldr	r2, [r3, #56]	; 0x38

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80039e2:	60a3      	str	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
 80039e4:	60e2      	str	r2, [r4, #12]
  currp->p_mtxlist = mp;
 80039e6:	639c      	str	r4, [r3, #56]	; 0x38
 80039e8:	e7ac      	b.n	8003944 <mtx5_execute.lto_priv.93+0x14>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80039ea:	69ab      	ldr	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
 80039ec:	6b9a      	ldr	r2, [r3, #56]	; 0x38

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80039ee:	60a3      	str	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
 80039f0:	60e2      	str	r2, [r4, #12]
  currp->p_mtxlist = mp;
 80039f2:	639c      	str	r4, [r3, #56]	; 0x38
 80039f4:	e7b2      	b.n	800395c <mtx5_execute.lto_priv.93+0x2c>
 80039f6:	46c0      	nop			; (mov r8, r8)
 80039f8:	20000f20 	.word	0x20000f20
 80039fc:	2000063c 	.word	0x2000063c

08003a00 <bmk12_setup.lto_priv.136>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8003a00:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a02:	4b02      	ldr	r3, [pc, #8]	; (8003a0c <bmk12_setup.lto_priv.136+0xc>)
 8003a04:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003a06:	605b      	str	r3, [r3, #4]
 8003a08:	609a      	str	r2, [r3, #8]
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}
 8003a0a:	4770      	bx	lr
 8003a0c:	200010e4 	.word	0x200010e4

08003a10 <bmk11_setup.lto_priv.134>:
 8003a10:	2201      	movs	r2, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a12:	4b02      	ldr	r3, [pc, #8]	; (8003a1c <bmk11_setup.lto_priv.134+0xc>)
 8003a14:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003a16:	605b      	str	r3, [r3, #4]
 8003a18:	609a      	str	r2, [r3, #8]
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}
 8003a1a:	4770      	bx	lr
 8003a1c:	20001128 	.word	0x20001128

08003a20 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8003a20:	4770      	bx	lr
 8003a22:	46c0      	nop			; (mov r8, r8)
 8003a24:	46c0      	nop			; (mov r8, r8)
 8003a26:	46c0      	nop			; (mov r8, r8)
 8003a28:	46c0      	nop			; (mov r8, r8)
 8003a2a:	46c0      	nop			; (mov r8, r8)
 8003a2c:	46c0      	nop			; (mov r8, r8)
 8003a2e:	46c0      	nop			; (mov r8, r8)

08003a30 <bmk7_setup.lto_priv.129>:
 8003a30:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a32:	4b02      	ldr	r3, [pc, #8]	; (8003a3c <bmk7_setup.lto_priv.129+0xc>)
 8003a34:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003a36:	605b      	str	r3, [r3, #4]
 8003a38:	609a      	str	r2, [r3, #8]
}

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 8003a3a:	4770      	bx	lr
 8003a3c:	20001128 	.word	0x20001128

08003a40 <sys2_execute.lto_priv.75>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a40:	b672      	cpsid	i
 8003a42:	b672      	cpsid	i
 8003a44:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a46:	b662      	cpsie	i

  chSysSuspend();
  chSysDisable();
  chSysSuspend();
  chSysEnable();
}
 8003a48:	4770      	bx	lr
 8003a4a:	46c0      	nop			; (mov r8, r8)
 8003a4c:	46c0      	nop			; (mov r8, r8)
 8003a4e:	46c0      	nop			; (mov r8, r8)

08003a50 <bmk12_execute.lto_priv.137>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 8003a50:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;
 8003a52:	2500      	movs	r5, #0

  test_wait_tick();
 8003a54:	f7fd fd94 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003a58:	f7fe ff32 	bl	80028c0 <test_start_timer.constprop.2>
 8003a5c:	4c13      	ldr	r4, [pc, #76]	; (8003aac <bmk12_execute.lto_priv.137+0x5c>)
 8003a5e:	4e14      	ldr	r6, [pc, #80]	; (8003ab0 <bmk12_execute.lto_priv.137+0x60>)
  do {
    chMtxLock(&mtx1);
 8003a60:	1c20      	adds	r0, r4, #0
 8003a62:	f7fd fa35 	bl	8000ed0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8003a66:	1c20      	adds	r0, r4, #0
 8003a68:	f7fc ff62 	bl	8000930 <chMtxUnlock>
    chMtxLock(&mtx1);
 8003a6c:	1c20      	adds	r0, r4, #0
 8003a6e:	f7fd fa2f 	bl	8000ed0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8003a72:	1c20      	adds	r0, r4, #0
 8003a74:	f7fc ff5c 	bl	8000930 <chMtxUnlock>
    chMtxLock(&mtx1);
 8003a78:	1c20      	adds	r0, r4, #0
 8003a7a:	f7fd fa29 	bl	8000ed0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8003a7e:	1c20      	adds	r0, r4, #0
 8003a80:	f7fc ff56 	bl	8000930 <chMtxUnlock>
    chMtxLock(&mtx1);
 8003a84:	1c20      	adds	r0, r4, #0
 8003a86:	f7fd fa23 	bl	8000ed0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8003a8a:	1c20      	adds	r0, r4, #0
 8003a8c:	f7fc ff50 	bl	8000930 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003a90:	7833      	ldrb	r3, [r6, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 8003a92:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003a94:	2b00      	cmp	r3, #0
 8003a96:	d0e3      	beq.n	8003a60 <bmk12_execute.lto_priv.137+0x10>
  test_print("--- Score : ");
 8003a98:	4806      	ldr	r0, [pc, #24]	; (8003ab4 <bmk12_execute.lto_priv.137+0x64>)
 8003a9a:	f7fc fe01 	bl	80006a0 <test_print>
  test_printn(n * 4);
 8003a9e:	00a8      	lsls	r0, r5, #2
 8003aa0:	f7fc fe16 	bl	80006d0 <test_printn>
  test_println(" lock+unlock/S");
 8003aa4:	4804      	ldr	r0, [pc, #16]	; (8003ab8 <bmk12_execute.lto_priv.137+0x68>)
 8003aa6:	f7fc fddb 	bl	8000660 <test_println>
}
 8003aaa:	bd70      	pop	{r4, r5, r6, pc}
 8003aac:	200010e4 	.word	0x200010e4
 8003ab0:	20000e96 	.word	0x20000e96
 8003ab4:	080061f0 	.word	0x080061f0
 8003ab8:	08006200 	.word	0x08006200
 8003abc:	46c0      	nop			; (mov r8, r8)
 8003abe:	46c0      	nop			; (mov r8, r8)

08003ac0 <bmk11_execute.lto_priv.135>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8003ac0:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;
 8003ac2:	2500      	movs	r5, #0

  test_wait_tick();
 8003ac4:	f7fd fd5c 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003ac8:	f7fe fefa 	bl	80028c0 <test_start_timer.constprop.2>
 8003acc:	4c13      	ldr	r4, [pc, #76]	; (8003b1c <bmk11_execute.lto_priv.135+0x5c>)
 8003ace:	4e14      	ldr	r6, [pc, #80]	; (8003b20 <bmk11_execute.lto_priv.135+0x60>)
  do {
    chSemWait(&sem1);
 8003ad0:	1c20      	adds	r0, r4, #0
 8003ad2:	f7fc ffd5 	bl	8000a80 <chSemWait>
    chSemSignal(&sem1);
 8003ad6:	1c20      	adds	r0, r4, #0
 8003ad8:	f7fc ff5a 	bl	8000990 <chSemSignal>
    chSemWait(&sem1);
 8003adc:	1c20      	adds	r0, r4, #0
 8003ade:	f7fc ffcf 	bl	8000a80 <chSemWait>
    chSemSignal(&sem1);
 8003ae2:	1c20      	adds	r0, r4, #0
 8003ae4:	f7fc ff54 	bl	8000990 <chSemSignal>
    chSemWait(&sem1);
 8003ae8:	1c20      	adds	r0, r4, #0
 8003aea:	f7fc ffc9 	bl	8000a80 <chSemWait>
    chSemSignal(&sem1);
 8003aee:	1c20      	adds	r0, r4, #0
 8003af0:	f7fc ff4e 	bl	8000990 <chSemSignal>
    chSemWait(&sem1);
 8003af4:	1c20      	adds	r0, r4, #0
 8003af6:	f7fc ffc3 	bl	8000a80 <chSemWait>
    chSemSignal(&sem1);
 8003afa:	1c20      	adds	r0, r4, #0
 8003afc:	f7fc ff48 	bl	8000990 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003b00:	7833      	ldrb	r3, [r6, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 8003b02:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003b04:	2b00      	cmp	r3, #0
 8003b06:	d0e3      	beq.n	8003ad0 <bmk11_execute.lto_priv.135+0x10>
  test_print("--- Score : ");
 8003b08:	4806      	ldr	r0, [pc, #24]	; (8003b24 <bmk11_execute.lto_priv.135+0x64>)
 8003b0a:	f7fc fdc9 	bl	80006a0 <test_print>
  test_printn(n * 4);
 8003b0e:	00a8      	lsls	r0, r5, #2
 8003b10:	f7fc fdde 	bl	80006d0 <test_printn>
  test_println(" wait+signal/S");
 8003b14:	4804      	ldr	r0, [pc, #16]	; (8003b28 <bmk11_execute.lto_priv.135+0x68>)
 8003b16:	f7fc fda3 	bl	8000660 <test_println>
}
 8003b1a:	bd70      	pop	{r4, r5, r6, pc}
 8003b1c:	20001128 	.word	0x20001128
 8003b20:	20000e96 	.word	0x20000e96
 8003b24:	080061f0 	.word	0x080061f0
 8003b28:	08006210 	.word	0x08006210
 8003b2c:	46c0      	nop			; (mov r8, r8)
 8003b2e:	46c0      	nop			; (mov r8, r8)

08003b30 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8003b30:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003b32:	4c07      	ldr	r4, [pc, #28]	; (8003b50 <thread3+0x20>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003b34:	69a3      	ldr	r3, [r4, #24]
 8003b36:	7f5b      	ldrb	r3, [r3, #29]

  (void)p;
  while (!chThdShouldTerminateX())
 8003b38:	075b      	lsls	r3, r3, #29
 8003b3a:	d408      	bmi.n	8003b4e <thread3+0x1e>
 8003b3c:	2504      	movs	r5, #4
 8003b3e:	4e05      	ldr	r6, [pc, #20]	; (8003b54 <thread3+0x24>)
    chSemWait(&sem1);
 8003b40:	1c30      	adds	r0, r6, #0
 8003b42:	f7fc ff9d 	bl	8000a80 <chSemWait>
 8003b46:	69a3      	ldr	r3, [r4, #24]
 8003b48:	7f5b      	ldrb	r3, [r3, #29]
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8003b4a:	421d      	tst	r5, r3
 8003b4c:	d0f8      	beq.n	8003b40 <thread3+0x10>
    chSemWait(&sem1);
}
 8003b4e:	bd70      	pop	{r4, r5, r6, pc}
 8003b50:	20000f20 	.word	0x20000f20
 8003b54:	20001128 	.word	0x20001128
 8003b58:	46c0      	nop			; (mov r8, r8)
 8003b5a:	46c0      	nop			; (mov r8, r8)
 8003b5c:	46c0      	nop			; (mov r8, r8)
 8003b5e:	46c0      	nop			; (mov r8, r8)

08003b60 <bmk10_execute.lto_priv.133>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 8003b60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b62:	4647      	mov	r7, r8
 8003b64:	b480      	push	{r7}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 8003b66:	f7fd fd0b 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003b6a:	f7fe fea9 	bl	80028c0 <test_start_timer.constprop.2>
 8003b6e:	4b15      	ldr	r3, [pc, #84]	; (8003bc4 <bmk10_execute.lto_priv.133+0x64>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8003b70:	2400      	movs	r4, #0
 8003b72:	4698      	mov	r8, r3
 8003b74:	4f14      	ldr	r7, [pc, #80]	; (8003bc8 <bmk10_execute.lto_priv.133+0x68>)
 8003b76:	4e15      	ldr	r6, [pc, #84]	; (8003bcc <bmk10_execute.lto_priv.133+0x6c>)
 8003b78:	4d15      	ldr	r5, [pc, #84]	; (8003bd0 <bmk10_execute.lto_priv.133+0x70>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b7a:	b672      	cpsid	i

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8003b7c:	2101      	movs	r1, #1
 8003b7e:	1c38      	adds	r0, r7, #0
 8003b80:	1c32      	adds	r2, r6, #0
 8003b82:	2300      	movs	r3, #0
 8003b84:	f7fd fb4c 	bl	8001220 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8003b88:	4912      	ldr	r1, [pc, #72]	; (8003bd4 <bmk10_execute.lto_priv.133+0x74>)
 8003b8a:	1c32      	adds	r2, r6, #0
 8003b8c:	2300      	movs	r3, #0
 8003b8e:	1c28      	adds	r0, r5, #0
 8003b90:	f7fd fb46 	bl	8001220 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8003b94:	1c38      	adds	r0, r7, #0
 8003b96:	f7fd fb03 	bl	80011a0 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8003b9a:	1c28      	adds	r0, r5, #0
 8003b9c:	f7fd fb00 	bl	80011a0 <chVTDoResetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ba0:	b662      	cpsie	i
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003ba2:	4643      	mov	r3, r8
 8003ba4:	781b      	ldrb	r3, [r3, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8003ba6:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003ba8:	2b00      	cmp	r3, #0
 8003baa:	d0e6      	beq.n	8003b7a <bmk10_execute.lto_priv.133+0x1a>
  test_print("--- Score : ");
 8003bac:	480a      	ldr	r0, [pc, #40]	; (8003bd8 <bmk10_execute.lto_priv.133+0x78>)
 8003bae:	f7fc fd77 	bl	80006a0 <test_print>
  test_printn(n * 2);
 8003bb2:	0060      	lsls	r0, r4, #1
 8003bb4:	f7fc fd8c 	bl	80006d0 <test_printn>
  test_println(" timers/S");
 8003bb8:	4808      	ldr	r0, [pc, #32]	; (8003bdc <bmk10_execute.lto_priv.133+0x7c>)
 8003bba:	f7fc fd51 	bl	8000660 <test_println>
}
 8003bbe:	bc04      	pop	{r2}
 8003bc0:	4690      	mov	r8, r2
 8003bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003bc4:	20000e96 	.word	0x20000e96
 8003bc8:	200010d0 	.word	0x200010d0
 8003bcc:	08003a21 	.word	0x08003a21
 8003bd0:	20001134 	.word	0x20001134
 8003bd4:	00002710 	.word	0x00002710
 8003bd8:	080061f0 	.word	0x080061f0
 8003bdc:	08006220 	.word	0x08006220

08003be0 <bmk9_execute.lto_priv.132>:
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003be0:	2200      	movs	r2, #0
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8003be2:	b570      	push	{r4, r5, r6, lr}
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
 8003be4:	2500      	movs	r5, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003be6:	4c20      	ldr	r4, [pc, #128]	; (8003c68 <bmk9_execute.lto_priv.132+0x88>)
  iqp->q_buffer  = bp;
 8003be8:	4b20      	ldr	r3, [pc, #128]	; (8003c6c <bmk9_execute.lto_priv.132+0x8c>)
 8003bea:	6024      	str	r4, [r4, #0]
 8003bec:	60e3      	str	r3, [r4, #12]
  iqp->q_rdptr   = bp;
 8003bee:	61a3      	str	r3, [r4, #24]
  iqp->q_wrptr   = bp;
 8003bf0:	6163      	str	r3, [r4, #20]
  tqp->p_prev = (thread_t *)tqp;
 8003bf2:	6064      	str	r4, [r4, #4]
  iqp->q_top     = bp + size;
 8003bf4:	3310      	adds	r3, #16
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003bf6:	60a2      	str	r2, [r4, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8003bf8:	6123      	str	r3, [r4, #16]
  iqp->q_notify  = infy;
 8003bfa:	61e2      	str	r2, [r4, #28]
  iqp->q_link    = link;
 8003bfc:	6222      	str	r2, [r4, #32]
  test_wait_tick();
 8003bfe:	f7fd fcbf 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003c02:	f7fe fe5d 	bl	80028c0 <test_start_timer.constprop.2>
 8003c06:	4e1a      	ldr	r6, [pc, #104]	; (8003c70 <bmk9_execute.lto_priv.132+0x90>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003c08:	b672      	cpsid	i
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 8003c0a:	2100      	movs	r1, #0
 8003c0c:	1c20      	adds	r0, r4, #0
 8003c0e:	f7fc ff67 	bl	8000ae0 <chIQPutI>
    chIQPutI(&iq, 1);
 8003c12:	1c20      	adds	r0, r4, #0
 8003c14:	2101      	movs	r1, #1
 8003c16:	f7fc ff63 	bl	8000ae0 <chIQPutI>
    chIQPutI(&iq, 2);
 8003c1a:	1c20      	adds	r0, r4, #0
 8003c1c:	2102      	movs	r1, #2
 8003c1e:	f7fc ff5f 	bl	8000ae0 <chIQPutI>
    chIQPutI(&iq, 3);
 8003c22:	1c20      	adds	r0, r4, #0
 8003c24:	2103      	movs	r1, #3
 8003c26:	f7fc ff5b 	bl	8000ae0 <chIQPutI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003c2a:	b662      	cpsie	i
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8003c2c:	4911      	ldr	r1, [pc, #68]	; (8003c74 <bmk9_execute.lto_priv.132+0x94>)
 8003c2e:	1c20      	adds	r0, r4, #0
 8003c30:	f7fd fc6e 	bl	8001510 <chIQGetTimeout>
 8003c34:	490f      	ldr	r1, [pc, #60]	; (8003c74 <bmk9_execute.lto_priv.132+0x94>)
 8003c36:	1c20      	adds	r0, r4, #0
 8003c38:	f7fd fc6a 	bl	8001510 <chIQGetTimeout>
 8003c3c:	490d      	ldr	r1, [pc, #52]	; (8003c74 <bmk9_execute.lto_priv.132+0x94>)
 8003c3e:	1c20      	adds	r0, r4, #0
 8003c40:	f7fd fc66 	bl	8001510 <chIQGetTimeout>
 8003c44:	1c20      	adds	r0, r4, #0
 8003c46:	490b      	ldr	r1, [pc, #44]	; (8003c74 <bmk9_execute.lto_priv.132+0x94>)
 8003c48:	f7fd fc62 	bl	8001510 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003c4c:	7833      	ldrb	r3, [r6, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 8003c4e:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003c50:	2b00      	cmp	r3, #0
 8003c52:	d0d9      	beq.n	8003c08 <bmk9_execute.lto_priv.132+0x28>
  test_print("--- Score : ");
 8003c54:	4808      	ldr	r0, [pc, #32]	; (8003c78 <bmk9_execute.lto_priv.132+0x98>)
 8003c56:	f7fc fd23 	bl	80006a0 <test_print>
  test_printn(n * 4);
 8003c5a:	00a8      	lsls	r0, r5, #2
 8003c5c:	f7fc fd38 	bl	80006d0 <test_printn>
  test_println(" bytes/S");
 8003c60:	4806      	ldr	r0, [pc, #24]	; (8003c7c <bmk9_execute.lto_priv.132+0x9c>)
 8003c62:	f7fc fcfd 	bl	8000660 <test_println>
}
 8003c66:	bd70      	pop	{r4, r5, r6, pc}
 8003c68:	20001104 	.word	0x20001104
 8003c6c:	200010f4 	.word	0x200010f4
 8003c70:	20000e96 	.word	0x20000e96
 8003c74:	0000ffff 	.word	0x0000ffff
 8003c78:	080061f0 	.word	0x080061f0
 8003c7c:	0800622c 	.word	0x0800622c

08003c80 <bmk8_execute.lto_priv.131>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8003c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003c82:	464f      	mov	r7, r9
 8003c84:	4646      	mov	r6, r8
  uint32_t n;

  n = 0;
 8003c86:	2300      	movs	r3, #0
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8003c88:	b4c0      	push	{r6, r7}
 8003c8a:	b085      	sub	sp, #20
  uint32_t n;

  n = 0;
 8003c8c:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8003c8e:	f7fd fc77 	bl	8001580 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003c92:	23a4      	movs	r3, #164	; 0xa4
 8003c94:	005b      	lsls	r3, r3, #1
 8003c96:	4698      	mov	r8, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003c98:	4b2c      	ldr	r3, [pc, #176]	; (8003d4c <bmk8_execute.lto_priv.131+0xcc>)
 8003c9a:	4c2d      	ldr	r4, [pc, #180]	; (8003d50 <bmk8_execute.lto_priv.131+0xd0>)
 8003c9c:	4699      	mov	r9, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003c9e:	699b      	ldr	r3, [r3, #24]
 8003ca0:	4f2c      	ldr	r7, [pc, #176]	; (8003d54 <bmk8_execute.lto_priv.131+0xd4>)
 8003ca2:	689a      	ldr	r2, [r3, #8]
 8003ca4:	ae03      	add	r6, sp, #12
 8003ca6:	4641      	mov	r1, r8
 8003ca8:	1c3b      	adds	r3, r7, #0
 8003caa:	3a01      	subs	r2, #1
 8003cac:	9600      	str	r6, [sp, #0]
 8003cae:	1c20      	adds	r0, r4, #0
 8003cb0:	f7fc fe86 	bl	80009c0 <chThdCreateStatic>
 8003cb4:	464b      	mov	r3, r9
 8003cb6:	4d28      	ldr	r5, [pc, #160]	; (8003d58 <bmk8_execute.lto_priv.131+0xd8>)
 8003cb8:	699b      	ldr	r3, [r3, #24]
 8003cba:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cbc:	1c20      	adds	r0, r4, #0
 8003cbe:	689a      	ldr	r2, [r3, #8]
 8003cc0:	4641      	mov	r1, r8
 8003cc2:	1c3b      	adds	r3, r7, #0
 8003cc4:	4440      	add	r0, r8
 8003cc6:	3a01      	subs	r2, #1
 8003cc8:	9600      	str	r6, [sp, #0]
 8003cca:	f7fc fe79 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cce:	23a4      	movs	r3, #164	; 0xa4
 8003cd0:	009b      	lsls	r3, r3, #2

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cd2:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cd4:	18e0      	adds	r0, r4, r3
 8003cd6:	464b      	mov	r3, r9
 8003cd8:	699b      	ldr	r3, [r3, #24]
 8003cda:	4641      	mov	r1, r8
 8003cdc:	689a      	ldr	r2, [r3, #8]
 8003cde:	1c3b      	adds	r3, r7, #0
 8003ce0:	3a01      	subs	r2, #1
 8003ce2:	9600      	str	r6, [sp, #0]
 8003ce4:	f7fc fe6c 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003ce8:	23f6      	movs	r3, #246	; 0xf6
 8003cea:	009b      	lsls	r3, r3, #2
  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cec:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003cee:	18e0      	adds	r0, r4, r3
 8003cf0:	464b      	mov	r3, r9
 8003cf2:	699b      	ldr	r3, [r3, #24]
 8003cf4:	4641      	mov	r1, r8
 8003cf6:	689a      	ldr	r2, [r3, #8]
 8003cf8:	1c3b      	adds	r3, r7, #0
 8003cfa:	3a01      	subs	r2, #1
 8003cfc:	9600      	str	r6, [sp, #0]
 8003cfe:	f7fc fe5f 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003d02:	23a4      	movs	r3, #164	; 0xa4
 8003d04:	00db      	lsls	r3, r3, #3
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003d06:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8003d08:	18e0      	adds	r0, r4, r3
 8003d0a:	464b      	mov	r3, r9
 8003d0c:	699b      	ldr	r3, [r3, #24]
 8003d0e:	4641      	mov	r1, r8
 8003d10:	689a      	ldr	r2, [r3, #8]
 8003d12:	1c3b      	adds	r3, r7, #0
 8003d14:	3a01      	subs	r2, #1
 8003d16:	9600      	str	r6, [sp, #0]
 8003d18:	f7fc fe52 	bl	80009c0 <chThdCreateStatic>
 8003d1c:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 8003d1e:	20fa      	movs	r0, #250	; 0xfa
 8003d20:	0080      	lsls	r0, r0, #2
 8003d22:	f7fd fc25 	bl	8001570 <chThdSleep>
  test_terminate_threads();
 8003d26:	f7fc fc03 	bl	8000530 <test_terminate_threads>
  test_wait_threads();
 8003d2a:	f7fd f989 	bl	8001040 <test_wait_threads>

  test_print("--- Score : ");
 8003d2e:	480b      	ldr	r0, [pc, #44]	; (8003d5c <bmk8_execute.lto_priv.131+0xdc>)
 8003d30:	f7fc fcb6 	bl	80006a0 <test_print>
  test_printn(n);
 8003d34:	9803      	ldr	r0, [sp, #12]
 8003d36:	f7fc fccb 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8003d3a:	4809      	ldr	r0, [pc, #36]	; (8003d60 <bmk8_execute.lto_priv.131+0xe0>)
 8003d3c:	f7fc fc90 	bl	8000660 <test_println>
}
 8003d40:	b005      	add	sp, #20
 8003d42:	bc0c      	pop	{r2, r3}
 8003d44:	4690      	mov	r8, r2
 8003d46:	4699      	mov	r9, r3
 8003d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003d4a:	46c0      	nop			; (mov r8, r8)
 8003d4c:	20000f20 	.word	0x20000f20
 8003d50:	200006c0 	.word	0x200006c0
 8003d54:	08003df1 	.word	0x08003df1
 8003d58:	20001090 	.word	0x20001090
 8003d5c:	080061f0 	.word	0x080061f0
 8003d60:	08006238 	.word	0x08006238
 8003d64:	46c0      	nop			; (mov r8, r8)
 8003d66:	46c0      	nop			; (mov r8, r8)
 8003d68:	46c0      	nop			; (mov r8, r8)
 8003d6a:	46c0      	nop			; (mov r8, r8)
 8003d6c:	46c0      	nop			; (mov r8, r8)
 8003d6e:	46c0      	nop			; (mov r8, r8)

08003d70 <bmk6_execute.lto_priv.128>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8003d70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003d72:	464f      	mov	r7, r9
 8003d74:	4646      	mov	r6, r8
 8003d76:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003d78:	4b14      	ldr	r3, [pc, #80]	; (8003dcc <bmk6_execute.lto_priv.128+0x5c>)
 8003d7a:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003d7c:	699b      	ldr	r3, [r3, #24]

  uint32_t n = 0;
 8003d7e:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8003d80:	689d      	ldr	r5, [r3, #8]
  test_wait_tick();
 8003d82:	f7fd fbfd 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003d86:	f7fe fd9b 	bl	80028c0 <test_start_timer.constprop.2>
 8003d8a:	4b11      	ldr	r3, [pc, #68]	; (8003dd0 <bmk6_execute.lto_priv.128+0x60>)
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8003d8c:	2600      	movs	r6, #0
 8003d8e:	4699      	mov	r9, r3
 8003d90:	4b10      	ldr	r3, [pc, #64]	; (8003dd4 <bmk6_execute.lto_priv.128+0x64>)
 8003d92:	4f11      	ldr	r7, [pc, #68]	; (8003dd8 <bmk6_execute.lto_priv.128+0x68>)
 8003d94:	4698      	mov	r8, r3

static void bmk6_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8003d96:	3501      	adds	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8003d98:	21a4      	movs	r1, #164	; 0xa4
 8003d9a:	4643      	mov	r3, r8
 8003d9c:	9600      	str	r6, [sp, #0]
 8003d9e:	4648      	mov	r0, r9
 8003da0:	0049      	lsls	r1, r1, #1
 8003da2:	1c2a      	adds	r2, r5, #0
 8003da4:	f7fc fe0c 	bl	80009c0 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003da8:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 8003daa:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003dac:	2b00      	cmp	r3, #0
 8003dae:	d0f3      	beq.n	8003d98 <bmk6_execute.lto_priv.128+0x28>
  test_print("--- Score : ");
 8003db0:	480a      	ldr	r0, [pc, #40]	; (8003ddc <bmk6_execute.lto_priv.128+0x6c>)
 8003db2:	f7fc fc75 	bl	80006a0 <test_print>
  test_printn(n);
 8003db6:	1c20      	adds	r0, r4, #0
 8003db8:	f7fc fc8a 	bl	80006d0 <test_printn>
  test_println(" threads/S");
 8003dbc:	4808      	ldr	r0, [pc, #32]	; (8003de0 <bmk6_execute.lto_priv.128+0x70>)
 8003dbe:	f7fc fc4f 	bl	8000660 <test_println>
}
 8003dc2:	b003      	add	sp, #12
 8003dc4:	bc0c      	pop	{r2, r3}
 8003dc6:	4690      	mov	r8, r2
 8003dc8:	4699      	mov	r9, r3
 8003dca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003dcc:	20000f20 	.word	0x20000f20
 8003dd0:	200006c0 	.word	0x200006c0
 8003dd4:	08004601 	.word	0x08004601
 8003dd8:	20000e96 	.word	0x20000e96
 8003ddc:	080061f0 	.word	0x080061f0
 8003de0:	08006244 	.word	0x08006244
 8003de4:	46c0      	nop			; (mov r8, r8)
 8003de6:	46c0      	nop			; (mov r8, r8)
 8003de8:	46c0      	nop			; (mov r8, r8)
 8003dea:	46c0      	nop			; (mov r8, r8)
 8003dec:	46c0      	nop			; (mov r8, r8)
 8003dee:	46c0      	nop			; (mov r8, r8)

08003df0 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8003df0:	b570      	push	{r4, r5, r6, lr}
 8003df2:	1c04      	adds	r4, r0, #0
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003df4:	2504      	movs	r5, #4
 8003df6:	4e08      	ldr	r6, [pc, #32]	; (8003e18 <thread8+0x28>)

  do {
    chThdYield();
 8003df8:	f7fc fd1a 	bl	8000830 <chThdYield>
    chThdYield();
 8003dfc:	f7fc fd18 	bl	8000830 <chThdYield>
    chThdYield();
 8003e00:	f7fc fd16 	bl	8000830 <chThdYield>
    chThdYield();
 8003e04:	f7fc fd14 	bl	8000830 <chThdYield>
    (*(uint32_t *)p) += 4;
 8003e08:	6823      	ldr	r3, [r4, #0]
 8003e0a:	3304      	adds	r3, #4
 8003e0c:	6023      	str	r3, [r4, #0]
 8003e0e:	69b3      	ldr	r3, [r6, #24]
 8003e10:	7f5b      	ldrb	r3, [r3, #29]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8003e12:	421d      	tst	r5, r3
 8003e14:	d0f0      	beq.n	8003df8 <thread8+0x8>
}
 8003e16:	bd70      	pop	{r4, r5, r6, pc}
 8003e18:	20000f20 	.word	0x20000f20
 8003e1c:	46c0      	nop			; (mov r8, r8)
 8003e1e:	46c0      	nop			; (mov r8, r8)

08003e20 <bmk7_execute.lto_priv.130>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8003e20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003e22:	4647      	mov	r7, r8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8003e24:	21a4      	movs	r1, #164	; 0xa4
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8003e26:	b480      	push	{r7}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8003e28:	2700      	movs	r7, #0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003e2a:	4b3e      	ldr	r3, [pc, #248]	; (8003f24 <bmk7_execute.lto_priv.130+0x104>)
 8003e2c:	4c3e      	ldr	r4, [pc, #248]	; (8003f28 <bmk7_execute.lto_priv.130+0x108>)
 8003e2e:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003e30:	699b      	ldr	r3, [r3, #24]
 8003e32:	4e3e      	ldr	r6, [pc, #248]	; (8003f2c <bmk7_execute.lto_priv.130+0x10c>)
 8003e34:	689a      	ldr	r2, [r3, #8]
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8003e36:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8003e38:	1c33      	adds	r3, r6, #0
 8003e3a:	3205      	adds	r2, #5
 8003e3c:	1c20      	adds	r0, r4, #0
 8003e3e:	0049      	lsls	r1, r1, #1
 8003e40:	9700      	str	r7, [sp, #0]
 8003e42:	f7fc fdbd 	bl	80009c0 <chThdCreateStatic>
 8003e46:	4643      	mov	r3, r8
 8003e48:	4d39      	ldr	r5, [pc, #228]	; (8003f30 <bmk7_execute.lto_priv.130+0x110>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8003e4a:	21a4      	movs	r1, #164	; 0xa4
}

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8003e4c:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8003e4e:	1c20      	adds	r0, r4, #0
 8003e50:	699b      	ldr	r3, [r3, #24]
 8003e52:	3049      	adds	r0, #73	; 0x49
 8003e54:	689a      	ldr	r2, [r3, #8]
 8003e56:	0049      	lsls	r1, r1, #1
 8003e58:	1c33      	adds	r3, r6, #0
 8003e5a:	3204      	adds	r2, #4
 8003e5c:	30ff      	adds	r0, #255	; 0xff
 8003e5e:	9700      	str	r7, [sp, #0]
 8003e60:	f7fc fdae 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8003e64:	23a4      	movs	r3, #164	; 0xa4
 8003e66:	009b      	lsls	r3, r3, #2

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8003e68:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8003e6a:	18e0      	adds	r0, r4, r3
 8003e6c:	4643      	mov	r3, r8
 8003e6e:	21a4      	movs	r1, #164	; 0xa4
 8003e70:	699b      	ldr	r3, [r3, #24]
 8003e72:	0049      	lsls	r1, r1, #1
 8003e74:	689a      	ldr	r2, [r3, #8]
 8003e76:	1c33      	adds	r3, r6, #0
 8003e78:	3203      	adds	r2, #3
 8003e7a:	9700      	str	r7, [sp, #0]
 8003e7c:	f7fc fda0 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8003e80:	23f6      	movs	r3, #246	; 0xf6
 8003e82:	009b      	lsls	r3, r3, #2
static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8003e84:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8003e86:	18e0      	adds	r0, r4, r3
 8003e88:	4643      	mov	r3, r8
 8003e8a:	21a4      	movs	r1, #164	; 0xa4
 8003e8c:	699b      	ldr	r3, [r3, #24]
 8003e8e:	0049      	lsls	r1, r1, #1
 8003e90:	689a      	ldr	r2, [r3, #8]
 8003e92:	1c33      	adds	r3, r6, #0
 8003e94:	3202      	adds	r2, #2
 8003e96:	9700      	str	r7, [sp, #0]
 8003e98:	f7fc fd92 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8003e9c:	23a4      	movs	r3, #164	; 0xa4
 8003e9e:	00db      	lsls	r3, r3, #3
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8003ea0:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8003ea2:	18e0      	adds	r0, r4, r3
 8003ea4:	4643      	mov	r3, r8
 8003ea6:	21a4      	movs	r1, #164	; 0xa4
 8003ea8:	699b      	ldr	r3, [r3, #24]
 8003eaa:	0049      	lsls	r1, r1, #1
 8003eac:	689a      	ldr	r2, [r3, #8]
 8003eae:	1c33      	adds	r3, r6, #0
 8003eb0:	3201      	adds	r2, #1
 8003eb2:	9700      	str	r7, [sp, #0]
 8003eb4:	f7fc fd84 	bl	80009c0 <chThdCreateStatic>

  n = 0;
 8003eb8:	2400      	movs	r4, #0

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8003eba:	6128      	str	r0, [r5, #16]

  n = 0;
  test_wait_tick();
 8003ebc:	f7fd fb60 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003ec0:	f7fe fcfe 	bl	80028c0 <test_start_timer.constprop.2>
 8003ec4:	4d1b      	ldr	r5, [pc, #108]	; (8003f34 <bmk7_execute.lto_priv.130+0x114>)
 8003ec6:	4e1c      	ldr	r6, [pc, #112]	; (8003f38 <bmk7_execute.lto_priv.130+0x118>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ec8:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8003eca:	2100      	movs	r1, #0
 8003ecc:	1c28      	adds	r0, r5, #0
 8003ece:	f7fd f92f 	bl	8001130 <chSemResetI>
  chSchRescheduleS();
 8003ed2:	f7fc fcdd 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ed6:	b662      	cpsie	i
    chSemReset(&sem1, 0);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003ed8:	7833      	ldrb	r3, [r6, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8003eda:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003edc:	2b00      	cmp	r3, #0
 8003ede:	d0f3      	beq.n	8003ec8 <bmk7_execute.lto_priv.130+0xa8>
  test_terminate_threads();
 8003ee0:	f7fc fb26 	bl	8000530 <test_terminate_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ee4:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8003ee6:	2100      	movs	r1, #0
 8003ee8:	1c28      	adds	r0, r5, #0
 8003eea:	f7fd f921 	bl	8001130 <chSemResetI>
  chSchRescheduleS();
 8003eee:	f7fc fccf 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ef2:	b662      	cpsie	i
  chSemReset(&sem1, 0);
  test_wait_threads();
 8003ef4:	f7fd f8a4 	bl	8001040 <test_wait_threads>

  test_print("--- Score : ");
 8003ef8:	4810      	ldr	r0, [pc, #64]	; (8003f3c <bmk7_execute.lto_priv.130+0x11c>)
 8003efa:	f7fc fbd1 	bl	80006a0 <test_print>
  test_printn(n);
 8003efe:	1c20      	adds	r0, r4, #0
 8003f00:	f7fc fbe6 	bl	80006d0 <test_printn>
  test_print(" reschedules/S, ");
 8003f04:	480e      	ldr	r0, [pc, #56]	; (8003f40 <bmk7_execute.lto_priv.130+0x120>)
 8003f06:	f7fc fbcb 	bl	80006a0 <test_print>
  test_printn(n * 6);
 8003f0a:	0060      	lsls	r0, r4, #1
 8003f0c:	1900      	adds	r0, r0, r4
 8003f0e:	0040      	lsls	r0, r0, #1
 8003f10:	f7fc fbde 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8003f14:	480b      	ldr	r0, [pc, #44]	; (8003f44 <bmk7_execute.lto_priv.130+0x124>)
 8003f16:	f7fc fba3 	bl	8000660 <test_println>
}
 8003f1a:	b002      	add	sp, #8
 8003f1c:	bc04      	pop	{r2}
 8003f1e:	4690      	mov	r8, r2
 8003f20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003f22:	46c0      	nop			; (mov r8, r8)
 8003f24:	20000f20 	.word	0x20000f20
 8003f28:	200006c0 	.word	0x200006c0
 8003f2c:	08003b31 	.word	0x08003b31
 8003f30:	20001090 	.word	0x20001090
 8003f34:	20001128 	.word	0x20001128
 8003f38:	20000e96 	.word	0x20000e96
 8003f3c:	080061f0 	.word	0x080061f0
 8003f40:	08006250 	.word	0x08006250
 8003f44:	08006238 	.word	0x08006238
 8003f48:	46c0      	nop			; (mov r8, r8)
 8003f4a:	46c0      	nop			; (mov r8, r8)
 8003f4c:	46c0      	nop			; (mov r8, r8)
 8003f4e:	46c0      	nop			; (mov r8, r8)

08003f50 <bmk5_execute.lto_priv.127>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8003f50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003f52:	464f      	mov	r7, r9
 8003f54:	4646      	mov	r6, r8
 8003f56:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003f58:	4b15      	ldr	r3, [pc, #84]	; (8003fb0 <bmk5_execute.lto_priv.127+0x60>)
 8003f5a:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003f5c:	699b      	ldr	r3, [r3, #24]

  uint32_t n = 0;
 8003f5e:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8003f60:	689d      	ldr	r5, [r3, #8]
  test_wait_tick();
 8003f62:	f7fd fb0d 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003f66:	f7fe fcab 	bl	80028c0 <test_start_timer.constprop.2>
 8003f6a:	4b12      	ldr	r3, [pc, #72]	; (8003fb4 <bmk5_execute.lto_priv.127+0x64>)
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8003f6c:	2600      	movs	r6, #0
 8003f6e:	4699      	mov	r9, r3
 8003f70:	4b11      	ldr	r3, [pc, #68]	; (8003fb8 <bmk5_execute.lto_priv.127+0x68>)
 8003f72:	4f12      	ldr	r7, [pc, #72]	; (8003fbc <bmk5_execute.lto_priv.127+0x6c>)
 8003f74:	4698      	mov	r8, r3

static void bmk5_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8003f76:	3d01      	subs	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8003f78:	21a4      	movs	r1, #164	; 0xa4
 8003f7a:	4643      	mov	r3, r8
 8003f7c:	0049      	lsls	r1, r1, #1
 8003f7e:	1c2a      	adds	r2, r5, #0
 8003f80:	9600      	str	r6, [sp, #0]
 8003f82:	4648      	mov	r0, r9
 8003f84:	f7fc fd1c 	bl	80009c0 <chThdCreateStatic>
 8003f88:	f7fd f842 	bl	8001010 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003f8c:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8003f8e:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003f90:	2b00      	cmp	r3, #0
 8003f92:	d0f1      	beq.n	8003f78 <bmk5_execute.lto_priv.127+0x28>
  test_print("--- Score : ");
 8003f94:	480a      	ldr	r0, [pc, #40]	; (8003fc0 <bmk5_execute.lto_priv.127+0x70>)
 8003f96:	f7fc fb83 	bl	80006a0 <test_print>
  test_printn(n);
 8003f9a:	1c20      	adds	r0, r4, #0
 8003f9c:	f7fc fb98 	bl	80006d0 <test_printn>
  test_println(" threads/S");
 8003fa0:	4808      	ldr	r0, [pc, #32]	; (8003fc4 <bmk5_execute.lto_priv.127+0x74>)
 8003fa2:	f7fc fb5d 	bl	8000660 <test_println>
}
 8003fa6:	b003      	add	sp, #12
 8003fa8:	bc0c      	pop	{r2, r3}
 8003faa:	4690      	mov	r8, r2
 8003fac:	4699      	mov	r9, r3
 8003fae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003fb0:	20000f20 	.word	0x20000f20
 8003fb4:	200006c0 	.word	0x200006c0
 8003fb8:	08004601 	.word	0x08004601
 8003fbc:	20000e96 	.word	0x20000e96
 8003fc0:	080061f0 	.word	0x080061f0
 8003fc4:	08006244 	.word	0x08006244
 8003fc8:	46c0      	nop			; (mov r8, r8)
 8003fca:	46c0      	nop			; (mov r8, r8)
 8003fcc:	46c0      	nop			; (mov r8, r8)
 8003fce:	46c0      	nop			; (mov r8, r8)

08003fd0 <bmk4_execute.lto_priv.126>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003fd0:	4b20      	ldr	r3, [pc, #128]	; (8004054 <bmk4_execute.lto_priv.126+0x84>)

static void bmk4_execute(void) {
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003fd2:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003fd4:	699b      	ldr	r3, [r3, #24]
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8003fd6:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003fd8:	689a      	ldr	r2, [r3, #8]
 8003fda:	2300      	movs	r3, #0
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8003fdc:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003fde:	3201      	adds	r2, #1
 8003fe0:	0049      	lsls	r1, r1, #1
 8003fe2:	9300      	str	r3, [sp, #0]
 8003fe4:	481c      	ldr	r0, [pc, #112]	; (8004058 <bmk4_execute.lto_priv.126+0x88>)
 8003fe6:	4b1d      	ldr	r3, [pc, #116]	; (800405c <bmk4_execute.lto_priv.126+0x8c>)
 8003fe8:	f7fc fcea 	bl	80009c0 <chThdCreateStatic>
                                      thread4, NULL);
  n = 0;
 8003fec:	2500      	movs	r5, #0

static void bmk4_execute(void) {
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003fee:	4b1c      	ldr	r3, [pc, #112]	; (8004060 <bmk4_execute.lto_priv.126+0x90>)
 8003ff0:	1c04      	adds	r4, r0, #0
 8003ff2:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8003ff4:	f7fd fac4 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 8003ff8:	f7fe fc62 	bl	80028c0 <test_start_timer.constprop.2>
 8003ffc:	4e19      	ldr	r6, [pc, #100]	; (8004064 <bmk4_execute.lto_priv.126+0x94>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ffe:	b672      	cpsid	i
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8004000:	2100      	movs	r1, #0
 8004002:	1c20      	adds	r0, r4, #0
 8004004:	f7fc fc6c 	bl	80008e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8004008:	1c20      	adds	r0, r4, #0
 800400a:	2100      	movs	r1, #0
 800400c:	f7fc fc68 	bl	80008e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8004010:	1c20      	adds	r0, r4, #0
 8004012:	2100      	movs	r1, #0
 8004014:	f7fc fc64 	bl	80008e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8004018:	1c20      	adds	r0, r4, #0
 800401a:	2100      	movs	r1, #0
 800401c:	f7fc fc60 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004020:	b662      	cpsie	i
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8004022:	7833      	ldrb	r3, [r6, #0]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8004024:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8004026:	2b00      	cmp	r3, #0
 8004028:	d0e9      	beq.n	8003ffe <bmk4_execute.lto_priv.126+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800402a:	b672      	cpsid	i
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 800402c:	2101      	movs	r1, #1
 800402e:	1c20      	adds	r0, r4, #0
 8004030:	4249      	negs	r1, r1
 8004032:	f7fc fc55 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004036:	b662      	cpsie	i
  chSysUnlock();

  test_wait_threads();
 8004038:	f7fd f802 	bl	8001040 <test_wait_threads>
  test_print("--- Score : ");
 800403c:	480a      	ldr	r0, [pc, #40]	; (8004068 <bmk4_execute.lto_priv.126+0x98>)
 800403e:	f7fc fb2f 	bl	80006a0 <test_print>
  test_printn(n * 2);
 8004042:	0068      	lsls	r0, r5, #1
 8004044:	f7fc fb44 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8004048:	4808      	ldr	r0, [pc, #32]	; (800406c <bmk4_execute.lto_priv.126+0x9c>)
 800404a:	f7fc fb09 	bl	8000660 <test_println>
}
 800404e:	b002      	add	sp, #8
 8004050:	bd70      	pop	{r4, r5, r6, pc}
 8004052:	46c0      	nop			; (mov r8, r8)
 8004054:	20000f20 	.word	0x20000f20
 8004058:	200006c0 	.word	0x200006c0
 800405c:	08004071 	.word	0x08004071
 8004060:	20001090 	.word	0x20001090
 8004064:	20000e96 	.word	0x20000e96
 8004068:	080061f0 	.word	0x080061f0
 800406c:	08006238 	.word	0x08006238

08004070 <thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004070:	4b05      	ldr	r3, [pc, #20]	; (8004088 <thread4+0x18>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8004072:	b510      	push	{r4, lr}
 8004074:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004076:	b672      	cpsid	i
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8004078:	2003      	movs	r0, #3
 800407a:	f7fc fcd1 	bl	8000a20 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 800407e:	6a23      	ldr	r3, [r4, #32]
 8004080:	2b00      	cmp	r3, #0
 8004082:	d0f9      	beq.n	8004078 <thread4+0x8>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004084:	b662      	cpsie	i
  chSysUnlock();
}
 8004086:	bd10      	pop	{r4, pc}
 8004088:	20000f20 	.word	0x20000f20
 800408c:	46c0      	nop			; (mov r8, r8)
 800408e:	46c0      	nop			; (mov r8, r8)

08004090 <thread2.lto_priv.140>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8004090:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8004092:	f7fc fcd5 	bl	8000a40 <chMsgWait>
 8004096:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004098:	b672      	cpsid	i
 800409a:	1c21      	adds	r1, r4, #0
 800409c:	f7fc fc20 	bl	80008e0 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80040a0:	b662      	cpsie	i
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 80040a2:	2c00      	cmp	r4, #0
 80040a4:	d1f5      	bne.n	8004092 <thread2.lto_priv.140+0x2>
}
 80040a6:	bd10      	pop	{r4, pc}
 80040a8:	46c0      	nop			; (mov r8, r8)
 80040aa:	46c0      	nop			; (mov r8, r8)
 80040ac:	46c0      	nop			; (mov r8, r8)
 80040ae:	46c0      	nop			; (mov r8, r8)

080040b0 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80040b0:	b570      	push	{r4, r5, r6, lr}

  uint32_t n = 0;
 80040b2:	2400      	movs	r4, #0
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80040b4:	1c05      	adds	r5, r0, #0

  uint32_t n = 0;
  test_wait_tick();
 80040b6:	f7fd fa63 	bl	8001580 <test_wait_tick>
  test_start_timer(1000);
 80040ba:	f7fe fc01 	bl	80028c0 <test_start_timer.constprop.2>
 80040be:	4e07      	ldr	r6, [pc, #28]	; (80040dc <msg_loop_test+0x2c>)
  do {
    (void)chMsgSend(tp, 1);
 80040c0:	1c28      	adds	r0, r5, #0
 80040c2:	2101      	movs	r1, #1
 80040c4:	f7fc fd64 	bl	8000b90 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80040c8:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 80040ca:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80040cc:	2b00      	cmp	r3, #0
 80040ce:	d0f7      	beq.n	80040c0 <msg_loop_test+0x10>
  (void)chMsgSend(tp, 0);
 80040d0:	1c28      	adds	r0, r5, #0
 80040d2:	2100      	movs	r1, #0
 80040d4:	f7fc fd5c 	bl	8000b90 <chMsgSend>
  return n;
}
 80040d8:	1c20      	adds	r0, r4, #0
 80040da:	bd70      	pop	{r4, r5, r6, pc}
 80040dc:	20000e96 	.word	0x20000e96

080040e0 <bmk3_execute.lto_priv.125>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80040e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80040e2:	464f      	mov	r7, r9
 80040e4:	4646      	mov	r6, r8
 80040e6:	4b30      	ldr	r3, [pc, #192]	; (80041a8 <bmk3_execute.lto_priv.125+0xc8>)
 80040e8:	b4c0      	push	{r6, r7}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80040ea:	26a4      	movs	r6, #164	; 0xa4
 80040ec:	2700      	movs	r7, #0
 80040ee:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80040f0:	699b      	ldr	r3, [r3, #24]
 80040f2:	4c2e      	ldr	r4, [pc, #184]	; (80041ac <bmk3_execute.lto_priv.125+0xcc>)
 80040f4:	689a      	ldr	r2, [r3, #8]
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80040f6:	b083      	sub	sp, #12
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80040f8:	0076      	lsls	r6, r6, #1
 80040fa:	1c31      	adds	r1, r6, #0
 80040fc:	3201      	adds	r2, #1
 80040fe:	9700      	str	r7, [sp, #0]
 8004100:	1c20      	adds	r0, r4, #0
 8004102:	4b2b      	ldr	r3, [pc, #172]	; (80041b0 <bmk3_execute.lto_priv.125+0xd0>)
 8004104:	f7fc fc5c 	bl	80009c0 <chThdCreateStatic>
 8004108:	4643      	mov	r3, r8
 800410a:	699b      	ldr	r3, [r3, #24]
 800410c:	4d29      	ldr	r5, [pc, #164]	; (80041b4 <bmk3_execute.lto_priv.125+0xd4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 800410e:	689a      	ldr	r2, [r3, #8]
 8004110:	4b29      	ldr	r3, [pc, #164]	; (80041b8 <bmk3_execute.lto_priv.125+0xd8>)
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8004112:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8004114:	1c31      	adds	r1, r6, #0
 8004116:	19a0      	adds	r0, r4, r6
 8004118:	3a02      	subs	r2, #2
 800411a:	9700      	str	r7, [sp, #0]
 800411c:	4699      	mov	r9, r3
 800411e:	f7fc fc4f 	bl	80009c0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8004122:	23a4      	movs	r3, #164	; 0xa4
 8004124:	009b      	lsls	r3, r3, #2

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8004126:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8004128:	18e0      	adds	r0, r4, r3
 800412a:	4643      	mov	r3, r8
 800412c:	699b      	ldr	r3, [r3, #24]
 800412e:	1c31      	adds	r1, r6, #0
 8004130:	689a      	ldr	r2, [r3, #8]
 8004132:	464b      	mov	r3, r9
 8004134:	3a03      	subs	r2, #3
 8004136:	9700      	str	r7, [sp, #0]
 8004138:	f7fc fc42 	bl	80009c0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 800413c:	23f6      	movs	r3, #246	; 0xf6
 800413e:	009b      	lsls	r3, r3, #2
static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8004140:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8004142:	18e0      	adds	r0, r4, r3
 8004144:	4643      	mov	r3, r8
 8004146:	699b      	ldr	r3, [r3, #24]
 8004148:	1c31      	adds	r1, r6, #0
 800414a:	689a      	ldr	r2, [r3, #8]
 800414c:	464b      	mov	r3, r9
 800414e:	3a04      	subs	r2, #4
 8004150:	9700      	str	r7, [sp, #0]
 8004152:	f7fc fc35 	bl	80009c0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8004156:	23a4      	movs	r3, #164	; 0xa4
 8004158:	00db      	lsls	r3, r3, #3
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 800415a:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 800415c:	18e0      	adds	r0, r4, r3
 800415e:	4643      	mov	r3, r8
 8004160:	699b      	ldr	r3, [r3, #24]
 8004162:	1c31      	adds	r1, r6, #0
 8004164:	689a      	ldr	r2, [r3, #8]
 8004166:	464b      	mov	r3, r9
 8004168:	3a05      	subs	r2, #5
 800416a:	9700      	str	r7, [sp, #0]
 800416c:	f7fc fc28 	bl	80009c0 <chThdCreateStatic>
 8004170:	6128      	str	r0, [r5, #16]
  n = msg_loop_test(threads[0]);
 8004172:	6828      	ldr	r0, [r5, #0]
 8004174:	f7ff ff9c 	bl	80040b0 <msg_loop_test>
 8004178:	1c04      	adds	r4, r0, #0
  test_wait_threads();
 800417a:	f7fc ff61 	bl	8001040 <test_wait_threads>
  test_print("--- Score : ");
 800417e:	480f      	ldr	r0, [pc, #60]	; (80041bc <bmk3_execute.lto_priv.125+0xdc>)
 8004180:	f7fc fa8e 	bl	80006a0 <test_print>
  test_printn(n);
 8004184:	1c20      	adds	r0, r4, #0
 8004186:	f7fc faa3 	bl	80006d0 <test_printn>
  test_print(" msgs/S, ");
 800418a:	480d      	ldr	r0, [pc, #52]	; (80041c0 <bmk3_execute.lto_priv.125+0xe0>)
 800418c:	f7fc fa88 	bl	80006a0 <test_print>
  test_printn(n << 1);
 8004190:	0060      	lsls	r0, r4, #1
 8004192:	f7fc fa9d 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8004196:	480b      	ldr	r0, [pc, #44]	; (80041c4 <bmk3_execute.lto_priv.125+0xe4>)
 8004198:	f7fc fa62 	bl	8000660 <test_println>
}
 800419c:	b003      	add	sp, #12
 800419e:	bc0c      	pop	{r2, r3}
 80041a0:	4690      	mov	r8, r2
 80041a2:	4699      	mov	r9, r3
 80041a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80041a6:	46c0      	nop			; (mov r8, r8)
 80041a8:	20000f20 	.word	0x20000f20
 80041ac:	200006c0 	.word	0x200006c0
 80041b0:	08004091 	.word	0x08004091
 80041b4:	20001090 	.word	0x20001090
 80041b8:	08004601 	.word	0x08004601
 80041bc:	080061f0 	.word	0x080061f0
 80041c0:	08006264 	.word	0x08006264
 80041c4:	08006238 	.word	0x08006238
 80041c8:	46c0      	nop			; (mov r8, r8)
 80041ca:	46c0      	nop			; (mov r8, r8)
 80041cc:	46c0      	nop			; (mov r8, r8)
 80041ce:	46c0      	nop			; (mov r8, r8)

080041d0 <bmk2_execute.lto_priv.124>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80041d0:	4b12      	ldr	r3, [pc, #72]	; (800421c <bmk2_execute.lto_priv.124+0x4c>)
 */

static void bmk2_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80041d2:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80041d4:	699b      	ldr	r3, [r3, #24]
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 80041d6:	b510      	push	{r4, lr}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80041d8:	689a      	ldr	r2, [r3, #8]
 80041da:	2300      	movs	r3, #0
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 80041dc:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80041de:	3201      	adds	r2, #1
 80041e0:	0049      	lsls	r1, r1, #1
 80041e2:	9300      	str	r3, [sp, #0]
 80041e4:	480e      	ldr	r0, [pc, #56]	; (8004220 <bmk2_execute.lto_priv.124+0x50>)
 80041e6:	4b0f      	ldr	r3, [pc, #60]	; (8004224 <bmk2_execute.lto_priv.124+0x54>)
 80041e8:	f7fc fbea 	bl	80009c0 <chThdCreateStatic>
 80041ec:	4b0e      	ldr	r3, [pc, #56]	; (8004228 <bmk2_execute.lto_priv.124+0x58>)
 80041ee:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 80041f0:	f7ff ff5e 	bl	80040b0 <msg_loop_test>
 80041f4:	1c04      	adds	r4, r0, #0
  test_wait_threads();
 80041f6:	f7fc ff23 	bl	8001040 <test_wait_threads>
  test_print("--- Score : ");
 80041fa:	480c      	ldr	r0, [pc, #48]	; (800422c <bmk2_execute.lto_priv.124+0x5c>)
 80041fc:	f7fc fa50 	bl	80006a0 <test_print>
  test_printn(n);
 8004200:	1c20      	adds	r0, r4, #0
 8004202:	f7fc fa65 	bl	80006d0 <test_printn>
  test_print(" msgs/S, ");
 8004206:	480a      	ldr	r0, [pc, #40]	; (8004230 <bmk2_execute.lto_priv.124+0x60>)
 8004208:	f7fc fa4a 	bl	80006a0 <test_print>
  test_printn(n << 1);
 800420c:	0060      	lsls	r0, r4, #1
 800420e:	f7fc fa5f 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8004212:	4808      	ldr	r0, [pc, #32]	; (8004234 <bmk2_execute.lto_priv.124+0x64>)
 8004214:	f7fc fa24 	bl	8000660 <test_println>
}
 8004218:	b002      	add	sp, #8
 800421a:	bd10      	pop	{r4, pc}
 800421c:	20000f20 	.word	0x20000f20
 8004220:	200006c0 	.word	0x200006c0
 8004224:	08004091 	.word	0x08004091
 8004228:	20001090 	.word	0x20001090
 800422c:	080061f0 	.word	0x080061f0
 8004230:	08006264 	.word	0x08006264
 8004234:	08006238 	.word	0x08006238
 8004238:	46c0      	nop			; (mov r8, r8)
 800423a:	46c0      	nop			; (mov r8, r8)
 800423c:	46c0      	nop			; (mov r8, r8)
 800423e:	46c0      	nop			; (mov r8, r8)

08004240 <bmk1_execute.lto_priv.123>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004240:	4b12      	ldr	r3, [pc, #72]	; (800428c <bmk1_execute.lto_priv.123+0x4c>)
 */

static void bmk1_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8004242:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004244:	699b      	ldr	r3, [r3, #24]
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8004246:	b510      	push	{r4, lr}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8004248:	689a      	ldr	r2, [r3, #8]
 800424a:	2300      	movs	r3, #0
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 800424c:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 800424e:	3a01      	subs	r2, #1
 8004250:	0049      	lsls	r1, r1, #1
 8004252:	9300      	str	r3, [sp, #0]
 8004254:	480e      	ldr	r0, [pc, #56]	; (8004290 <bmk1_execute.lto_priv.123+0x50>)
 8004256:	4b0f      	ldr	r3, [pc, #60]	; (8004294 <bmk1_execute.lto_priv.123+0x54>)
 8004258:	f7fc fbb2 	bl	80009c0 <chThdCreateStatic>
 800425c:	4b0e      	ldr	r3, [pc, #56]	; (8004298 <bmk1_execute.lto_priv.123+0x58>)
 800425e:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8004260:	f7ff ff26 	bl	80040b0 <msg_loop_test>
 8004264:	1c04      	adds	r4, r0, #0
  test_wait_threads();
 8004266:	f7fc feeb 	bl	8001040 <test_wait_threads>
  test_print("--- Score : ");
 800426a:	480c      	ldr	r0, [pc, #48]	; (800429c <bmk1_execute.lto_priv.123+0x5c>)
 800426c:	f7fc fa18 	bl	80006a0 <test_print>
  test_printn(n);
 8004270:	1c20      	adds	r0, r4, #0
 8004272:	f7fc fa2d 	bl	80006d0 <test_printn>
  test_print(" msgs/S, ");
 8004276:	480a      	ldr	r0, [pc, #40]	; (80042a0 <bmk1_execute.lto_priv.123+0x60>)
 8004278:	f7fc fa12 	bl	80006a0 <test_print>
  test_printn(n << 1);
 800427c:	0060      	lsls	r0, r4, #1
 800427e:	f7fc fa27 	bl	80006d0 <test_printn>
  test_println(" ctxswc/S");
 8004282:	4808      	ldr	r0, [pc, #32]	; (80042a4 <bmk1_execute.lto_priv.123+0x64>)
 8004284:	f7fc f9ec 	bl	8000660 <test_println>
}
 8004288:	b002      	add	sp, #8
 800428a:	bd10      	pop	{r4, pc}
 800428c:	20000f20 	.word	0x20000f20
 8004290:	200006c0 	.word	0x200006c0
 8004294:	08004091 	.word	0x08004091
 8004298:	20001090 	.word	0x20001090
 800429c:	080061f0 	.word	0x080061f0
 80042a0:	08006264 	.word	0x08006264
 80042a4:	08006238 	.word	0x08006238
 80042a8:	46c0      	nop			; (mov r8, r8)
 80042aa:	46c0      	nop			; (mov r8, r8)
 80042ac:	46c0      	nop			; (mov r8, r8)
 80042ae:	46c0      	nop			; (mov r8, r8)

080042b0 <sys3_execute.lto_priv.76>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 80042b0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042b2:	b672      	cpsid	i
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80042b4:	2001      	movs	r0, #1
 80042b6:	f7fd f98b 	bl	80015d0 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042ba:	b662      	cpsie	i
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 80042bc:	2401      	movs	r4, #1
 80042be:	4060      	eors	r0, r4
 80042c0:	b2c1      	uxtb	r1, r0
 80042c2:	2001      	movs	r0, #1
 80042c4:	f7fc f99c 	bl	8000600 <_test_assert>
 80042c8:	2800      	cmp	r0, #0
 80042ca:	d000      	beq.n	80042ce <sys3_execute.lto_priv.76+0x1e>

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
}
 80042cc:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042ce:	b672      	cpsid	i
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80042d0:	3002      	adds	r0, #2
 80042d2:	f7fd f97d 	bl	80015d0 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042d6:	b662      	cpsie	i
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 80042d8:	4060      	eors	r0, r4
 80042da:	b2c1      	uxtb	r1, r0
 80042dc:	2002      	movs	r0, #2
 80042de:	f7fc f98f 	bl	8000600 <_test_assert>
 80042e2:	2800      	cmp	r0, #0
 80042e4:	d1f2      	bne.n	80042cc <sys3_execute.lto_priv.76+0x1c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042e6:	b672      	cpsid	i

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80042e8:	3004      	adds	r0, #4
 80042ea:	f7fd f971 	bl	80015d0 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042ee:	b662      	cpsie	i
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 80042f0:	4060      	eors	r0, r4
 80042f2:	b2c1      	uxtb	r1, r0
 80042f4:	2003      	movs	r0, #3
 80042f6:	f7fc f983 	bl	8000600 <_test_assert>
 80042fa:	2800      	cmp	r0, #0
 80042fc:	d1e6      	bne.n	80042cc <sys3_execute.lto_priv.76+0x1c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042fe:	b672      	cpsid	i

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8004300:	3008      	adds	r0, #8
 8004302:	f7fd f965 	bl	80015d0 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004306:	b662      	cpsie	i
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 8004308:	4044      	eors	r4, r0
 800430a:	b2e1      	uxtb	r1, r4
 800430c:	2004      	movs	r0, #4
 800430e:	f7fc f977 	bl	8000600 <_test_assert>
 8004312:	e7db      	b.n	80042cc <sys3_execute.lto_priv.76+0x1c>
 8004314:	46c0      	nop			; (mov r8, r8)
 8004316:	46c0      	nop			; (mov r8, r8)
 8004318:	46c0      	nop			; (mov r8, r8)
 800431a:	46c0      	nop			; (mov r8, r8)
 800431c:	46c0      	nop			; (mov r8, r8)
 800431e:	46c0      	nop			; (mov r8, r8)

08004320 <sys1_execute.lto_priv.74>:
  sts = chSysGetStatusAndLockX();
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}

static void sys1_execute(void) {
 8004320:	b510      	push	{r4, lr}
 8004322:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8004324:	f7fd f94c 	bl	80015c0 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8004328:	07c3      	lsls	r3, r0, #31
 800432a:	d401      	bmi.n	8004330 <sys1_execute.lto_priv.74+0x10>
 800432c:	f7fd f938 	bl	80015a0 <chSysRestoreStatusX.part.2.lto_priv.142>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004330:	b672      	cpsid	i
  chSysRestoreStatusX(sts);

  /* Reentrant case.*/
  chSysLock();
  sts = chSysGetStatusAndLockX();
 8004332:	f7fd f945 	bl	80015c0 <chSysGetStatusAndLockX>
 8004336:	07c3      	lsls	r3, r0, #31
 8004338:	d401      	bmi.n	800433e <sys1_execute.lto_priv.74+0x1e>
 800433a:	f7fd f931 	bl	80015a0 <chSysRestoreStatusX.part.2.lto_priv.142>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800433e:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8004340:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8004344:	07db      	lsls	r3, r3, #31
 8004346:	d400      	bmi.n	800434a <sys1_execute.lto_priv.74+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004348:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800434a:	f3ef 8310 	mrs	r3, PRIMASK
 800434e:	07db      	lsls	r3, r3, #31
 8004350:	d400      	bmi.n	8004354 <sys1_execute.lto_priv.74+0x34>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004352:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004354:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004356:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8004358:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800435c:	07db      	lsls	r3, r3, #31
 800435e:	d500      	bpl.n	8004362 <sys1_execute.lto_priv.74+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004360:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8004362:	f3ef 8310 	mrs	r3, PRIMASK
 8004366:	07db      	lsls	r3, r3, #31
 8004368:	d500      	bpl.n	800436c <sys1_execute.lto_priv.74+0x4c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800436a:	b662      	cpsie	i
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 800436c:	2300      	movs	r3, #0
 800436e:	9304      	str	r3, [sp, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004370:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8004372:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8004374:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8004376:	2b00      	cmp	r3, #0
 8004378:	d002      	beq.n	8004380 <sys1_execute.lto_priv.74+0x60>
    chVTDoResetI(vtp);
 800437a:	1c20      	adds	r0, r4, #0
 800437c:	f7fc ff10 	bl	80011a0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8004380:	1c20      	adds	r0, r4, #0
 8004382:	2101      	movs	r1, #1
 8004384:	4a09      	ldr	r2, [pc, #36]	; (80043ac <sys1_execute.lto_priv.74+0x8c>)
 8004386:	2300      	movs	r3, #0
 8004388:	f7fc ff4a 	bl	8001220 <chVTDoSetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800438c:	b662      	cpsie	i
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 800438e:	200a      	movs	r0, #10
 8004390:	f7fd f8ee 	bl	8001570 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004394:	b672      	cpsid	i
 8004396:	9904      	ldr	r1, [sp, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004398:	b662      	cpsie	i

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 800439a:	424b      	negs	r3, r1
 800439c:	4159      	adcs	r1, r3
 800439e:	2001      	movs	r0, #1
 80043a0:	b2c9      	uxtb	r1, r1
 80043a2:	f7fc f92d 	bl	8000600 <_test_assert>
}
 80043a6:	b006      	add	sp, #24
 80043a8:	bd10      	pop	{r4, pc}
 80043aa:	46c0      	nop			; (mov r8, r8)
 80043ac:	080043b1 	.word	0x080043b1

080043b0 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 80043b0:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043b2:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043b4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043b6:	b672      	cpsid	i
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 80043b8:	f7fd f902 	bl	80015c0 <chSysGetStatusAndLockX>
 80043bc:	07c3      	lsls	r3, r0, #31
 80043be:	d401      	bmi.n	80043c4 <vtcb+0x14>
 80043c0:	f7fd f8ee 	bl	80015a0 <chSysRestoreStatusX.part.2.lto_priv.142>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043c4:	b662      	cpsie	i
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}
 80043c6:	bd08      	pop	{r3, pc}
 80043c8:	46c0      	nop			; (mov r8, r8)
 80043ca:	46c0      	nop			; (mov r8, r8)
 80043cc:	46c0      	nop			; (mov r8, r8)
 80043ce:	46c0      	nop			; (mov r8, r8)

080043d0 <thread2.lto_priv.139>:
static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static THD_FUNCTION(thread2, p) {
 80043d0:	b508      	push	{r3, lr}

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 80043d2:	4803      	ldr	r0, [pc, #12]	; (80043e0 <thread2.lto_priv.139+0x10>)
 80043d4:	2100      	movs	r1, #0
 80043d6:	22c8      	movs	r2, #200	; 0xc8
 80043d8:	f7fd f81a 	bl	8001410 <chOQPutTimeout>
}
 80043dc:	bd08      	pop	{r3, pc}
 80043de:	46c0      	nop			; (mov r8, r8)
 80043e0:	2000065c 	.word	0x2000065c
 80043e4:	46c0      	nop			; (mov r8, r8)
 80043e6:	46c0      	nop			; (mov r8, r8)
 80043e8:	46c0      	nop			; (mov r8, r8)
 80043ea:	46c0      	nop			; (mov r8, r8)
 80043ec:	46c0      	nop			; (mov r8, r8)
 80043ee:	46c0      	nop			; (mov r8, r8)

080043f0 <queues2_execute.lto_priv.122>:

static void queues2_execute(void) {
 80043f0:	b570      	push	{r4, r5, r6, lr}
 80043f2:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043f4:	b672      	cpsid	i
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80043f6:	4d7b      	ldr	r5, [pc, #492]	; (80045e4 <queues2_execute.lto_priv.122+0x1f4>)
 80043f8:	2100      	movs	r1, #0
 80043fa:	696b      	ldr	r3, [r5, #20]
 80043fc:	69aa      	ldr	r2, [r5, #24]
 80043fe:	4293      	cmp	r3, r2
 8004400:	d100      	bne.n	8004404 <queues2_execute.lto_priv.122+0x14>
 8004402:	e0e4      	b.n	80045ce <queues2_execute.lto_priv.122+0x1de>
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8004404:	2001      	movs	r0, #1
 8004406:	f7fc f8fb 	bl	8000600 <_test_assert>
 800440a:	2800      	cmp	r0, #0
 800440c:	d12d      	bne.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800440e:	b662      	cpsie	i
 8004410:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8004412:	1c21      	adds	r1, r4, #0
 8004414:	3401      	adds	r4, #1
 8004416:	1c28      	adds	r0, r5, #0
 8004418:	4a73      	ldr	r2, [pc, #460]	; (80045e8 <queues2_execute.lto_priv.122+0x1f8>)
 800441a:	b2e4      	uxtb	r4, r4
 800441c:	f7fc fff8 	bl	8001410 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8004420:	2c45      	cmp	r4, #69	; 0x45
 8004422:	d1f6      	bne.n	8004412 <queues2_execute.lto_priv.122+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004424:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8004426:	68a9      	ldr	r1, [r5, #8]
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 8004428:	2002      	movs	r0, #2
 800442a:	424b      	negs	r3, r1
 800442c:	4159      	adcs	r1, r3
 800442e:	b2c9      	uxtb	r1, r1
 8004430:	f7fc f8e6 	bl	8000600 <_test_assert>
 8004434:	1e06      	subs	r6, r0, #0
 8004436:	d118      	bne.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004438:	b662      	cpsie	i
 800443a:	2404      	movs	r4, #4
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800443c:	b672      	cpsid	i
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 800443e:	1c28      	adds	r0, r5, #0
 8004440:	f7fc fb7e 	bl	8000b40 <chOQGetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004444:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 8004446:	b2c0      	uxtb	r0, r0
 8004448:	3c01      	subs	r4, #1
 800444a:	f7fc f8f1 	bl	8000630 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800444e:	2c00      	cmp	r4, #0
 8004450:	d1f4      	bne.n	800443c <queues2_execute.lto_priv.122+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004452:	b672      	cpsid	i
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8004454:	696b      	ldr	r3, [r5, #20]
 8004456:	69aa      	ldr	r2, [r5, #24]
 8004458:	4293      	cmp	r3, r2
 800445a:	d100      	bne.n	800445e <queues2_execute.lto_priv.122+0x6e>
 800445c:	e0bc      	b.n	80045d8 <queues2_execute.lto_priv.122+0x1e8>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800445e:	2003      	movs	r0, #3
 8004460:	1c31      	adds	r1, r6, #0
 8004462:	f7fc f8cd 	bl	8000600 <_test_assert>
 8004466:	2800      	cmp	r0, #0
 8004468:	d002      	beq.n	8004470 <queues2_execute.lto_priv.122+0x80>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800446a:	b662      	cpsie	i
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 800446c:	b002      	add	sp, #8
 800446e:	bd70      	pop	{r4, r5, r6, pc}
 8004470:	b662      	cpsie	i
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 8004472:	2004      	movs	r0, #4
 8004474:	495d      	ldr	r1, [pc, #372]	; (80045ec <queues2_execute.lto_priv.122+0x1fc>)
 8004476:	f7fc f893 	bl	80005a0 <_test_assert_sequence>
 800447a:	2800      	cmp	r0, #0
 800447c:	d1f6      	bne.n	800446c <queues2_execute.lto_priv.122+0x7c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800447e:	b672      	cpsid	i
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8004480:	1c28      	adds	r0, r5, #0
 8004482:	f7fc fb5d 	bl	8000b40 <chOQGetI>
 8004486:	3003      	adds	r0, #3
 8004488:	4241      	negs	r1, r0
 800448a:	4141      	adcs	r1, r0
 800448c:	2005      	movs	r0, #5
 800448e:	b2c9      	uxtb	r1, r1
 8004490:	f7fc f8b6 	bl	8000600 <_test_assert>
 8004494:	2800      	cmp	r0, #0
 8004496:	d1e8      	bne.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004498:	b662      	cpsie	i

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800449a:	4c55      	ldr	r4, [pc, #340]	; (80045f0 <queues2_execute.lto_priv.122+0x200>)
 800449c:	2300      	movs	r3, #0
 800449e:	1c21      	adds	r1, r4, #0
 80044a0:	1c28      	adds	r0, r5, #0
 80044a2:	2208      	movs	r2, #8
 80044a4:	f7fc ff64 	bl	8001370 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80044a8:	1f01      	subs	r1, r0, #4
 80044aa:	424b      	negs	r3, r1
 80044ac:	414b      	adcs	r3, r1
 80044ae:	2006      	movs	r0, #6
 80044b0:	b2d9      	uxtb	r1, r3
 80044b2:	f7fc f8a5 	bl	8000600 <_test_assert>
 80044b6:	2800      	cmp	r0, #0
 80044b8:	d1d8      	bne.n	800446c <queues2_execute.lto_priv.122+0x7c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80044ba:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 80044bc:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 80044be:	3007      	adds	r0, #7
 80044c0:	424b      	negs	r3, r1
 80044c2:	4159      	adcs	r1, r3
 80044c4:	b2c9      	uxtb	r1, r1
 80044c6:	f7fc f89b 	bl	8000600 <_test_assert>
 80044ca:	2800      	cmp	r0, #0
 80044cc:	d1cd      	bne.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80044ce:	b662      	cpsie	i
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80044d0:	1c23      	adds	r3, r4, #0
 80044d2:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80044d4:	4a47      	ldr	r2, [pc, #284]	; (80045f4 <queues2_execute.lto_priv.122+0x204>)
 80044d6:	3b49      	subs	r3, #73	; 0x49
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80044d8:	6992      	ldr	r2, [r2, #24]
 80044da:	3bff      	subs	r3, #255	; 0xff
 80044dc:	6892      	ldr	r2, [r2, #8]
 80044de:	0049      	lsls	r1, r1, #1
 80044e0:	9000      	str	r0, [sp, #0]
 80044e2:	3201      	adds	r2, #1
 80044e4:	1c18      	adds	r0, r3, #0
 80044e6:	4b44      	ldr	r3, [pc, #272]	; (80045f8 <queues2_execute.lto_priv.122+0x208>)
 80044e8:	f7fc fa6a 	bl	80009c0 <chThdCreateStatic>
 80044ec:	4b43      	ldr	r3, [pc, #268]	; (80045fc <queues2_execute.lto_priv.122+0x20c>)
 80044ee:	6018      	str	r0, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80044f0:	b672      	cpsid	i
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 80044f2:	692b      	ldr	r3, [r5, #16]
 80044f4:	68ea      	ldr	r2, [r5, #12]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 80044f6:	2008      	movs	r0, #8
 80044f8:	1a99      	subs	r1, r3, r2
 80044fa:	68ab      	ldr	r3, [r5, #8]
 80044fc:	1ac9      	subs	r1, r1, r3
 80044fe:	3904      	subs	r1, #4
 8004500:	424a      	negs	r2, r1
 8004502:	414a      	adcs	r2, r1
 8004504:	b2d1      	uxtb	r1, r2
 8004506:	f7fc f87b 	bl	8000600 <_test_assert>
 800450a:	2800      	cmp	r0, #0
 800450c:	d1ad      	bne.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800450e:	b662      	cpsie	i
  test_wait_threads();
 8004510:	f7fc fd96 	bl	8001040 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004514:	b672      	cpsid	i

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8004516:	2602      	movs	r6, #2
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8004518:	68eb      	ldr	r3, [r5, #12]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800451a:	692a      	ldr	r2, [r5, #16]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800451c:	6828      	ldr	r0, [r5, #0]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 800451e:	61ab      	str	r3, [r5, #24]
  oqp->q_wrptr = oqp->q_buffer;
 8004520:	616b      	str	r3, [r5, #20]
  oqp->q_counter = chQSizeX(oqp);
 8004522:	1ad3      	subs	r3, r2, r3
 8004524:	60ab      	str	r3, [r5, #8]
 8004526:	4276      	negs	r6, r6
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 8004528:	42a8      	cmp	r0, r5
 800452a:	d008      	beq.n	800453e <queues2_execute.lto_priv.122+0x14e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800452c:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800452e:	605d      	str	r5, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8004530:	602b      	str	r3, [r5, #0]
 8004532:	6206      	str	r6, [r0, #32]
  (void) chSchReadyI(tp);
 8004534:	f7fc fac4 	bl	8000ac0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004538:	6828      	ldr	r0, [r5, #0]
 800453a:	42a8      	cmp	r0, r5
 800453c:	d1f6      	bne.n	800452c <queues2_execute.lto_priv.122+0x13c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800453e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004540:	b672      	cpsid	i
 8004542:	692b      	ldr	r3, [r5, #16]
 8004544:	68ea      	ldr	r2, [r5, #12]

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 8004546:	2009      	movs	r0, #9
 8004548:	1a99      	subs	r1, r3, r2
 800454a:	68ab      	ldr	r3, [r5, #8]
 800454c:	1ac9      	subs	r1, r1, r3
 800454e:	424a      	negs	r2, r1
 8004550:	414a      	adcs	r2, r1
 8004552:	b2d1      	uxtb	r1, r2
 8004554:	f7fc f854 	bl	8000600 <_test_assert>
 8004558:	2800      	cmp	r0, #0
 800455a:	d000      	beq.n	800455e <queues2_execute.lto_priv.122+0x16e>
 800455c:	e785      	b.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800455e:	b662      	cpsie	i

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8004560:	2202      	movs	r2, #2
 8004562:	1c21      	adds	r1, r4, #0
 8004564:	2300      	movs	r3, #0
 8004566:	1c28      	adds	r0, r5, #0
 8004568:	f7fc ff02 	bl	8001370 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800456c:	1e81      	subs	r1, r0, #2
 800456e:	424b      	negs	r3, r1
 8004570:	414b      	adcs	r3, r1
 8004572:	200a      	movs	r0, #10
 8004574:	b2d9      	uxtb	r1, r3
 8004576:	f7fc f843 	bl	8000600 <_test_assert>
 800457a:	1e03      	subs	r3, r0, #0
 800457c:	d000      	beq.n	8004580 <queues2_execute.lto_priv.122+0x190>
 800457e:	e775      	b.n	800446c <queues2_execute.lto_priv.122+0x7c>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8004580:	1c21      	adds	r1, r4, #0
 8004582:	1c28      	adds	r0, r5, #0
 8004584:	2202      	movs	r2, #2
 8004586:	f7fc fef3 	bl	8001370 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800458a:	1e81      	subs	r1, r0, #2
 800458c:	424b      	negs	r3, r1
 800458e:	414b      	adcs	r3, r1
 8004590:	200b      	movs	r0, #11
 8004592:	b2d9      	uxtb	r1, r3
 8004594:	f7fc f834 	bl	8000600 <_test_assert>
 8004598:	2800      	cmp	r0, #0
 800459a:	d000      	beq.n	800459e <queues2_execute.lto_priv.122+0x1ae>
 800459c:	e766      	b.n	800446c <queues2_execute.lto_priv.122+0x7c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800459e:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 80045a0:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 80045a2:	300c      	adds	r0, #12
 80045a4:	424b      	negs	r3, r1
 80045a6:	4159      	adcs	r1, r3
 80045a8:	b2c9      	uxtb	r1, r1
 80045aa:	f7fc f829 	bl	8000600 <_test_assert>
 80045ae:	1e01      	subs	r1, r0, #0
 80045b0:	d000      	beq.n	80045b4 <queues2_execute.lto_priv.122+0x1c4>
 80045b2:	e75a      	b.n	800446a <queues2_execute.lto_priv.122+0x7a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80045b4:	b662      	cpsie	i

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 80045b6:	220a      	movs	r2, #10
 80045b8:	1c28      	adds	r0, r5, #0
 80045ba:	f7fc ff29 	bl	8001410 <chOQPutTimeout>
 80045be:	1c41      	adds	r1, r0, #1
 80045c0:	424b      	negs	r3, r1
 80045c2:	414b      	adcs	r3, r1
 80045c4:	200d      	movs	r0, #13
 80045c6:	b2d9      	uxtb	r1, r3
 80045c8:	f7fc f81a 	bl	8000600 <_test_assert>
 80045cc:	e74e      	b.n	800446c <queues2_execute.lto_priv.122+0x7c>
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80045ce:	68a9      	ldr	r1, [r5, #8]
 80045d0:	1e4b      	subs	r3, r1, #1
 80045d2:	4199      	sbcs	r1, r3
 80045d4:	b2c9      	uxtb	r1, r1
 80045d6:	e715      	b.n	8004404 <queues2_execute.lto_priv.122+0x14>
 80045d8:	68ae      	ldr	r6, [r5, #8]
 80045da:	1e73      	subs	r3, r6, #1
 80045dc:	419e      	sbcs	r6, r3
 80045de:	b2f6      	uxtb	r6, r6
 80045e0:	e73d      	b.n	800445e <queues2_execute.lto_priv.122+0x6e>
 80045e2:	46c0      	nop			; (mov r8, r8)
 80045e4:	2000065c 	.word	0x2000065c
 80045e8:	0000ffff 	.word	0x0000ffff
 80045ec:	08006270 	.word	0x08006270
 80045f0:	20000808 	.word	0x20000808
 80045f4:	20000f20 	.word	0x20000f20
 80045f8:	080043d1 	.word	0x080043d1
 80045fc:	20001090 	.word	0x20001090

08004600 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8004600:	b508      	push	{r3, lr}

  chThdExit((msg_t)p);
 8004602:	f7fc fdad 	bl	8001160 <chThdExit>
}
 8004606:	bd08      	pop	{r3, pc}
 8004608:	46c0      	nop			; (mov r8, r8)
 800460a:	46c0      	nop			; (mov r8, r8)
 800460c:	46c0      	nop			; (mov r8, r8)
 800460e:	46c0      	nop			; (mov r8, r8)

08004610 <notify.lto_priv.141>:

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
  (void)qp;
}
 8004610:	4770      	bx	lr
 8004612:	46c0      	nop			; (mov r8, r8)
 8004614:	46c0      	nop			; (mov r8, r8)
 8004616:	46c0      	nop			; (mov r8, r8)
 8004618:	46c0      	nop			; (mov r8, r8)
 800461a:	46c0      	nop			; (mov r8, r8)
 800461c:	46c0      	nop			; (mov r8, r8)
 800461e:	46c0      	nop			; (mov r8, r8)

08004620 <queues2_setup.lto_priv.121>:
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8004620:	2204      	movs	r2, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004622:	4b07      	ldr	r3, [pc, #28]	; (8004640 <queues2_setup.lto_priv.121+0x20>)
 8004624:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8004626:	4a07      	ldr	r2, [pc, #28]	; (8004644 <queues2_setup.lto_priv.121+0x24>)
 8004628:	601b      	str	r3, [r3, #0]
 800462a:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800462c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800462e:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8004630:	3204      	adds	r2, #4
 8004632:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8004634:	4a04      	ldr	r2, [pc, #16]	; (8004648 <queues2_setup.lto_priv.121+0x28>)
  tqp->p_prev = (thread_t *)tqp;
 8004636:	605b      	str	r3, [r3, #4]
 8004638:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800463a:	2200      	movs	r2, #0
 800463c:	621a      	str	r2, [r3, #32]
 */

static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800463e:	4770      	bx	lr
 8004640:	2000065c 	.word	0x2000065c
 8004644:	200006c0 	.word	0x200006c0
 8004648:	08004611 	.word	0x08004611
 800464c:	46c0      	nop			; (mov r8, r8)
 800464e:	46c0      	nop			; (mov r8, r8)

08004650 <queues1_setup.lto_priv.119>:
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8004650:	2100      	movs	r1, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004652:	4b07      	ldr	r3, [pc, #28]	; (8004670 <queues1_setup.lto_priv.119+0x20>)
  iqp->q_buffer  = bp;
 8004654:	4a07      	ldr	r2, [pc, #28]	; (8004674 <queues1_setup.lto_priv.119+0x24>)
 8004656:	601b      	str	r3, [r3, #0]
 8004658:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800465a:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800465c:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800465e:	3204      	adds	r2, #4
 8004660:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8004662:	4a05      	ldr	r2, [pc, #20]	; (8004678 <queues1_setup.lto_priv.119+0x28>)
  tqp->p_prev = (thread_t *)tqp;
 8004664:	605b      	str	r3, [r3, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8004666:	6099      	str	r1, [r3, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8004668:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800466a:	6219      	str	r1, [r3, #32]
 */

static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800466c:	4770      	bx	lr
 800466e:	46c0      	nop			; (mov r8, r8)
 8004670:	2000068c 	.word	0x2000068c
 8004674:	200006c0 	.word	0x200006c0
 8004678:	08004611 	.word	0x08004611
 800467c:	46c0      	nop			; (mov r8, r8)
 800467e:	46c0      	nop			; (mov r8, r8)

08004680 <dyn3_setup.lto_priv.117>:

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8004680:	20cc      	movs	r0, #204	; 0xcc
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8004682:	2200      	movs	r2, #0
 8004684:	4b06      	ldr	r3, [pc, #24]	; (80046a0 <dyn3_setup.lto_priv.117+0x20>)
  heapp->h_free.h.u.next = hp;
 8004686:	4907      	ldr	r1, [pc, #28]	; (80046a4 <dyn3_setup.lto_priv.117+0x24>)
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8004688:	00c0      	lsls	r0, r0, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 800468a:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 800468c:	600a      	str	r2, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
 800468e:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004690:	1c19      	adds	r1, r3, #0
 8004692:	3110      	adds	r1, #16
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8004694:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8004696:	60da      	str	r2, [r3, #12]
 8004698:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 800469a:	6159      	str	r1, [r3, #20]
 800469c:	619a      	str	r2, [r3, #24]
}

static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 800469e:	4770      	bx	lr
 80046a0:	20000e70 	.word	0x20000e70
 80046a4:	200006c0 	.word	0x200006c0
 80046a8:	46c0      	nop			; (mov r8, r8)
 80046aa:	46c0      	nop			; (mov r8, r8)
 80046ac:	46c0      	nop			; (mov r8, r8)
 80046ae:	46c0      	nop			; (mov r8, r8)

080046b0 <dyn2_setup.lto_priv.115>:
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 80046b0:	21a4      	movs	r1, #164	; 0xa4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80046b2:	2200      	movs	r2, #0
 80046b4:	4b02      	ldr	r3, [pc, #8]	; (80046c0 <dyn2_setup.lto_priv.115+0x10>)
  mp->mp_object_size = size;
 80046b6:	0049      	lsls	r1, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80046b8:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80046ba:	6059      	str	r1, [r3, #4]
  mp->mp_provider = provider;
 80046bc:	609a      	str	r2, [r3, #8]
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 80046be:	4770      	bx	lr
 80046c0:	20000f14 	.word	0x20000f14
 80046c4:	46c0      	nop			; (mov r8, r8)
 80046c6:	46c0      	nop			; (mov r8, r8)
 80046c8:	46c0      	nop			; (mov r8, r8)
 80046ca:	46c0      	nop			; (mov r8, r8)
 80046cc:	46c0      	nop			; (mov r8, r8)
 80046ce:	46c0      	nop			; (mov r8, r8)

080046d0 <dyn1_setup.lto_priv.113>:
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 80046d0:	20cc      	movs	r0, #204	; 0xcc
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 80046d2:	2200      	movs	r2, #0
 80046d4:	4b06      	ldr	r3, [pc, #24]	; (80046f0 <dyn1_setup.lto_priv.113+0x20>)
  heapp->h_free.h.u.next = hp;
 80046d6:	4907      	ldr	r1, [pc, #28]	; (80046f4 <dyn1_setup.lto_priv.113+0x24>)
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 80046d8:	00c0      	lsls	r0, r0, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 80046da:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 80046dc:	600a      	str	r2, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
 80046de:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80046e0:	1c19      	adds	r1, r3, #0
 80046e2:	3110      	adds	r1, #16
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 80046e4:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 80046e6:	60da      	str	r2, [r3, #12]
 80046e8:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 80046ea:	6159      	str	r1, [r3, #20]
 80046ec:	619a      	str	r2, [r3, #24]

#if (CH_CFG_USE_HEAP && !CH_CFG_USE_MALLOC_HEAP) || defined(__DOXYGEN__)
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 80046ee:	4770      	bx	lr
 80046f0:	20000e70 	.word	0x20000e70
 80046f4:	200006c0 	.word	0x200006c0
 80046f8:	46c0      	nop			; (mov r8, r8)
 80046fa:	46c0      	nop			; (mov r8, r8)
 80046fc:	46c0      	nop			; (mov r8, r8)
 80046fe:	46c0      	nop			; (mov r8, r8)

08004700 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8004700:	2000      	movs	r0, #0
 8004702:	4770      	bx	lr
 8004704:	46c0      	nop			; (mov r8, r8)
 8004706:	46c0      	nop			; (mov r8, r8)
 8004708:	46c0      	nop			; (mov r8, r8)
 800470a:	46c0      	nop			; (mov r8, r8)
 800470c:	46c0      	nop			; (mov r8, r8)
 800470e:	46c0      	nop			; (mov r8, r8)

08004710 <pools1_setup.lto_priv.111>:
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 8004710:	21a4      	movs	r1, #164	; 0xa4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8004712:	2200      	movs	r2, #0
 8004714:	4b02      	ldr	r3, [pc, #8]	; (8004720 <pools1_setup.lto_priv.111+0x10>)
  mp->mp_object_size = size;
 8004716:	0049      	lsls	r1, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8004718:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 800471a:	6059      	str	r1, [r3, #4]
  mp->mp_provider = provider;
 800471c:	609a      	str	r2, [r3, #8]

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 800471e:	4770      	bx	lr
 8004720:	20000680 	.word	0x20000680
 8004724:	46c0      	nop			; (mov r8, r8)
 8004726:	46c0      	nop			; (mov r8, r8)
 8004728:	46c0      	nop			; (mov r8, r8)
 800472a:	46c0      	nop			; (mov r8, r8)
 800472c:	46c0      	nop			; (mov r8, r8)
 800472e:	46c0      	nop			; (mov r8, r8)

08004730 <thread1>:

static THD_FUNCTION(thread1, p) {
 8004730:	b508      	push	{r3, lr}

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8004732:	4802      	ldr	r0, [pc, #8]	; (800473c <thread1+0xc>)
 8004734:	21c8      	movs	r1, #200	; 0xc8
 8004736:	f7fc feeb 	bl	8001510 <chIQGetTimeout>
}
 800473a:	bd08      	pop	{r3, pc}
 800473c:	2000068c 	.word	0x2000068c

08004740 <thread.lto_priv.62>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 8004740:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8004742:	7800      	ldrb	r0, [r0, #0]
 8004744:	f7fb ff74 	bl	8000630 <test_emit_token>
}
 8004748:	bd08      	pop	{r3, pc}
 800474a:	46c0      	nop			; (mov r8, r8)
 800474c:	46c0      	nop			; (mov r8, r8)
 800474e:	46c0      	nop			; (mov r8, r8)

08004750 <queues1_execute.lto_priv.120>:

static void queues1_execute(void) {
 8004750:	b570      	push	{r4, r5, r6, lr}
 8004752:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004754:	b672      	cpsid	i
 8004756:	4d7f      	ldr	r5, [pc, #508]	; (8004954 <queues1_execute.lto_priv.120+0x204>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 8004758:	2001      	movs	r0, #1
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800475a:	68a9      	ldr	r1, [r5, #8]
 800475c:	424b      	negs	r3, r1
 800475e:	4159      	adcs	r1, r3
 8004760:	b2c9      	uxtb	r1, r1
 8004762:	f7fb ff4d 	bl	8000600 <_test_assert>
 8004766:	1e06      	subs	r6, r0, #0
 8004768:	d117      	bne.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800476a:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800476c:	b672      	cpsid	i
 800476e:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8004770:	1c21      	adds	r1, r4, #0
 8004772:	3401      	adds	r4, #1
 8004774:	1c28      	adds	r0, r5, #0
 8004776:	b2e4      	uxtb	r4, r4
 8004778:	f7fc f9b2 	bl	8000ae0 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800477c:	2c45      	cmp	r4, #69	; 0x45
 800477e:	d1f7      	bne.n	8004770 <queues1_execute.lto_priv.120+0x20>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004780:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004782:	b672      	cpsid	i
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8004784:	69ab      	ldr	r3, [r5, #24]
 8004786:	696a      	ldr	r2, [r5, #20]
 8004788:	4293      	cmp	r3, r2
 800478a:	d100      	bne.n	800478e <queues1_execute.lto_priv.120+0x3e>
 800478c:	e0dc      	b.n	8004948 <queues1_execute.lto_priv.120+0x1f8>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800478e:	2002      	movs	r0, #2
 8004790:	1c31      	adds	r1, r6, #0
 8004792:	f7fb ff35 	bl	8000600 <_test_assert>
 8004796:	2800      	cmp	r0, #0
 8004798:	d002      	beq.n	80047a0 <queues1_execute.lto_priv.120+0x50>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800479a:	b662      	cpsie	i
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 800479c:	b002      	add	sp, #8
 800479e:	bd70      	pop	{r4, r5, r6, pc}
 80047a0:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047a2:	b672      	cpsid	i
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 80047a4:	2100      	movs	r1, #0
 80047a6:	1c28      	adds	r0, r5, #0
 80047a8:	f7fc f99a 	bl	8000ae0 <chIQPutI>
 80047ac:	3004      	adds	r0, #4
 80047ae:	4241      	negs	r1, r0
 80047b0:	4141      	adcs	r1, r0
 80047b2:	2003      	movs	r0, #3
 80047b4:	b2c9      	uxtb	r1, r1
 80047b6:	f7fb ff23 	bl	8000600 <_test_assert>
 80047ba:	2800      	cmp	r0, #0
 80047bc:	d1ed      	bne.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047be:	b662      	cpsie	i
 80047c0:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 80047c2:	4965      	ldr	r1, [pc, #404]	; (8004958 <queues1_execute.lto_priv.120+0x208>)
 80047c4:	1c28      	adds	r0, r5, #0
 80047c6:	f7fc fea3 	bl	8001510 <chIQGetTimeout>
 80047ca:	3c01      	subs	r4, #1

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 80047cc:	b2c0      	uxtb	r0, r0
 80047ce:	f7fb ff2f 	bl	8000630 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80047d2:	2c00      	cmp	r4, #0
 80047d4:	d1f5      	bne.n	80047c2 <queues1_execute.lto_priv.120+0x72>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047d6:	b672      	cpsid	i
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80047d8:	68a9      	ldr	r1, [r5, #8]
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 80047da:	2004      	movs	r0, #4
 80047dc:	424b      	negs	r3, r1
 80047de:	4159      	adcs	r1, r3
 80047e0:	b2c9      	uxtb	r1, r1
 80047e2:	f7fb ff0d 	bl	8000600 <_test_assert>
 80047e6:	2800      	cmp	r0, #0
 80047e8:	d1d7      	bne.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047ea:	b662      	cpsie	i
  test_assert_sequence(5, "ABCD");
 80047ec:	2005      	movs	r0, #5
 80047ee:	495b      	ldr	r1, [pc, #364]	; (800495c <queues1_execute.lto_priv.120+0x20c>)
 80047f0:	f7fb fed6 	bl	80005a0 <_test_assert_sequence>
 80047f4:	2800      	cmp	r0, #0
 80047f6:	d1d1      	bne.n	800479c <queues1_execute.lto_priv.120+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047f8:	b672      	cpsid	i
 80047fa:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80047fc:	1c21      	adds	r1, r4, #0
 80047fe:	3401      	adds	r4, #1
 8004800:	1c28      	adds	r0, r5, #0
 8004802:	b2e4      	uxtb	r4, r4
 8004804:	f7fc f96c 	bl	8000ae0 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8004808:	2c45      	cmp	r4, #69	; 0x45
 800480a:	d1f7      	bne.n	80047fc <queues1_execute.lto_priv.120+0xac>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800480c:	b662      	cpsie	i
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800480e:	4e54      	ldr	r6, [pc, #336]	; (8004960 <queues1_execute.lto_priv.120+0x210>)
 8004810:	2300      	movs	r3, #0
 8004812:	1c31      	adds	r1, r6, #0
 8004814:	1c28      	adds	r0, r5, #0
 8004816:	2208      	movs	r2, #8
 8004818:	f7fc fe32 	bl	8001480 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800481c:	1f01      	subs	r1, r0, #4
 800481e:	424b      	negs	r3, r1
 8004820:	414b      	adcs	r3, r1
 8004822:	2006      	movs	r0, #6
 8004824:	b2d9      	uxtb	r1, r3
 8004826:	f7fb feeb 	bl	8000600 <_test_assert>
 800482a:	2800      	cmp	r0, #0
 800482c:	d1b6      	bne.n	800479c <queues1_execute.lto_priv.120+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800482e:	b672      	cpsid	i
 8004830:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8004832:	3007      	adds	r0, #7
 8004834:	424b      	negs	r3, r1
 8004836:	4159      	adcs	r1, r3
 8004838:	b2c9      	uxtb	r1, r1
 800483a:	f7fb fee1 	bl	8000600 <_test_assert>
 800483e:	2800      	cmp	r0, #0
 8004840:	d1ab      	bne.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004842:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004844:	b672      	cpsid	i
 8004846:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8004848:	1c21      	adds	r1, r4, #0
 800484a:	3401      	adds	r4, #1
 800484c:	1c28      	adds	r0, r5, #0
 800484e:	b2e4      	uxtb	r4, r4
 8004850:	f7fc f946 	bl	8000ae0 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8004854:	2c45      	cmp	r4, #69	; 0x45
 8004856:	d1f7      	bne.n	8004848 <queues1_execute.lto_priv.120+0xf8>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004858:	b662      	cpsie	i
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800485a:	2300      	movs	r3, #0
 800485c:	1c31      	adds	r1, r6, #0
 800485e:	1c28      	adds	r0, r5, #0
 8004860:	2202      	movs	r2, #2
 8004862:	f7fc fe0d 	bl	8001480 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8004866:	1e81      	subs	r1, r0, #2
 8004868:	424b      	negs	r3, r1
 800486a:	414b      	adcs	r3, r1
 800486c:	2008      	movs	r0, #8
 800486e:	b2d9      	uxtb	r1, r3
 8004870:	f7fb fec6 	bl	8000600 <_test_assert>
 8004874:	2800      	cmp	r0, #0
 8004876:	d000      	beq.n	800487a <queues1_execute.lto_priv.120+0x12a>
 8004878:	e790      	b.n	800479c <queues1_execute.lto_priv.120+0x4c>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800487a:	1c31      	adds	r1, r6, #0
 800487c:	2300      	movs	r3, #0
 800487e:	1c28      	adds	r0, r5, #0
 8004880:	2202      	movs	r2, #2
 8004882:	f7fc fdfd 	bl	8001480 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8004886:	1e81      	subs	r1, r0, #2
 8004888:	424b      	negs	r3, r1
 800488a:	414b      	adcs	r3, r1
 800488c:	2009      	movs	r0, #9
 800488e:	b2d9      	uxtb	r1, r3
 8004890:	f7fb feb6 	bl	8000600 <_test_assert>
 8004894:	2800      	cmp	r0, #0
 8004896:	d000      	beq.n	800489a <queues1_execute.lto_priv.120+0x14a>
 8004898:	e780      	b.n	800479c <queues1_execute.lto_priv.120+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800489a:	b672      	cpsid	i
 800489c:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800489e:	300a      	adds	r0, #10
 80048a0:	424b      	negs	r3, r1
 80048a2:	4159      	adcs	r1, r3
 80048a4:	b2c9      	uxtb	r1, r1
 80048a6:	f7fb feab 	bl	8000600 <_test_assert>
 80048aa:	1e04      	subs	r4, r0, #0
 80048ac:	d000      	beq.n	80048b0 <queues1_execute.lto_priv.120+0x160>
 80048ae:	e774      	b.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80048b0:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80048b2:	b672      	cpsid	i

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 80048b4:	2100      	movs	r1, #0
 80048b6:	1c28      	adds	r0, r5, #0
 80048b8:	f7fc f912 	bl	8000ae0 <chIQPutI>

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80048bc:	60ac      	str	r4, [r5, #8]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80048be:	2402      	movs	r4, #2
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80048c0:	68eb      	ldr	r3, [r5, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80048c2:	6828      	ldr	r0, [r5, #0]
 80048c4:	61ab      	str	r3, [r5, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80048c6:	616b      	str	r3, [r5, #20]
 80048c8:	4264      	negs	r4, r4
 80048ca:	42a8      	cmp	r0, r5
 80048cc:	d008      	beq.n	80048e0 <queues1_execute.lto_priv.120+0x190>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80048ce:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80048d0:	605d      	str	r5, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80048d2:	602b      	str	r3, [r5, #0]
 80048d4:	6204      	str	r4, [r0, #32]
  (void) chSchReadyI(tp);
 80048d6:	f7fc f8f3 	bl	8000ac0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80048da:	6828      	ldr	r0, [r5, #0]
 80048dc:	42a8      	cmp	r0, r5
 80048de:	d1f6      	bne.n	80048ce <queues1_execute.lto_priv.120+0x17e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80048e0:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80048e2:	b672      	cpsid	i
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 80048e4:	68a9      	ldr	r1, [r5, #8]
 80048e6:	200b      	movs	r0, #11
 80048e8:	424b      	negs	r3, r1
 80048ea:	4159      	adcs	r1, r3
 80048ec:	b2c9      	uxtb	r1, r1
 80048ee:	f7fb fe87 	bl	8000600 <_test_assert>
 80048f2:	2800      	cmp	r0, #0
 80048f4:	d000      	beq.n	80048f8 <queues1_execute.lto_priv.120+0x1a8>
 80048f6:	e750      	b.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80048f8:	b662      	cpsie	i
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 80048fa:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80048fc:	4b19      	ldr	r3, [pc, #100]	; (8004964 <queues1_execute.lto_priv.120+0x214>)
 80048fe:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004900:	699b      	ldr	r3, [r3, #24]
 8004902:	689a      	ldr	r2, [r3, #8]
 8004904:	9000      	str	r0, [sp, #0]
 8004906:	3201      	adds	r2, #1
 8004908:	4b17      	ldr	r3, [pc, #92]	; (8004968 <queues1_execute.lto_priv.120+0x218>)
 800490a:	4818      	ldr	r0, [pc, #96]	; (800496c <queues1_execute.lto_priv.120+0x21c>)
 800490c:	f7fc f858 	bl	80009c0 <chThdCreateStatic>
 8004910:	4b17      	ldr	r3, [pc, #92]	; (8004970 <queues1_execute.lto_priv.120+0x220>)
 8004912:	6018      	str	r0, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004914:	b672      	cpsid	i
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 8004916:	68a9      	ldr	r1, [r5, #8]
 8004918:	200c      	movs	r0, #12
 800491a:	424b      	negs	r3, r1
 800491c:	4159      	adcs	r1, r3
 800491e:	b2c9      	uxtb	r1, r1
 8004920:	f7fb fe6e 	bl	8000600 <_test_assert>
 8004924:	2800      	cmp	r0, #0
 8004926:	d000      	beq.n	800492a <queues1_execute.lto_priv.120+0x1da>
 8004928:	e737      	b.n	800479a <queues1_execute.lto_priv.120+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800492a:	b662      	cpsie	i
  test_wait_threads();
 800492c:	f7fc fb88 	bl	8001040 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8004930:	1c28      	adds	r0, r5, #0
 8004932:	210a      	movs	r1, #10
 8004934:	f7fc fdec 	bl	8001510 <chIQGetTimeout>
 8004938:	1c41      	adds	r1, r0, #1
 800493a:	424b      	negs	r3, r1
 800493c:	414b      	adcs	r3, r1
 800493e:	200d      	movs	r0, #13
 8004940:	b2d9      	uxtb	r1, r3
 8004942:	f7fb fe5d 	bl	8000600 <_test_assert>
 8004946:	e729      	b.n	800479c <queues1_execute.lto_priv.120+0x4c>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8004948:	68ae      	ldr	r6, [r5, #8]
 800494a:	1e73      	subs	r3, r6, #1
 800494c:	419e      	sbcs	r6, r3
 800494e:	b2f6      	uxtb	r6, r6
 8004950:	e71d      	b.n	800478e <queues1_execute.lto_priv.120+0x3e>
 8004952:	46c0      	nop			; (mov r8, r8)
 8004954:	2000068c 	.word	0x2000068c
 8004958:	0000ffff 	.word	0x0000ffff
 800495c:	08006270 	.word	0x08006270
 8004960:	20000808 	.word	0x20000808
 8004964:	20000f20 	.word	0x20000f20
 8004968:	08004731 	.word	0x08004731
 800496c:	200006c0 	.word	0x200006c0
 8004970:	20001090 	.word	0x20001090
 8004974:	46c0      	nop			; (mov r8, r8)
 8004976:	46c0      	nop			; (mov r8, r8)
 8004978:	46c0      	nop			; (mov r8, r8)
 800497a:	46c0      	nop			; (mov r8, r8)
 800497c:	46c0      	nop			; (mov r8, r8)
 800497e:	46c0      	nop			; (mov r8, r8)

08004980 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8004980:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004982:	1c07      	adds	r7, r0, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004984:	b672      	cpsid	i
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8004986:	4e0e      	ldr	r6, [pc, #56]	; (80049c0 <regfind+0x40>)
 8004988:	6930      	ldr	r0, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800498a:	7f83      	ldrb	r3, [r0, #30]
 800498c:	3301      	adds	r3, #1
 800498e:	7783      	strb	r3, [r0, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004990:	b662      	cpsie	i
  thread_t *ftp;
  bool found = false;
 8004992:	2500      	movs	r5, #0
 8004994:	e000      	b.n	8004998 <regfind+0x18>

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
 8004996:	1c20      	adds	r0, r4, #0
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
 8004998:	1bc3      	subs	r3, r0, r7
 800499a:	425a      	negs	r2, r3
 800499c:	4153      	adcs	r3, r2
 800499e:	431d      	orrs	r5, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049a0:	b672      	cpsid	i
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 80049a2:	6904      	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80049a4:	42b4      	cmp	r4, r6
 80049a6:	d009      	beq.n	80049bc <regfind+0x3c>
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 80049a8:	7fa3      	ldrb	r3, [r4, #30]
 80049aa:	3301      	adds	r3, #1
 80049ac:	77a3      	strb	r3, [r4, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80049ae:	b662      	cpsie	i
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80049b0:	f7fc fb06 	bl	8000fc0 <chThdRelease>
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
 80049b4:	2c00      	cmp	r4, #0
 80049b6:	d1ee      	bne.n	8004996 <regfind+0x16>
  return found;
}
 80049b8:	1c28      	adds	r0, r5, #0
 80049ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 80049bc:	2400      	movs	r4, #0
 80049be:	e7f6      	b.n	80049ae <regfind+0x2e>
 80049c0:	20000f20 	.word	0x20000f20
 80049c4:	46c0      	nop			; (mov r8, r8)
 80049c6:	46c0      	nop			; (mov r8, r8)
 80049c8:	46c0      	nop			; (mov r8, r8)
 80049ca:	46c0      	nop			; (mov r8, r8)
 80049cc:	46c0      	nop			; (mov r8, r8)
 80049ce:	46c0      	nop			; (mov r8, r8)

080049d0 <dyn3_execute.lto_priv.118>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80049d0:	4b44      	ldr	r3, [pc, #272]	; (8004ae4 <dyn3_execute.lto_priv.118+0x114>)
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 80049d2:	b510      	push	{r4, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80049d4:	699b      	ldr	r3, [r3, #24]
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 80049d6:	4944      	ldr	r1, [pc, #272]	; (8004ae8 <dyn3_execute.lto_priv.118+0x118>)
 80049d8:	6898      	ldr	r0, [r3, #8]
 80049da:	3801      	subs	r0, #1
 80049dc:	f7fd fda0 	bl	8002520 <chThdCreateFromHeap.constprop.57>
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 80049e0:	7f81      	ldrb	r1, [r0, #30]
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 80049e2:	1c04      	adds	r4, r0, #0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 80049e4:	3901      	subs	r1, #1
 80049e6:	424b      	negs	r3, r1
 80049e8:	4159      	adcs	r1, r3
 80049ea:	2001      	movs	r0, #1
 80049ec:	b2c9      	uxtb	r1, r1
 80049ee:	f7fb fe07 	bl	8000600 <_test_assert>
 80049f2:	2800      	cmp	r0, #0
 80049f4:	d000      	beq.n	80049f8 <dyn3_execute.lto_priv.118+0x28>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
}
 80049f6:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049f8:	b672      	cpsid	i
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 80049fa:	7fa3      	ldrb	r3, [r4, #30]
 80049fc:	3301      	adds	r3, #1
 80049fe:	77a3      	strb	r3, [r4, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004a00:	b662      	cpsie	i

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
  chThdAddRef(tp);
  test_assert(2, tp->p_refs == 2, "references increase failure");
 8004a02:	7fa1      	ldrb	r1, [r4, #30]
 8004a04:	3002      	adds	r0, #2
 8004a06:	3902      	subs	r1, #2
 8004a08:	424b      	negs	r3, r1
 8004a0a:	4159      	adcs	r1, r3
 8004a0c:	b2c9      	uxtb	r1, r1
 8004a0e:	f7fb fdf7 	bl	8000600 <_test_assert>
 8004a12:	2800      	cmp	r0, #0
 8004a14:	d1ef      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  chThdRelease(tp);
 8004a16:	1c20      	adds	r0, r4, #0
 8004a18:	f7fc fad2 	bl	8000fc0 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8004a1c:	7fa1      	ldrb	r1, [r4, #30]
 8004a1e:	2003      	movs	r0, #3
 8004a20:	3901      	subs	r1, #1
 8004a22:	424b      	negs	r3, r1
 8004a24:	4159      	adcs	r1, r3
 8004a26:	b2c9      	uxtb	r1, r1
 8004a28:	f7fb fdea 	bl	8000600 <_test_assert>
 8004a2c:	2800      	cmp	r0, #0
 8004a2e:	d1e2      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 8004a30:	1c20      	adds	r0, r4, #0
 8004a32:	f7ff ffa5 	bl	8004980 <regfind>
 8004a36:	1c01      	adds	r1, r0, #0
 8004a38:	2004      	movs	r0, #4
 8004a3a:	f7fb fde1 	bl	8000600 <_test_assert>
 8004a3e:	2800      	cmp	r0, #0
 8004a40:	d1d9      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  test_assert(5, regfind(tp), "thread disappeared");
 8004a42:	1c20      	adds	r0, r4, #0
 8004a44:	f7ff ff9c 	bl	8004980 <regfind>
 8004a48:	1c01      	adds	r1, r0, #0
 8004a4a:	2005      	movs	r0, #5
 8004a4c:	f7fb fdd8 	bl	8000600 <_test_assert>
 8004a50:	2800      	cmp	r0, #0
 8004a52:	d1d0      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 8004a54:	1c20      	adds	r0, r4, #0
 8004a56:	f7fc fab3 	bl	8000fc0 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8004a5a:	7fa1      	ldrb	r1, [r4, #30]
 8004a5c:	2006      	movs	r0, #6
 8004a5e:	424b      	negs	r3, r1
 8004a60:	4159      	adcs	r1, r3
 8004a62:	b2c9      	uxtb	r1, r1
 8004a64:	f7fb fdcc 	bl	8000600 <_test_assert>
 8004a68:	2800      	cmp	r0, #0
 8004a6a:	d1c4      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8004a6c:	7f21      	ldrb	r1, [r4, #28]
 8004a6e:	3007      	adds	r0, #7
 8004a70:	424b      	negs	r3, r1
 8004a72:	4159      	adcs	r1, r3
 8004a74:	b2c9      	uxtb	r1, r1
 8004a76:	f7fb fdc3 	bl	8000600 <_test_assert>
 8004a7a:	2800      	cmp	r0, #0
 8004a7c:	d1bb      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  test_assert(8, regfind(tp), "thread disappeared");
 8004a7e:	1c20      	adds	r0, r4, #0
 8004a80:	f7ff ff7e 	bl	8004980 <regfind>
 8004a84:	1c01      	adds	r1, r0, #0
 8004a86:	2008      	movs	r0, #8
 8004a88:	f7fb fdba 	bl	8000600 <_test_assert>
 8004a8c:	2800      	cmp	r0, #0
 8004a8e:	d1b2      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  test_assert(9, regfind(tp), "thread disappeared");
 8004a90:	1c20      	adds	r0, r4, #0
 8004a92:	f7ff ff75 	bl	8004980 <regfind>
 8004a96:	1c01      	adds	r1, r0, #0
 8004a98:	2009      	movs	r0, #9
 8004a9a:	f7fb fdb1 	bl	8000600 <_test_assert>
 8004a9e:	2800      	cmp	r0, #0
 8004aa0:	d1a9      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 8004aa2:	3032      	adds	r0, #50	; 0x32
 8004aa4:	f7fc fd64 	bl	8001570 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8004aa8:	7f21      	ldrb	r1, [r4, #28]
 8004aaa:	200a      	movs	r0, #10
 8004aac:	390f      	subs	r1, #15
 8004aae:	424b      	negs	r3, r1
 8004ab0:	4159      	adcs	r1, r3
 8004ab2:	b2c9      	uxtb	r1, r1
 8004ab4:	f7fb fda4 	bl	8000600 <_test_assert>
 8004ab8:	2800      	cmp	r0, #0
 8004aba:	d19c      	bne.n	80049f6 <dyn3_execute.lto_priv.118+0x26>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8004abc:	1c20      	adds	r0, r4, #0
 8004abe:	f7ff ff5f 	bl	8004980 <regfind>
 8004ac2:	1c01      	adds	r1, r0, #0
 8004ac4:	200b      	movs	r0, #11
 8004ac6:	f7fb fd9b 	bl	8000600 <_test_assert>
 8004aca:	2800      	cmp	r0, #0
 8004acc:	d000      	beq.n	8004ad0 <dyn3_execute.lto_priv.118+0x100>
 8004ace:	e792      	b.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
  test_assert(12, !regfind(tp), "thread still in registry");
 8004ad0:	1c20      	adds	r0, r4, #0
 8004ad2:	f7ff ff55 	bl	8004980 <regfind>
 8004ad6:	2101      	movs	r1, #1
 8004ad8:	4041      	eors	r1, r0
 8004ada:	b2c9      	uxtb	r1, r1
 8004adc:	200c      	movs	r0, #12
 8004ade:	f7fb fd8f 	bl	8000600 <_test_assert>
 8004ae2:	e788      	b.n	80049f6 <dyn3_execute.lto_priv.118+0x26>
 8004ae4:	20000f20 	.word	0x20000f20
 8004ae8:	080055f4 	.word	0x080055f4
 8004aec:	46c0      	nop			; (mov r8, r8)
 8004aee:	46c0      	nop			; (mov r8, r8)

08004af0 <pools1_execute.lto_priv.112>:

static void pools1_execute(void) {
 8004af0:	2205      	movs	r2, #5
 8004af2:	b538      	push	{r3, r4, r5, lr}
 8004af4:	4b2d      	ldr	r3, [pc, #180]	; (8004bac <pools1_execute.lto_priv.112+0xbc>)
 8004af6:	4c2e      	ldr	r4, [pc, #184]	; (8004bb0 <pools1_execute.lto_priv.112+0xc0>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004af8:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8004afa:	6821      	ldr	r1, [r4, #0]
  mp->mp_next = php;
 8004afc:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8004afe:	6019      	str	r1, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004b00:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8004b02:	6861      	ldr	r1, [r4, #4]
 8004b04:	3a01      	subs	r2, #1
 8004b06:	468c      	mov	ip, r1
 8004b08:	4463      	add	r3, ip
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8004b0a:	2a00      	cmp	r2, #0
 8004b0c:	d1f4      	bne.n	8004af8 <pools1_execute.lto_priv.112+0x8>
 8004b0e:	2505      	movs	r5, #5
  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8004b10:	1c20      	adds	r0, r4, #0
 8004b12:	f7fb fe6d 	bl	80007f0 <chPoolAlloc>
 8004b16:	1e41      	subs	r1, r0, #1
 8004b18:	4188      	sbcs	r0, r1
 8004b1a:	b2c1      	uxtb	r1, r0
 8004b1c:	2001      	movs	r0, #1
 8004b1e:	f7fb fd6f 	bl	8000600 <_test_assert>
 8004b22:	2800      	cmp	r0, #0
 8004b24:	d131      	bne.n	8004b8a <pools1_execute.lto_priv.112+0x9a>
 8004b26:	3d01      	subs	r5, #1

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004b28:	2d00      	cmp	r5, #0
 8004b2a:	d1f1      	bne.n	8004b10 <pools1_execute.lto_priv.112+0x20>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8004b2c:	1c20      	adds	r0, r4, #0
 8004b2e:	f7fb fe5f 	bl	80007f0 <chPoolAlloc>
 8004b32:	4241      	negs	r1, r0
 8004b34:	4141      	adcs	r1, r0
 8004b36:	2002      	movs	r0, #2
 8004b38:	b2c9      	uxtb	r1, r1
 8004b3a:	f7fb fd61 	bl	8000600 <_test_assert>
 8004b3e:	2800      	cmp	r0, #0
 8004b40:	d123      	bne.n	8004b8a <pools1_execute.lto_priv.112+0x9a>
 8004b42:	4a1c      	ldr	r2, [pc, #112]	; (8004bb4 <pools1_execute.lto_priv.112+0xc4>)

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8004b44:	5953      	ldr	r3, [r2, r5]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004b46:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8004b48:	6821      	ldr	r1, [r4, #0]
 8004b4a:	6019      	str	r1, [r3, #0]
  mp->mp_next = php;
 8004b4c:	6023      	str	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004b4e:	b662      	cpsie	i
 8004b50:	3504      	adds	r5, #4

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004b52:	2d14      	cmp	r5, #20
 8004b54:	d1f6      	bne.n	8004b44 <pools1_execute.lto_priv.112+0x54>
 8004b56:	3d0f      	subs	r5, #15
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 8004b58:	1c20      	adds	r0, r4, #0
 8004b5a:	f7fb fe49 	bl	80007f0 <chPoolAlloc>
 8004b5e:	1e41      	subs	r1, r0, #1
 8004b60:	4188      	sbcs	r0, r1
 8004b62:	b2c1      	uxtb	r1, r0
 8004b64:	2003      	movs	r0, #3
 8004b66:	f7fb fd4b 	bl	8000600 <_test_assert>
 8004b6a:	2800      	cmp	r0, #0
 8004b6c:	d10d      	bne.n	8004b8a <pools1_execute.lto_priv.112+0x9a>
 8004b6e:	3d01      	subs	r5, #1
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004b70:	2d00      	cmp	r5, #0
 8004b72:	d1f1      	bne.n	8004b58 <pools1_execute.lto_priv.112+0x68>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 8004b74:	1c20      	adds	r0, r4, #0
 8004b76:	f7fb fe3b 	bl	80007f0 <chPoolAlloc>
 8004b7a:	4241      	negs	r1, r0
 8004b7c:	4141      	adcs	r1, r0
 8004b7e:	2004      	movs	r0, #4
 8004b80:	b2c9      	uxtb	r1, r1
 8004b82:	f7fb fd3d 	bl	8000600 <_test_assert>
 8004b86:	2800      	cmp	r0, #0
 8004b88:	d000      	beq.n	8004b8c <pools1_execute.lto_priv.112+0x9c>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
}
 8004b8a:	bd38      	pop	{r3, r4, r5, pc}
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 8004b8c:	2310      	movs	r3, #16
 8004b8e:	6063      	str	r3, [r4, #4]
  mp->mp_provider = provider;
 8004b90:	4b09      	ldr	r3, [pc, #36]	; (8004bb8 <pools1_execute.lto_priv.112+0xc8>)
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8004b92:	1c20      	adds	r0, r4, #0
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8004b94:	6025      	str	r5, [r4, #0]
  mp->mp_object_size = size;
  mp->mp_provider = provider;
 8004b96:	60a3      	str	r3, [r4, #8]
 8004b98:	f7fb fe2a 	bl	80007f0 <chPoolAlloc>
 8004b9c:	4241      	negs	r1, r0
 8004b9e:	4141      	adcs	r1, r0
 8004ba0:	2005      	movs	r0, #5
 8004ba2:	b2c9      	uxtb	r1, r1
 8004ba4:	f7fb fd2c 	bl	8000600 <_test_assert>
 8004ba8:	e7ef      	b.n	8004b8a <pools1_execute.lto_priv.112+0x9a>
 8004baa:	46c0      	nop			; (mov r8, r8)
 8004bac:	200006c0 	.word	0x200006c0
 8004bb0:	20000680 	.word	0x20000680
 8004bb4:	08006280 	.word	0x08006280
 8004bb8:	08004701 	.word	0x08004701
 8004bbc:	46c0      	nop			; (mov r8, r8)
 8004bbe:	46c0      	nop			; (mov r8, r8)

08004bc0 <dyn2_execute.lto_priv.116>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004bc0:	4b32      	ldr	r3, [pc, #200]	; (8004c8c <dyn2_execute.lto_priv.116+0xcc>)
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8004bc2:	b570      	push	{r4, r5, r6, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004bc4:	699b      	ldr	r3, [r3, #24]
 8004bc6:	4932      	ldr	r1, [pc, #200]	; (8004c90 <dyn2_execute.lto_priv.116+0xd0>)
 8004bc8:	689e      	ldr	r6, [r3, #8]
 8004bca:	2300      	movs	r3, #0
 8004bcc:	4c31      	ldr	r4, [pc, #196]	; (8004c94 <dyn2_execute.lto_priv.116+0xd4>)
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 8004bce:	58ca      	ldr	r2, [r1, r3]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004bd0:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8004bd2:	6820      	ldr	r0, [r4, #0]
 8004bd4:	6010      	str	r0, [r2, #0]
  mp->mp_next = php;
 8004bd6:	6022      	str	r2, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004bd8:	b662      	cpsie	i
 8004bda:	3304      	adds	r3, #4
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8004bdc:	2b10      	cmp	r3, #16
 8004bde:	d1f6      	bne.n	8004bce <dyn2_execute.lto_priv.116+0xe>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8004be0:	492d      	ldr	r1, [pc, #180]	; (8004c98 <dyn2_execute.lto_priv.116+0xd8>)
 8004be2:	1e70      	subs	r0, r6, #1
 8004be4:	f7fd fcdc 	bl	80025a0 <chThdCreateFromMemoryPool.constprop.56>
 8004be8:	4d2c      	ldr	r5, [pc, #176]	; (8004c9c <dyn2_execute.lto_priv.116+0xdc>)
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004bea:	492d      	ldr	r1, [pc, #180]	; (8004ca0 <dyn2_execute.lto_priv.116+0xe0>)
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8004bec:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004bee:	1eb0      	subs	r0, r6, #2
 8004bf0:	f7fd fcd6 	bl	80025a0 <chThdCreateFromMemoryPool.constprop.56>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004bf4:	492b      	ldr	r1, [pc, #172]	; (8004ca4 <dyn2_execute.lto_priv.116+0xe4>)
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8004bf6:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004bf8:	1ef0      	subs	r0, r6, #3
 8004bfa:	f7fd fcd1 	bl	80025a0 <chThdCreateFromMemoryPool.constprop.56>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004bfe:	492a      	ldr	r1, [pc, #168]	; (8004ca8 <dyn2_execute.lto_priv.116+0xe8>)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8004c00:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004c02:	1f30      	subs	r0, r6, #4
 8004c04:	f7fd fccc 	bl	80025a0 <chThdCreateFromMemoryPool.constprop.56>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004c08:	4928      	ldr	r1, [pc, #160]	; (8004cac <dyn2_execute.lto_priv.116+0xec>)

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8004c0a:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004c0c:	1f70      	subs	r0, r6, #5
 8004c0e:	f7fd fcc7 	bl	80025a0 <chThdCreateFromMemoryPool.constprop.56>

  test_assert(1, (threads[0] != NULL) &&
 8004c12:	682b      	ldr	r3, [r5, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8004c14:	6128      	str	r0, [r5, #16]

  test_assert(1, (threads[0] != NULL) &&
 8004c16:	2b00      	cmp	r3, #0
 8004c18:	d011      	beq.n	8004c3e <dyn2_execute.lto_priv.116+0x7e>
 8004c1a:	686b      	ldr	r3, [r5, #4]
 8004c1c:	2b00      	cmp	r3, #0
 8004c1e:	d00e      	beq.n	8004c3e <dyn2_execute.lto_priv.116+0x7e>
 8004c20:	68ab      	ldr	r3, [r5, #8]
 8004c22:	2b00      	cmp	r3, #0
 8004c24:	d00b      	beq.n	8004c3e <dyn2_execute.lto_priv.116+0x7e>
 8004c26:	68eb      	ldr	r3, [r5, #12]
 8004c28:	2b00      	cmp	r3, #0
 8004c2a:	d008      	beq.n	8004c3e <dyn2_execute.lto_priv.116+0x7e>
 8004c2c:	4241      	negs	r1, r0
 8004c2e:	4141      	adcs	r1, r0
 8004c30:	2001      	movs	r0, #1
 8004c32:	b2c9      	uxtb	r1, r1
 8004c34:	f7fb fce4 	bl	8000600 <_test_assert>
 8004c38:	2800      	cmp	r0, #0
 8004c3a:	d006      	beq.n	8004c4a <dyn2_execute.lto_priv.116+0x8a>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
}
 8004c3c:	bd70      	pop	{r4, r5, r6, pc}
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");

  test_assert(1, (threads[0] != NULL) &&
 8004c3e:	2100      	movs	r1, #0
 8004c40:	2001      	movs	r0, #1
 8004c42:	f7fb fcdd 	bl	8000600 <_test_assert>
 8004c46:	2800      	cmp	r0, #0
 8004c48:	d1f8      	bne.n	8004c3c <dyn2_execute.lto_priv.116+0x7c>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8004c4a:	f7fc f9f9 	bl	8001040 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8004c4e:	2002      	movs	r0, #2
 8004c50:	4917      	ldr	r1, [pc, #92]	; (8004cb0 <dyn2_execute.lto_priv.116+0xf0>)
 8004c52:	f7fb fca5 	bl	80005a0 <_test_assert_sequence>
 8004c56:	2800      	cmp	r0, #0
 8004c58:	d1f0      	bne.n	8004c3c <dyn2_execute.lto_priv.116+0x7c>
 8004c5a:	2504      	movs	r5, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8004c5c:	1c20      	adds	r0, r4, #0
 8004c5e:	f7fb fdc7 	bl	80007f0 <chPoolAlloc>
 8004c62:	1e41      	subs	r1, r0, #1
 8004c64:	4188      	sbcs	r0, r1
 8004c66:	b2c1      	uxtb	r1, r0
 8004c68:	2003      	movs	r0, #3
 8004c6a:	f7fb fcc9 	bl	8000600 <_test_assert>
 8004c6e:	2800      	cmp	r0, #0
 8004c70:	d1e4      	bne.n	8004c3c <dyn2_execute.lto_priv.116+0x7c>
 8004c72:	3d01      	subs	r5, #1
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8004c74:	2d00      	cmp	r5, #0
 8004c76:	d1f1      	bne.n	8004c5c <dyn2_execute.lto_priv.116+0x9c>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8004c78:	1c20      	adds	r0, r4, #0
 8004c7a:	f7fb fdb9 	bl	80007f0 <chPoolAlloc>
 8004c7e:	4241      	negs	r1, r0
 8004c80:	4141      	adcs	r1, r0
 8004c82:	2004      	movs	r0, #4
 8004c84:	b2c9      	uxtb	r1, r1
 8004c86:	f7fb fcbb 	bl	8000600 <_test_assert>
 8004c8a:	e7d7      	b.n	8004c3c <dyn2_execute.lto_priv.116+0x7c>
 8004c8c:	20000f20 	.word	0x20000f20
 8004c90:	08006280 	.word	0x08006280
 8004c94:	20000f14 	.word	0x20000f14
 8004c98:	080055f4 	.word	0x080055f4
 8004c9c:	20001090 	.word	0x20001090
 8004ca0:	080055f0 	.word	0x080055f0
 8004ca4:	080055fc 	.word	0x080055fc
 8004ca8:	080055f8 	.word	0x080055f8
 8004cac:	08005604 	.word	0x08005604
 8004cb0:	08006270 	.word	0x08006270
 8004cb4:	46c0      	nop			; (mov r8, r8)
 8004cb6:	46c0      	nop			; (mov r8, r8)
 8004cb8:	46c0      	nop			; (mov r8, r8)
 8004cba:	46c0      	nop			; (mov r8, r8)
 8004cbc:	46c0      	nop			; (mov r8, r8)
 8004cbe:	46c0      	nop			; (mov r8, r8)

08004cc0 <dyn1_execute.lto_priv.114>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004cc2:	4b2f      	ldr	r3, [pc, #188]	; (8004d80 <dyn1_execute.lto_priv.114+0xc0>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8004cc4:	4e2f      	ldr	r6, [pc, #188]	; (8004d84 <dyn1_execute.lto_priv.114+0xc4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004cc6:	699b      	ldr	r3, [r3, #24]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8004cc8:	b083      	sub	sp, #12
 8004cca:	689d      	ldr	r5, [r3, #8]
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8004ccc:	a901      	add	r1, sp, #4
 8004cce:	1c30      	adds	r0, r6, #0
 8004cd0:	f7fc f906 	bl	8000ee0 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8004cd4:	492c      	ldr	r1, [pc, #176]	; (8004d88 <dyn1_execute.lto_priv.114+0xc8>)
 8004cd6:	1e68      	subs	r0, r5, #1
 8004cd8:	f7fd fc22 	bl	8002520 <chThdCreateFromHeap.constprop.57>
 8004cdc:	4c2b      	ldr	r4, [pc, #172]	; (8004d8c <dyn1_execute.lto_priv.114+0xcc>)
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004cde:	492c      	ldr	r1, [pc, #176]	; (8004d90 <dyn1_execute.lto_priv.114+0xd0>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8004ce0:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004ce2:	1ea8      	subs	r0, r5, #2
 8004ce4:	f7fd fc1c 	bl	8002520 <chThdCreateFromHeap.constprop.57>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8004ce8:	4669      	mov	r1, sp
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8004cea:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8004cec:	1c30      	adds	r0, r6, #0
 8004cee:	f7fc f8f7 	bl	8000ee0 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8004cf2:	9900      	ldr	r1, [sp, #0]
 8004cf4:	1c30      	adds	r0, r6, #0
 8004cf6:	f7fc f9bb 	bl	8001070 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 8004cfa:	4926      	ldr	r1, [pc, #152]	; (8004d94 <dyn1_execute.lto_priv.114+0xd4>)
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 8004cfc:	1c07      	adds	r7, r0, #0
  threads[2] = chThdCreateFromHeap(&heap1,
 8004cfe:	1ee8      	subs	r0, r5, #3
 8004d00:	f7fd fc0e 	bl	8002520 <chThdCreateFromHeap.constprop.57>
 8004d04:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8004d06:	1c38      	adds	r0, r7, #0
 8004d08:	f7fc f912 	bl	8000f30 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8004d0c:	6823      	ldr	r3, [r4, #0]
 8004d0e:	2b00      	cmp	r3, #0
 8004d10:	d02c      	beq.n	8004d6c <dyn1_execute.lto_priv.114+0xac>
 8004d12:	6863      	ldr	r3, [r4, #4]
 8004d14:	2100      	movs	r1, #0
 8004d16:	2b00      	cmp	r3, #0
 8004d18:	d002      	beq.n	8004d20 <dyn1_execute.lto_priv.114+0x60>
 8004d1a:	68a3      	ldr	r3, [r4, #8]
 8004d1c:	2b00      	cmp	r3, #0
 8004d1e:	d027      	beq.n	8004d70 <dyn1_execute.lto_priv.114+0xb0>
 8004d20:	2001      	movs	r0, #1
 8004d22:	f7fb fc6d 	bl	8000600 <_test_assert>
 8004d26:	2800      	cmp	r0, #0
 8004d28:	d001      	beq.n	8004d2e <dyn1_execute.lto_priv.114+0x6e>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 8004d2a:	b003      	add	sp, #12
 8004d2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8004d2e:	f7fc f987 	bl	8001040 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8004d32:	2002      	movs	r0, #2
 8004d34:	4918      	ldr	r1, [pc, #96]	; (8004d98 <dyn1_execute.lto_priv.114+0xd8>)
 8004d36:	f7fb fc33 	bl	80005a0 <_test_assert_sequence>
 8004d3a:	2800      	cmp	r0, #0
 8004d3c:	d1f5      	bne.n	8004d2a <dyn1_execute.lto_priv.114+0x6a>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8004d3e:	4669      	mov	r1, sp
 8004d40:	1c30      	adds	r0, r6, #0
 8004d42:	f7fc f8cd 	bl	8000ee0 <chHeapStatus>
 8004d46:	1e41      	subs	r1, r0, #1
 8004d48:	424b      	negs	r3, r1
 8004d4a:	414b      	adcs	r3, r1
 8004d4c:	2003      	movs	r0, #3
 8004d4e:	b2d9      	uxtb	r1, r3
 8004d50:	f7fb fc56 	bl	8000600 <_test_assert>
 8004d54:	2800      	cmp	r0, #0
 8004d56:	d1e8      	bne.n	8004d2a <dyn1_execute.lto_priv.114+0x6a>
  test_assert(4, n == sz, "heap size changed");
 8004d58:	9b00      	ldr	r3, [sp, #0]
 8004d5a:	9a01      	ldr	r2, [sp, #4]
 8004d5c:	3004      	adds	r0, #4
 8004d5e:	1a99      	subs	r1, r3, r2
 8004d60:	424a      	negs	r2, r1
 8004d62:	414a      	adcs	r2, r1
 8004d64:	b2d1      	uxtb	r1, r2
 8004d66:	f7fb fc4b 	bl	8000600 <_test_assert>
 8004d6a:	e7de      	b.n	8004d2a <dyn1_execute.lto_priv.114+0x6a>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 8004d6c:	2100      	movs	r1, #0
 8004d6e:	e7d7      	b.n	8004d20 <dyn1_execute.lto_priv.114+0x60>
 8004d70:	68e3      	ldr	r3, [r4, #12]
 8004d72:	2b00      	cmp	r3, #0
 8004d74:	d1d4      	bne.n	8004d20 <dyn1_execute.lto_priv.114+0x60>
 8004d76:	6923      	ldr	r3, [r4, #16]
 8004d78:	4259      	negs	r1, r3
 8004d7a:	4159      	adcs	r1, r3
 8004d7c:	b2c9      	uxtb	r1, r1
 8004d7e:	e7cf      	b.n	8004d20 <dyn1_execute.lto_priv.114+0x60>
 8004d80:	20000f20 	.word	0x20000f20
 8004d84:	20000e70 	.word	0x20000e70
 8004d88:	080055f4 	.word	0x080055f4
 8004d8c:	20001090 	.word	0x20001090
 8004d90:	080055f0 	.word	0x080055f0
 8004d94:	080055fc 	.word	0x080055fc
 8004d98:	080062a0 	.word	0x080062a0
 8004d9c:	46c0      	nop			; (mov r8, r8)
 8004d9e:	46c0      	nop			; (mov r8, r8)

08004da0 <heap1_execute.lto_priv.110>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8004da0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004da2:	b083      	sub	sp, #12

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8004da4:	a901      	add	r1, sp, #4
 8004da6:	2000      	movs	r0, #0
 8004da8:	f7fc f89a 	bl	8000ee0 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8004dac:	2110      	movs	r1, #16
 8004dae:	2000      	movs	r0, #0
 8004db0:	f7fc f95e 	bl	8001070 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8004db4:	1c01      	adds	r1, r0, #0
 8004db6:	1e4b      	subs	r3, r1, #1
 8004db8:	4199      	sbcs	r1, r3
  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
 8004dba:	1c04      	adds	r4, r0, #0
  test_assert(1, p1 != NULL, "allocation failed");
 8004dbc:	b2c9      	uxtb	r1, r1
 8004dbe:	2001      	movs	r0, #1
 8004dc0:	f7fb fc1e 	bl	8000600 <_test_assert>
 8004dc4:	2800      	cmp	r0, #0
 8004dc6:	d001      	beq.n	8004dcc <heap1_execute.lto_priv.110+0x2c>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8004dc8:	b003      	add	sp, #12
 8004dca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8004dcc:	1c20      	adds	r0, r4, #0
 8004dce:	f7fc f8af 	bl	8000f30 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8004dd2:	4982      	ldr	r1, [pc, #520]	; (8004fdc <heap1_execute.lto_priv.110+0x23c>)
 8004dd4:	2000      	movs	r0, #0
 8004dd6:	f7fc f94b 	bl	8001070 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8004dda:	4241      	negs	r1, r0
 8004ddc:	4141      	adcs	r1, r0
 8004dde:	2002      	movs	r0, #2
 8004de0:	b2c9      	uxtb	r1, r1
 8004de2:	f7fb fc0d 	bl	8000600 <_test_assert>
 8004de6:	2800      	cmp	r0, #0
 8004de8:	d1ee      	bne.n	8004dc8 <heap1_execute.lto_priv.110+0x28>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8004dea:	4c7d      	ldr	r4, [pc, #500]	; (8004fe0 <heap1_execute.lto_priv.110+0x240>)
 8004dec:	a901      	add	r1, sp, #4
 8004dee:	1c20      	adds	r0, r4, #0
 8004df0:	f7fc f876 	bl	8000ee0 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004df4:	2110      	movs	r1, #16
 8004df6:	1c20      	adds	r0, r4, #0
 8004df8:	f7fc f93a 	bl	8001070 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004dfc:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004dfe:	1c07      	adds	r7, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e00:	1c20      	adds	r0, r4, #0
 8004e02:	f7fc f935 	bl	8001070 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004e06:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e08:	1c06      	adds	r6, r0, #0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004e0a:	1c20      	adds	r0, r4, #0
 8004e0c:	f7fc f930 	bl	8001070 <chHeapAlloc>
 8004e10:	1c05      	adds	r5, r0, #0
  chHeapFree(p1);                               /* Does not merge.*/
 8004e12:	1c38      	adds	r0, r7, #0
 8004e14:	f7fc f88c 	bl	8000f30 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8004e18:	1c30      	adds	r0, r6, #0
 8004e1a:	f7fc f889 	bl	8000f30 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8004e1e:	1c28      	adds	r0, r5, #0
 8004e20:	f7fc f886 	bl	8000f30 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004e24:	4669      	mov	r1, sp
 8004e26:	1c20      	adds	r0, r4, #0
 8004e28:	f7fc f85a 	bl	8000ee0 <chHeapStatus>
 8004e2c:	1e41      	subs	r1, r0, #1
 8004e2e:	4248      	negs	r0, r1
 8004e30:	4141      	adcs	r1, r0
 8004e32:	2003      	movs	r0, #3
 8004e34:	b2c9      	uxtb	r1, r1
 8004e36:	f7fb fbe3 	bl	8000600 <_test_assert>
 8004e3a:	2800      	cmp	r0, #0
 8004e3c:	d1c4      	bne.n	8004dc8 <heap1_execute.lto_priv.110+0x28>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004e3e:	2110      	movs	r1, #16
 8004e40:	1c20      	adds	r0, r4, #0
 8004e42:	f7fc f915 	bl	8001070 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e46:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004e48:	1c05      	adds	r5, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e4a:	1c20      	adds	r0, r4, #0
 8004e4c:	f7fc f910 	bl	8001070 <chHeapAlloc>
 8004e50:	1c06      	adds	r6, r0, #0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004e52:	2110      	movs	r1, #16
 8004e54:	1c20      	adds	r0, r4, #0
 8004e56:	f7fc f90b 	bl	8001070 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8004e5a:	f7fc f869 	bl	8000f30 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8004e5e:	1c30      	adds	r0, r6, #0
 8004e60:	f7fc f866 	bl	8000f30 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8004e64:	1c28      	adds	r0, r5, #0
 8004e66:	f7fc f863 	bl	8000f30 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004e6a:	4669      	mov	r1, sp
 8004e6c:	1c20      	adds	r0, r4, #0
 8004e6e:	f7fc f837 	bl	8000ee0 <chHeapStatus>
 8004e72:	1e41      	subs	r1, r0, #1
 8004e74:	4248      	negs	r0, r1
 8004e76:	4141      	adcs	r1, r0
 8004e78:	2004      	movs	r0, #4
 8004e7a:	b2c9      	uxtb	r1, r1
 8004e7c:	f7fb fbc0 	bl	8000600 <_test_assert>
 8004e80:	2800      	cmp	r0, #0
 8004e82:	d1a1      	bne.n	8004dc8 <heap1_execute.lto_priv.110+0x28>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8004e84:	2111      	movs	r1, #17
 8004e86:	1c20      	adds	r0, r4, #0
 8004e88:	f7fc f8f2 	bl	8001070 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e8c:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8004e8e:	1c05      	adds	r5, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004e90:	1c20      	adds	r0, r4, #0
 8004e92:	f7fc f8ed 	bl	8001070 <chHeapAlloc>
 8004e96:	1c06      	adds	r6, r0, #0
  chHeapFree(p1);
 8004e98:	1c28      	adds	r0, r5, #0
 8004e9a:	f7fc f849 	bl	8000f30 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8004e9e:	4669      	mov	r1, sp
 8004ea0:	1c20      	adds	r0, r4, #0
 8004ea2:	f7fc f81d 	bl	8000ee0 <chHeapStatus>
 8004ea6:	1e81      	subs	r1, r0, #2
 8004ea8:	4248      	negs	r0, r1
 8004eaa:	4141      	adcs	r1, r0
 8004eac:	2005      	movs	r0, #5
 8004eae:	b2c9      	uxtb	r1, r1
 8004eb0:	f7fb fba6 	bl	8000600 <_test_assert>
 8004eb4:	2800      	cmp	r0, #0
 8004eb6:	d000      	beq.n	8004eba <heap1_execute.lto_priv.110+0x11a>
 8004eb8:	e786      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004eba:	2110      	movs	r1, #16
 8004ebc:	1c20      	adds	r0, r4, #0
 8004ebe:	f7fc f8d7 	bl	8001070 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004ec2:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004ec4:	1c05      	adds	r5, r0, #0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004ec6:	1c20      	adds	r0, r4, #0
 8004ec8:	f7fc f80a 	bl	8000ee0 <chHeapStatus>
 8004ecc:	2101      	movs	r1, #1
 8004ece:	2801      	cmp	r0, #1
 8004ed0:	d007      	beq.n	8004ee2 <heap1_execute.lto_priv.110+0x142>
 8004ed2:	4669      	mov	r1, sp
 8004ed4:	1c20      	adds	r0, r4, #0
 8004ed6:	f7fc f803 	bl	8000ee0 <chHeapStatus>
 8004eda:	1e81      	subs	r1, r0, #2
 8004edc:	4248      	negs	r0, r1
 8004ede:	4141      	adcs	r1, r0
 8004ee0:	b2c9      	uxtb	r1, r1
 8004ee2:	2006      	movs	r0, #6
 8004ee4:	f7fb fb8c 	bl	8000600 <_test_assert>
 8004ee8:	2800      	cmp	r0, #0
 8004eea:	d000      	beq.n	8004eee <heap1_execute.lto_priv.110+0x14e>
 8004eec:	e76c      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8004eee:	1c30      	adds	r0, r6, #0
 8004ef0:	f7fc f81e 	bl	8000f30 <chHeapFree>
  chHeapFree(p1);
 8004ef4:	1c28      	adds	r0, r5, #0
 8004ef6:	f7fc f81b 	bl	8000f30 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004efa:	4669      	mov	r1, sp
 8004efc:	1c20      	adds	r0, r4, #0
 8004efe:	f7fb ffef 	bl	8000ee0 <chHeapStatus>
 8004f02:	1e41      	subs	r1, r0, #1
 8004f04:	4248      	negs	r0, r1
 8004f06:	4141      	adcs	r1, r0
 8004f08:	2007      	movs	r0, #7
 8004f0a:	b2c9      	uxtb	r1, r1
 8004f0c:	f7fb fb78 	bl	8000600 <_test_assert>
 8004f10:	2800      	cmp	r0, #0
 8004f12:	d000      	beq.n	8004f16 <heap1_execute.lto_priv.110+0x176>
 8004f14:	e758      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004f16:	2110      	movs	r1, #16
 8004f18:	1c20      	adds	r0, r4, #0
 8004f1a:	f7fc f8a9 	bl	8001070 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004f1e:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004f20:	1c06      	adds	r6, r0, #0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004f22:	1c20      	adds	r0, r4, #0
 8004f24:	f7fc f8a4 	bl	8001070 <chHeapAlloc>
 8004f28:	1c05      	adds	r5, r0, #0
  chHeapFree(p1);
 8004f2a:	1c30      	adds	r0, r6, #0
 8004f2c:	f7fc f800 	bl	8000f30 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8004f30:	4669      	mov	r1, sp
 8004f32:	1c20      	adds	r0, r4, #0
 8004f34:	f7fb ffd4 	bl	8000ee0 <chHeapStatus>
 8004f38:	1e81      	subs	r1, r0, #2
 8004f3a:	4248      	negs	r0, r1
 8004f3c:	4141      	adcs	r1, r0
 8004f3e:	2008      	movs	r0, #8
 8004f40:	b2c9      	uxtb	r1, r1
 8004f42:	f7fb fb5d 	bl	8000600 <_test_assert>
 8004f46:	2800      	cmp	r0, #0
 8004f48:	d000      	beq.n	8004f4c <heap1_execute.lto_priv.110+0x1ac>
 8004f4a:	e73d      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8004f4c:	2120      	movs	r1, #32
 8004f4e:	1c20      	adds	r0, r4, #0
 8004f50:	f7fc f88e 	bl	8001070 <chHeapAlloc>
  chHeapFree(p1);
 8004f54:	f7fb ffec 	bl	8000f30 <chHeapFree>
  chHeapFree(p2);
 8004f58:	1c28      	adds	r0, r5, #0
 8004f5a:	f7fb ffe9 	bl	8000f30 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004f5e:	4669      	mov	r1, sp
 8004f60:	1c20      	adds	r0, r4, #0
 8004f62:	f7fb ffbd 	bl	8000ee0 <chHeapStatus>
 8004f66:	1e41      	subs	r1, r0, #1
 8004f68:	4248      	negs	r0, r1
 8004f6a:	4141      	adcs	r1, r0
 8004f6c:	2009      	movs	r0, #9
 8004f6e:	b2c9      	uxtb	r1, r1
 8004f70:	f7fb fb46 	bl	8000600 <_test_assert>
 8004f74:	2800      	cmp	r0, #0
 8004f76:	d000      	beq.n	8004f7a <heap1_execute.lto_priv.110+0x1da>
 8004f78:	e726      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 8004f7a:	4669      	mov	r1, sp
 8004f7c:	1c20      	adds	r0, r4, #0
 8004f7e:	f7fb ffaf 	bl	8000ee0 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8004f82:	9900      	ldr	r1, [sp, #0]
 8004f84:	1c20      	adds	r0, r4, #0
 8004f86:	f7fc f873 	bl	8001070 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8004f8a:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 8004f8c:	1c05      	adds	r5, r0, #0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8004f8e:	1c20      	adds	r0, r4, #0
 8004f90:	f7fb ffa6 	bl	8000ee0 <chHeapStatus>
 8004f94:	4241      	negs	r1, r0
 8004f96:	4141      	adcs	r1, r0
 8004f98:	200a      	movs	r0, #10
 8004f9a:	b2c9      	uxtb	r1, r1
 8004f9c:	f7fb fb30 	bl	8000600 <_test_assert>
 8004fa0:	2800      	cmp	r0, #0
 8004fa2:	d000      	beq.n	8004fa6 <heap1_execute.lto_priv.110+0x206>
 8004fa4:	e710      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
  chHeapFree(p1);
 8004fa6:	1c28      	adds	r0, r5, #0
 8004fa8:	f7fb ffc2 	bl	8000f30 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004fac:	4669      	mov	r1, sp
 8004fae:	1c20      	adds	r0, r4, #0
 8004fb0:	f7fb ff96 	bl	8000ee0 <chHeapStatus>
 8004fb4:	1e41      	subs	r1, r0, #1
 8004fb6:	4248      	negs	r0, r1
 8004fb8:	4141      	adcs	r1, r0
 8004fba:	200b      	movs	r0, #11
 8004fbc:	b2c9      	uxtb	r1, r1
 8004fbe:	f7fb fb1f 	bl	8000600 <_test_assert>
 8004fc2:	2800      	cmp	r0, #0
 8004fc4:	d000      	beq.n	8004fc8 <heap1_execute.lto_priv.110+0x228>
 8004fc6:	e6ff      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
  test_assert(12, n == sz, "size changed");
 8004fc8:	9b00      	ldr	r3, [sp, #0]
 8004fca:	9a01      	ldr	r2, [sp, #4]
 8004fcc:	300c      	adds	r0, #12
 8004fce:	1a99      	subs	r1, r3, r2
 8004fd0:	424b      	negs	r3, r1
 8004fd2:	4159      	adcs	r1, r3
 8004fd4:	b2c9      	uxtb	r1, r1
 8004fd6:	f7fb fb13 	bl	8000600 <_test_assert>
 8004fda:	e6f5      	b.n	8004dc8 <heap1_execute.lto_priv.110+0x28>
 8004fdc:	ffffff00 	.word	0xffffff00
 8004fe0:	20001148 	.word	0x20001148
 8004fe4:	46c0      	nop			; (mov r8, r8)
 8004fe6:	46c0      	nop			; (mov r8, r8)
 8004fe8:	46c0      	nop			; (mov r8, r8)
 8004fea:	46c0      	nop			; (mov r8, r8)
 8004fec:	46c0      	nop			; (mov r8, r8)
 8004fee:	46c0      	nop			; (mov r8, r8)

08004ff0 <heap1_setup.lto_priv.109>:
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8004ff0:	20cc      	movs	r0, #204	; 0xcc
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8004ff2:	2200      	movs	r2, #0
 8004ff4:	4b06      	ldr	r3, [pc, #24]	; (8005010 <heap1_setup.lto_priv.109+0x20>)
  heapp->h_free.h.u.next = hp;
 8004ff6:	4907      	ldr	r1, [pc, #28]	; (8005014 <heap1_setup.lto_priv.109+0x24>)
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8004ff8:	00c0      	lsls	r0, r0, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8004ffa:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 8004ffc:	600a      	str	r2, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
 8004ffe:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005000:	1c19      	adds	r1, r3, #0
 8005002:	3110      	adds	r1, #16
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8005004:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8005006:	60da      	str	r2, [r3, #12]
 8005008:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 800500a:	6159      	str	r1, [r3, #20]
 800500c:	619a      	str	r2, [r3, #24]
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}
 800500e:	4770      	bx	lr
 8005010:	20001148 	.word	0x20001148
 8005014:	200006c0 	.word	0x200006c0
 8005018:	46c0      	nop			; (mov r8, r8)
 800501a:	46c0      	nop			; (mov r8, r8)
 800501c:	46c0      	nop			; (mov r8, r8)
 800501e:	46c0      	nop			; (mov r8, r8)

08005020 <evt3_execute.lto_priv.108>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8005020:	b538      	push	{r3, r4, r5, lr}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8005022:	4c47      	ldr	r4, [pc, #284]	; (8005140 <evt3_execute.lto_priv.108+0x120>)
 8005024:	69a2      	ldr	r2, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005026:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8005028:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800502a:	2b00      	cmp	r3, #0
 800502c:	d107      	bne.n	800503e <evt3_execute.lto_priv.108+0x1e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800502e:	b662      	cpsie	i
 8005030:	2101      	movs	r1, #1

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
 8005032:	2001      	movs	r0, #1
 8005034:	f7fb fae4 	bl	8000600 <_test_assert>
 8005038:	1e01      	subs	r1, r0, #0
 800503a:	d00e      	beq.n	800505a <evt3_execute.lto_priv.108+0x3a>
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
}
 800503c:	bd38      	pop	{r3, r4, r5, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 800503e:	4259      	negs	r1, r3
 8005040:	4019      	ands	r1, r3
  ctp->p_epending &= ~m;
 8005042:	438b      	bics	r3, r1
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8005044:	1c08      	adds	r0, r1, #0
  ctp->p_epending &= ~m;
 8005046:	6353      	str	r3, [r2, #52]	; 0x34
 8005048:	b662      	cpsie	i
 800504a:	4241      	negs	r1, r0
 800504c:	4141      	adcs	r1, r0

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
 800504e:	2001      	movs	r0, #1
 8005050:	b2c9      	uxtb	r1, r1
 8005052:	f7fb fad5 	bl	8000600 <_test_assert>
 8005056:	1e01      	subs	r1, r0, #0
 8005058:	d1f0      	bne.n	800503c <evt3_execute.lto_priv.108+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800505a:	69a3      	ldr	r3, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800505c:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
 800505e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005060:	2a00      	cmp	r2, #0
 8005062:	d05d      	beq.n	8005120 <evt3_execute.lto_priv.108+0x100>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  ctp->p_epending &= ~m;
 8005064:	6358      	str	r0, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005066:	b662      	cpsie	i
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
 8005068:	2002      	movs	r0, #2
 800506a:	f7fb fac9 	bl	8000600 <_test_assert>
 800506e:	1e01      	subs	r1, r0, #0
 8005070:	d1e4      	bne.n	800503c <evt3_execute.lto_priv.108+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8005072:	69a3      	ldr	r3, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005074:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 8005076:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005078:	3201      	adds	r2, #1
 800507a:	d054      	beq.n	8005126 <evt3_execute.lto_priv.108+0x106>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800507c:	b662      	cpsie	i
 800507e:	3101      	adds	r1, #1
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(3, m == 0, "spurious event");
 8005080:	2003      	movs	r0, #3
 8005082:	f7fb fabd 	bl	8000600 <_test_assert>
 8005086:	2800      	cmp	r0, #0
 8005088:	d1d8      	bne.n	800503c <evt3_execute.lto_priv.108+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800508a:	69a5      	ldr	r5, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800508c:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800508e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8005090:	2b00      	cmp	r3, #0
 8005092:	d108      	bne.n	80050a6 <evt3_execute.lto_priv.108+0x86>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8005094:	3b01      	subs	r3, #1
 8005096:	622b      	str	r3, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8005098:	300a      	adds	r0, #10
 800509a:	210a      	movs	r1, #10
 800509c:	f7fc f908 	bl	80012b0 <chSchGoSleepTimeoutS>
 80050a0:	2800      	cmp	r0, #0
 80050a2:	db43      	blt.n	800512c <evt3_execute.lto_priv.108+0x10c>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 80050a4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80050a6:	4259      	negs	r1, r3
 80050a8:	1c0a      	adds	r2, r1, #0
 80050aa:	401a      	ands	r2, r3
  ctp->p_epending &= ~m;
 80050ac:	4393      	bics	r3, r2
 80050ae:	636b      	str	r3, [r5, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80050b0:	b662      	cpsie	i
 80050b2:	4251      	negs	r1, r2
 80050b4:	4151      	adcs	r1, r2
 80050b6:	b2c9      	uxtb	r1, r1
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
 80050b8:	2004      	movs	r0, #4
 80050ba:	f7fb faa1 	bl	8000600 <_test_assert>
 80050be:	2800      	cmp	r0, #0
 80050c0:	d1bc      	bne.n	800503c <evt3_execute.lto_priv.108+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80050c2:	69a5      	ldr	r5, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80050c4:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80050c6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80050c8:	2b00      	cmp	r3, #0
 80050ca:	d108      	bne.n	80050de <evt3_execute.lto_priv.108+0xbe>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 80050cc:	3b01      	subs	r3, #1
 80050ce:	622b      	str	r3, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80050d0:	300a      	adds	r0, #10
 80050d2:	210a      	movs	r1, #10
 80050d4:	f7fc f8ec 	bl	80012b0 <chSchGoSleepTimeoutS>
 80050d8:	2800      	cmp	r0, #0
 80050da:	db2a      	blt.n	8005132 <evt3_execute.lto_priv.108+0x112>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 80050dc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 80050de:	2200      	movs	r2, #0
 80050e0:	636a      	str	r2, [r5, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80050e2:	b662      	cpsie	i
 80050e4:	4259      	negs	r1, r3
 80050e6:	4159      	adcs	r1, r3
 80050e8:	b2c9      	uxtb	r1, r1
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
 80050ea:	2005      	movs	r0, #5
 80050ec:	f7fb fa88 	bl	8000600 <_test_assert>
 80050f0:	1e05      	subs	r5, r0, #0
 80050f2:	d1a3      	bne.n	800503c <evt3_execute.lto_priv.108+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80050f4:	69a4      	ldr	r4, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80050f6:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80050f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80050fa:	3301      	adds	r3, #1
 80050fc:	d008      	beq.n	8005110 <evt3_execute.lto_priv.108+0xf0>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 80050fe:	2301      	movs	r3, #1
 8005100:	425b      	negs	r3, r3
 8005102:	6223      	str	r3, [r4, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8005104:	200b      	movs	r0, #11
 8005106:	210a      	movs	r1, #10
 8005108:	f7fc f8d2 	bl	80012b0 <chSchGoSleepTimeoutS>
 800510c:	2800      	cmp	r0, #0
 800510e:	db13      	blt.n	8005138 <evt3_execute.lto_priv.108+0x118>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 8005110:	2300      	movs	r3, #0
 8005112:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005114:	b662      	cpsie	i
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 8005116:	1c29      	adds	r1, r5, #0
 8005118:	2006      	movs	r0, #6
 800511a:	f7fb fa71 	bl	8000600 <_test_assert>
 800511e:	e78d      	b.n	800503c <evt3_execute.lto_priv.108+0x1c>
 8005120:	b662      	cpsie	i
 8005122:	3101      	adds	r1, #1
 8005124:	e7a0      	b.n	8005068 <evt3_execute.lto_priv.108+0x48>
 8005126:	6358      	str	r0, [r3, #52]	; 0x34
 8005128:	b662      	cpsie	i
 800512a:	e7a9      	b.n	8005080 <evt3_execute.lto_priv.108+0x60>
 800512c:	b662      	cpsie	i
 800512e:	2101      	movs	r1, #1
 8005130:	e7c2      	b.n	80050b8 <evt3_execute.lto_priv.108+0x98>
 8005132:	b662      	cpsie	i
 8005134:	2101      	movs	r1, #1
 8005136:	e7d8      	b.n	80050ea <evt3_execute.lto_priv.108+0xca>
 8005138:	b662      	cpsie	i
 800513a:	3501      	adds	r5, #1
 800513c:	e7eb      	b.n	8005116 <evt3_execute.lto_priv.108+0xf6>
 800513e:	46c0      	nop			; (mov r8, r8)
 8005140:	20000f20 	.word	0x20000f20
 8005144:	46c0      	nop			; (mov r8, r8)
 8005146:	46c0      	nop			; (mov r8, r8)
 8005148:	46c0      	nop			; (mov r8, r8)
 800514a:	46c0      	nop			; (mov r8, r8)
 800514c:	46c0      	nop			; (mov r8, r8)
 800514e:	46c0      	nop			; (mov r8, r8)

08005150 <evt3_setup.lto_priv.107>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 8005150:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8005152:	f7fd fab5 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
}
 8005156:	bd08      	pop	{r3, pc}
 8005158:	46c0      	nop			; (mov r8, r8)
 800515a:	46c0      	nop			; (mov r8, r8)
 800515c:	46c0      	nop			; (mov r8, r8)
 800515e:	46c0      	nop			; (mov r8, r8)

08005160 <evt2_setup.lto_priv.105>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 8005160:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8005162:	f7fd faad 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
}
 8005166:	bd08      	pop	{r3, pc}
 8005168:	46c0      	nop			; (mov r8, r8)
 800516a:	46c0      	nop			; (mov r8, r8)
 800516c:	46c0      	nop			; (mov r8, r8)
 800516e:	46c0      	nop			; (mov r8, r8)

08005170 <evt1_setup.lto_priv.103>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 8005170:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8005172:	f7fd faa5 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
}
 8005176:	bd08      	pop	{r3, pc}
 8005178:	46c0      	nop			; (mov r8, r8)
 800517a:	46c0      	nop			; (mov r8, r8)
 800517c:	46c0      	nop			; (mov r8, r8)
 800517e:	46c0      	nop			; (mov r8, r8)

08005180 <evt2_execute.lto_priv.106>:
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8005180:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005182:	465f      	mov	r7, fp
 8005184:	4656      	mov	r6, sl
 8005186:	464d      	mov	r5, r9
 8005188:	4644      	mov	r4, r8
 800518a:	b4f0      	push	{r4, r5, r6, r7}
 800518c:	b08f      	sub	sp, #60	; 0x3c
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800518e:	b672      	cpsid	i
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 8005190:	2307      	movs	r3, #7
 8005192:	4ca9      	ldr	r4, [pc, #676]	; (8005438 <evt2_execute.lto_priv.106+0x2b8>)
 8005194:	69a2      	ldr	r2, [r4, #24]
 8005196:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8005198:	430b      	orrs	r3, r1
 800519a:	6353      	str	r3, [r2, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800519c:	b662      	cpsie	i

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
 800519e:	f7fd fa9f 	bl	80026e0 <chEvtWaitOne.constprop.35>
  test_assert(1, m == 1, "single event error");
 80051a2:	1e41      	subs	r1, r0, #1
 80051a4:	424b      	negs	r3, r1
 80051a6:	414b      	adcs	r3, r1
 80051a8:	2001      	movs	r0, #1
 80051aa:	b2d9      	uxtb	r1, r3
 80051ac:	f7fb fa28 	bl	8000600 <_test_assert>
 80051b0:	2800      	cmp	r0, #0
 80051b2:	d006      	beq.n	80051c2 <evt2_execute.lto_priv.106+0x42>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 80051b4:	b00f      	add	sp, #60	; 0x3c
 80051b6:	bc3c      	pop	{r2, r3, r4, r5}
 80051b8:	4690      	mov	r8, r2
 80051ba:	4699      	mov	r9, r3
 80051bc:	46a2      	mov	sl, r4
 80051be:	46ab      	mov	fp, r5
 80051c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 80051c2:	f7fd fa8d 	bl	80026e0 <chEvtWaitOne.constprop.35>
  test_assert(2, m == 2, "single event error");
 80051c6:	1e81      	subs	r1, r0, #2
 80051c8:	424b      	negs	r3, r1
 80051ca:	414b      	adcs	r3, r1
 80051cc:	2002      	movs	r0, #2
 80051ce:	b2d9      	uxtb	r1, r3
 80051d0:	f7fb fa16 	bl	8000600 <_test_assert>
 80051d4:	2800      	cmp	r0, #0
 80051d6:	d1ed      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtWaitOne(ALL_EVENTS);
 80051d8:	f7fd fa82 	bl	80026e0 <chEvtWaitOne.constprop.35>
  test_assert(3, m == 4, "single event error");
 80051dc:	1f01      	subs	r1, r0, #4
 80051de:	424b      	negs	r3, r1
 80051e0:	414b      	adcs	r3, r1
 80051e2:	2003      	movs	r0, #3
 80051e4:	b2d9      	uxtb	r1, r3
 80051e6:	f7fb fa0b 	bl	8000600 <_test_assert>
 80051ea:	2800      	cmp	r0, #0
 80051ec:	d1e2      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80051ee:	f7fd fa67 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
  test_assert(4, m == 0, "stuck event");
 80051f2:	4241      	negs	r1, r0
 80051f4:	4141      	adcs	r1, r0
 80051f6:	2004      	movs	r0, #4
 80051f8:	b2c9      	uxtb	r1, r1
 80051fa:	f7fb fa01 	bl	8000600 <_test_assert>
 80051fe:	2800      	cmp	r0, #0
 8005200:	d1d8      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8005202:	f7fc f9bd 	bl	8001580 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005206:	b672      	cpsid	i
 8005208:	4b8c      	ldr	r3, [pc, #560]	; (800543c <evt2_execute.lto_priv.106+0x2bc>)
 800520a:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 800520c:	469a      	mov	sl, r3
 800520e:	b2bf      	uxth	r7, r7
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005210:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005212:	498b      	ldr	r1, [pc, #556]	; (8005440 <evt2_execute.lto_priv.106+0x2c0>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005214:	69a3      	ldr	r3, [r4, #24]
 8005216:	4689      	mov	r9, r1
 8005218:	21a4      	movs	r1, #164	; 0xa4
 800521a:	689a      	ldr	r2, [r3, #8]
 800521c:	4e89      	ldr	r6, [pc, #548]	; (8005444 <evt2_execute.lto_priv.106+0x2c4>)
 800521e:	3a01      	subs	r2, #1
 8005220:	0049      	lsls	r1, r1, #1
 8005222:	9300      	str	r3, [sp, #0]
 8005224:	1c30      	adds	r0, r6, #0
 8005226:	464b      	mov	r3, r9
 8005228:	f7fb fbca 	bl	80009c0 <chThdCreateStatic>
 800522c:	4d86      	ldr	r5, [pc, #536]	; (8005448 <evt2_execute.lto_priv.106+0x2c8>)
 800522e:	6028      	str	r0, [r5, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8005230:	f7fd fa56 	bl	80026e0 <chEvtWaitOne.constprop.35>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8005234:	1c39      	adds	r1, r7, #0
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8005236:	3737      	adds	r7, #55	; 0x37

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8005238:	3132      	adds	r1, #50	; 0x32
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800523a:	4680      	mov	r8, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800523c:	b289      	uxth	r1, r1
 800523e:	b2ba      	uxth	r2, r7
 8005240:	2005      	movs	r0, #5
 8005242:	f7fb f98d 	bl	8000560 <_test_assert_time_window>
 8005246:	2800      	cmp	r0, #0
 8005248:	d1b4      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_assert(6, m == 1, "single event error");
 800524a:	4641      	mov	r1, r8
 800524c:	3901      	subs	r1, #1
 800524e:	424a      	negs	r2, r1
 8005250:	414a      	adcs	r2, r1
 8005252:	3006      	adds	r0, #6
 8005254:	b2d1      	uxtb	r1, r2
 8005256:	f7fb f9d3 	bl	8000600 <_test_assert>
 800525a:	2800      	cmp	r0, #0
 800525c:	d1aa      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800525e:	f7fd fa2f 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
  test_assert(7, m == 0, "stuck event");
 8005262:	4241      	negs	r1, r0
 8005264:	4141      	adcs	r1, r0
 8005266:	2007      	movs	r0, #7
 8005268:	b2c9      	uxtb	r1, r1
 800526a:	f7fb f9c9 	bl	8000600 <_test_assert>
 800526e:	2800      	cmp	r0, #0
 8005270:	d1a0      	bne.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_wait_threads();
 8005272:	f7fb fee5 	bl	8001040 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005276:	b672      	cpsid	i
 8005278:	2305      	movs	r3, #5
 800527a:	69a2      	ldr	r2, [r4, #24]
 800527c:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800527e:	430b      	orrs	r3, r1
 8005280:	6353      	str	r3, [r2, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005282:	b662      	cpsie	i

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitAny(ALL_EVENTS);
 8005284:	f7fd fa44 	bl	8002710 <chEvtWaitAny.constprop.34>
  test_assert(8, m == 5, "unexpected pending bit");
 8005288:	1f41      	subs	r1, r0, #5
 800528a:	424b      	negs	r3, r1
 800528c:	414b      	adcs	r3, r1
 800528e:	2008      	movs	r0, #8
 8005290:	b2d9      	uxtb	r1, r3
 8005292:	f7fb f9b5 	bl	8000600 <_test_assert>
 8005296:	2800      	cmp	r0, #0
 8005298:	d000      	beq.n	800529c <evt2_execute.lto_priv.106+0x11c>
 800529a:	e78b      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800529c:	f7fd fa10 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
  test_assert(9, m == 0, "stuck event");
 80052a0:	4241      	negs	r1, r0
 80052a2:	4141      	adcs	r1, r0
 80052a4:	2009      	movs	r0, #9
 80052a6:	b2c9      	uxtb	r1, r1
 80052a8:	f7fb f9aa 	bl	8000600 <_test_assert>
 80052ac:	2800      	cmp	r0, #0
 80052ae:	d000      	beq.n	80052b2 <evt2_execute.lto_priv.106+0x132>
 80052b0:	e780      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 80052b2:	f7fc f965 	bl	8001580 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80052b6:	b672      	cpsid	i
 80052b8:	4653      	mov	r3, sl
 80052ba:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 80052bc:	b2bf      	uxth	r7, r7
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80052be:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80052c0:	21a4      	movs	r1, #164	; 0xa4
 80052c2:	69a3      	ldr	r3, [r4, #24]
 80052c4:	0049      	lsls	r1, r1, #1
 80052c6:	689a      	ldr	r2, [r3, #8]
 80052c8:	1c30      	adds	r0, r6, #0
 80052ca:	3a01      	subs	r2, #1
 80052cc:	9300      	str	r3, [sp, #0]
 80052ce:	464b      	mov	r3, r9
 80052d0:	f7fb fb76 	bl	80009c0 <chThdCreateStatic>
 80052d4:	6028      	str	r0, [r5, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80052d6:	f7fd fa1b 	bl	8002710 <chEvtWaitAny.constprop.34>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80052da:	1c39      	adds	r1, r7, #0
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80052dc:	1c3a      	adds	r2, r7, #0

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80052de:	3132      	adds	r1, #50	; 0x32
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80052e0:	3237      	adds	r2, #55	; 0x37
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80052e2:	4680      	mov	r8, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80052e4:	b289      	uxth	r1, r1
 80052e6:	b292      	uxth	r2, r2
 80052e8:	200a      	movs	r0, #10
 80052ea:	f7fb f939 	bl	8000560 <_test_assert_time_window>
 80052ee:	2800      	cmp	r0, #0
 80052f0:	d000      	beq.n	80052f4 <evt2_execute.lto_priv.106+0x174>
 80052f2:	e75f      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_assert(11, m == 1, "single event error");
 80052f4:	4641      	mov	r1, r8
 80052f6:	3901      	subs	r1, #1
 80052f8:	424a      	negs	r2, r1
 80052fa:	414a      	adcs	r2, r1
 80052fc:	300b      	adds	r0, #11
 80052fe:	b2d1      	uxtb	r1, r2
 8005300:	f7fb f97e 	bl	8000600 <_test_assert>
 8005304:	2800      	cmp	r0, #0
 8005306:	d000      	beq.n	800530a <evt2_execute.lto_priv.106+0x18a>
 8005308:	e754      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800530a:	f7fd f9d9 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
  test_assert(12, m == 0, "stuck event");
 800530e:	4241      	negs	r1, r0
 8005310:	4141      	adcs	r1, r0
 8005312:	200c      	movs	r0, #12
 8005314:	b2c9      	uxtb	r1, r1
 8005316:	f7fb f973 	bl	8000600 <_test_assert>
 800531a:	1e07      	subs	r7, r0, #0
 800531c:	d000      	beq.n	8005320 <evt2_execute.lto_priv.106+0x1a0>
 800531e:	e749      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_wait_threads();
 8005320:	f7fb fe8e 	bl	8001040 <test_wait_threads>
 8005324:	4b49      	ldr	r3, [pc, #292]	; (800544c <evt2_execute.lto_priv.106+0x2cc>)
 8005326:	601b      	str	r3, [r3, #0]
 8005328:	4699      	mov	r9, r3
 800532a:	4b49      	ldr	r3, [pc, #292]	; (8005450 <evt2_execute.lto_priv.106+0x2d0>)
 800532c:	4698      	mov	r8, r3
 800532e:	601b      	str	r3, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005330:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8005332:	ab04      	add	r3, sp, #16
 8005334:	469b      	mov	fp, r3
 8005336:	464b      	mov	r3, r9
 8005338:	681b      	ldr	r3, [r3, #0]
  esp->es_next     = elp;
 800533a:	465a      	mov	r2, fp
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800533c:	9304      	str	r3, [sp, #16]
  esp->es_next     = elp;
 800533e:	464b      	mov	r3, r9
 8005340:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 8005342:	465b      	mov	r3, fp
 8005344:	69a2      	ldr	r2, [r4, #24]
 8005346:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8005348:	465a      	mov	r2, fp
 800534a:	2301      	movs	r3, #1
 800534c:	6093      	str	r3, [r2, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 800534e:	2301      	movs	r3, #1
 8005350:	425b      	negs	r3, r3
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8005352:	60d7      	str	r7, [r2, #12]
  elp->el_wflags   = wflags;
 8005354:	6113      	str	r3, [r2, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005356:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005358:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800535a:	aa09      	add	r2, sp, #36	; 0x24
 800535c:	4692      	mov	sl, r2
 800535e:	4642      	mov	r2, r8
 8005360:	6812      	ldr	r2, [r2, #0]
  esp->es_next     = elp;
 8005362:	4651      	mov	r1, sl
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8005364:	9209      	str	r2, [sp, #36]	; 0x24
  esp->es_next     = elp;
 8005366:	4642      	mov	r2, r8
 8005368:	6011      	str	r1, [r2, #0]
  elp->el_listener = currp;
 800536a:	4652      	mov	r2, sl
 800536c:	69a1      	ldr	r1, [r4, #24]
 800536e:	6051      	str	r1, [r2, #4]
  elp->el_events   = events;
 8005370:	4651      	mov	r1, sl
 8005372:	2204      	movs	r2, #4
  elp->el_flags    = (eventflags_t)0;
 8005374:	60cf      	str	r7, [r1, #12]

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 8005376:	608a      	str	r2, [r1, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8005378:	610b      	str	r3, [r1, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800537a:	b662      	cpsie	i
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 800537c:	f7fc f900 	bl	8001580 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005380:	b672      	cpsid	i
 8005382:	4b2e      	ldr	r3, [pc, #184]	; (800543c <evt2_execute.lto_priv.106+0x2bc>)
 8005384:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 8005386:	b2bf      	uxth	r7, r7
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005388:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
 800538a:	1c3b      	adds	r3, r7, #0
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800538c:	21a4      	movs	r1, #164	; 0xa4
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 800538e:	3332      	adds	r3, #50	; 0x32
 8005390:	b29b      	uxth	r3, r3
 8005392:	9303      	str	r3, [sp, #12]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005394:	69a3      	ldr	r3, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005396:	1c30      	adds	r0, r6, #0
 8005398:	689a      	ldr	r2, [r3, #8]
 800539a:	4b2e      	ldr	r3, [pc, #184]	; (8005454 <evt2_execute.lto_priv.106+0x2d4>)
 800539c:	3a01      	subs	r2, #1
 800539e:	9300      	str	r3, [sp, #0]
 80053a0:	0049      	lsls	r1, r1, #1
 80053a2:	4b2d      	ldr	r3, [pc, #180]	; (8005458 <evt2_execute.lto_priv.106+0x2d8>)
 80053a4:	f7fb fb0c 	bl	80009c0 <chThdCreateStatic>
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 80053a8:	69a4      	ldr	r4, [r4, #24]
 80053aa:	6028      	str	r0, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80053ac:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80053ae:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80053b0:	2205      	movs	r2, #5
 80053b2:	1c19      	adds	r1, r3, #0
 80053b4:	4011      	ands	r1, r2
 80053b6:	4291      	cmp	r1, r2
 80053b8:	d004      	beq.n	80053c4 <evt2_execute.lto_priv.106+0x244>
    ctp->p_u.ewmask = events;
 80053ba:	6222      	str	r2, [r4, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80053bc:	200b      	movs	r0, #11
 80053be:	f7fb fb2f 	bl	8000a20 <chSchGoSleepS>
 80053c2:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~events;
 80053c4:	2205      	movs	r2, #5
 80053c6:	4393      	bics	r3, r2
 80053c8:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80053ca:	b662      	cpsie	i
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 80053cc:	1c3a      	adds	r2, r7, #0
 80053ce:	3237      	adds	r2, #55	; 0x37
 80053d0:	b292      	uxth	r2, r2
 80053d2:	200d      	movs	r0, #13
 80053d4:	9903      	ldr	r1, [sp, #12]
 80053d6:	f7fb f8c3 	bl	8000560 <_test_assert_time_window>
 80053da:	2800      	cmp	r0, #0
 80053dc:	d000      	beq.n	80053e0 <evt2_execute.lto_priv.106+0x260>
 80053de:	e6e9      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80053e0:	f7fd f96e 	bl	80026c0 <chEvtGetAndClearEvents.constprop.39>
  test_assert(14, m == 0, "stuck event");
 80053e4:	4241      	negs	r1, r0
 80053e6:	4141      	adcs	r1, r0
 80053e8:	200e      	movs	r0, #14
 80053ea:	b2c9      	uxtb	r1, r1
 80053ec:	f7fb f908 	bl	8000600 <_test_assert>
 80053f0:	2800      	cmp	r0, #0
 80053f2:	d000      	beq.n	80053f6 <evt2_execute.lto_priv.106+0x276>
 80053f4:	e6de      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_wait_threads();
 80053f6:	f7fb fe23 	bl	8001040 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 80053fa:	4648      	mov	r0, r9
 80053fc:	4659      	mov	r1, fp
 80053fe:	f7fb fa07 	bl	8000810 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8005402:	4640      	mov	r0, r8
 8005404:	4651      	mov	r1, sl
 8005406:	f7fb fa03 	bl	8000810 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800540a:	464b      	mov	r3, r9
 800540c:	681a      	ldr	r2, [r3, #0]
 800540e:	200f      	movs	r0, #15
 8005410:	1ad1      	subs	r1, r2, r3
 8005412:	424a      	negs	r2, r1
 8005414:	414a      	adcs	r2, r1
 8005416:	b2d1      	uxtb	r1, r2
 8005418:	f7fb f8f2 	bl	8000600 <_test_assert>
 800541c:	2800      	cmp	r0, #0
 800541e:	d000      	beq.n	8005422 <evt2_execute.lto_priv.106+0x2a2>
 8005420:	e6c8      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8005422:	4643      	mov	r3, r8
 8005424:	681a      	ldr	r2, [r3, #0]
 8005426:	3010      	adds	r0, #16
 8005428:	1ad1      	subs	r1, r2, r3
 800542a:	424a      	negs	r2, r1
 800542c:	414a      	adcs	r2, r1
 800542e:	b2d1      	uxtb	r1, r2
 8005430:	f7fb f8e6 	bl	8000600 <_test_assert>
 8005434:	e6be      	b.n	80051b4 <evt2_execute.lto_priv.106+0x34>
 8005436:	46c0      	nop			; (mov r8, r8)
 8005438:	20000f20 	.word	0x20000f20
 800543c:	40000400 	.word	0x40000400
 8005440:	080054a1 	.word	0x080054a1
 8005444:	200006c0 	.word	0x200006c0
 8005448:	20001090 	.word	0x20001090
 800544c:	200006b0 	.word	0x200006b0
 8005450:	200006b4 	.word	0x200006b4
 8005454:	080055f4 	.word	0x080055f4
 8005458:	08005461 	.word	0x08005461
 800545c:	46c0      	nop			; (mov r8, r8)
 800545e:	46c0      	nop			; (mov r8, r8)

08005460 <thread2>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(thread2, p) {
 8005460:	b508      	push	{r3, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005462:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8005464:	4809      	ldr	r0, [pc, #36]	; (800548c <thread2+0x2c>)
 8005466:	2100      	movs	r1, #0
 8005468:	f7fb fbd2 	bl	8000c10 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800546c:	f7fb fa10 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005470:	b662      	cpsie	i

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8005472:	2032      	movs	r0, #50	; 0x32
 8005474:	f7fc f87c 	bl	8001570 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005478:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 800547a:	4805      	ldr	r0, [pc, #20]	; (8005490 <thread2+0x30>)
 800547c:	2100      	movs	r1, #0
 800547e:	f7fb fbc7 	bl	8000c10 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8005482:	f7fb fa05 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005486:	b662      	cpsie	i
  chEvtBroadcast(&es2);
}
 8005488:	bd08      	pop	{r3, pc}
 800548a:	46c0      	nop			; (mov r8, r8)
 800548c:	200006b0 	.word	0x200006b0
 8005490:	200006b4 	.word	0x200006b4
 8005494:	46c0      	nop			; (mov r8, r8)
 8005496:	46c0      	nop			; (mov r8, r8)
 8005498:	46c0      	nop			; (mov r8, r8)
 800549a:	46c0      	nop			; (mov r8, r8)
 800549c:	46c0      	nop			; (mov r8, r8)
 800549e:	46c0      	nop			; (mov r8, r8)

080054a0 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 80054a0:	b510      	push	{r4, lr}
 80054a2:	1c04      	adds	r4, r0, #0

  chThdSleepMilliseconds(50);
 80054a4:	2032      	movs	r0, #50	; 0x32
 80054a6:	f7fc f863 	bl	8001570 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054aa:	b672      	cpsid	i
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 80054ac:	2101      	movs	r1, #1
 80054ae:	1c20      	adds	r0, r4, #0
 80054b0:	f7fb fb8e 	bl	8000bd0 <chEvtSignalI>
  chSchRescheduleS();
 80054b4:	f7fb f9ec 	bl	8000890 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054b8:	b662      	cpsie	i
  chEvtSignal((thread_t *)p, 1);
}
 80054ba:	bd10      	pop	{r4, pc}
 80054bc:	46c0      	nop			; (mov r8, r8)
 80054be:	46c0      	nop			; (mov r8, r8)

080054c0 <evt1_execute.lto_priv.104>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 80054c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80054c2:	4c2f      	ldr	r4, [pc, #188]	; (8005580 <evt1_execute.lto_priv.104+0xc0>)
 80054c4:	b08b      	sub	sp, #44	; 0x2c
 80054c6:	6024      	str	r4, [r4, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054c8:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80054ca:	6823      	ldr	r3, [r4, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 80054cc:	492d      	ldr	r1, [pc, #180]	; (8005584 <evt1_execute.lto_priv.104+0xc4>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80054ce:	9300      	str	r3, [sp, #0]
  esp->es_next     = elp;
 80054d0:	466b      	mov	r3, sp
 80054d2:	6023      	str	r3, [r4, #0]
  elp->el_listener = currp;
 80054d4:	698b      	ldr	r3, [r1, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80054d6:	2200      	movs	r2, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80054d8:	9301      	str	r3, [sp, #4]
  elp->el_events   = events;
 80054da:	2301      	movs	r3, #1
 80054dc:	9302      	str	r3, [sp, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80054de:	3b02      	subs	r3, #2
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80054e0:	9203      	str	r2, [sp, #12]
  elp->el_wflags   = wflags;
 80054e2:	9304      	str	r3, [sp, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054e4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054e6:	b672      	cpsid	i
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80054e8:	6989      	ldr	r1, [r1, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80054ea:	ad05      	add	r5, sp, #20
  esp->es_next     = elp;
  elp->el_listener = currp;
 80054ec:	6069      	str	r1, [r5, #4]
  elp->el_events   = events;
 80054ee:	2102      	movs	r1, #2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80054f0:	6820      	ldr	r0, [r4, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 80054f2:	60a9      	str	r1, [r5, #8]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80054f4:	9005      	str	r0, [sp, #20]
  esp->es_next     = elp;
 80054f6:	6025      	str	r5, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80054f8:	60ea      	str	r2, [r5, #12]
  elp->el_wflags   = wflags;
 80054fa:	612b      	str	r3, [r5, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054fc:	b662      	cpsie	i
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->es_next);
 80054fe:	6823      	ldr	r3, [r4, #0]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8005500:	2001      	movs	r0, #1
 8005502:	1b19      	subs	r1, r3, r4
 8005504:	1e4b      	subs	r3, r1, #1
 8005506:	4199      	sbcs	r1, r3
 8005508:	b2c9      	uxtb	r1, r1
 800550a:	f7fb f879 	bl	8000600 <_test_assert>
 800550e:	2800      	cmp	r0, #0
 8005510:	d001      	beq.n	8005516 <evt1_execute.lto_priv.104+0x56>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8005512:	b00b      	add	sp, #44	; 0x2c
 8005514:	bdf0      	pop	{r4, r5, r6, r7, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8005516:	1c20      	adds	r0, r4, #0
 8005518:	4669      	mov	r1, sp
 800551a:	f7fb f979 	bl	8000810 <chEvtUnregister>
 800551e:	6823      	ldr	r3, [r4, #0]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8005520:	2002      	movs	r0, #2
 8005522:	1b19      	subs	r1, r3, r4
 8005524:	1e4b      	subs	r3, r1, #1
 8005526:	4199      	sbcs	r1, r3
 8005528:	b2c9      	uxtb	r1, r1
 800552a:	f7fb f869 	bl	8000600 <_test_assert>
 800552e:	2800      	cmp	r0, #0
 8005530:	d1ef      	bne.n	8005512 <evt1_execute.lto_priv.104+0x52>
  chEvtUnregister(&es1, &el2);
 8005532:	1c20      	adds	r0, r4, #0
 8005534:	1c29      	adds	r1, r5, #0
 8005536:	f7fb f96b 	bl	8000810 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800553a:	6823      	ldr	r3, [r4, #0]
 800553c:	2003      	movs	r0, #3
 800553e:	1b19      	subs	r1, r3, r4
 8005540:	424b      	negs	r3, r1
 8005542:	414b      	adcs	r3, r1
 8005544:	b2d9      	uxtb	r1, r3
 8005546:	f7fb f85b 	bl	8000600 <_test_assert>
 800554a:	2800      	cmp	r0, #0
 800554c:	d1e1      	bne.n	8005512 <evt1_execute.lto_priv.104+0x52>
 800554e:	2400      	movs	r4, #0
 8005550:	2507      	movs	r5, #7

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8005552:	2601      	movs	r6, #1
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8005554:	4f0c      	ldr	r7, [pc, #48]	; (8005588 <evt1_execute.lto_priv.104+0xc8>)
 8005556:	e002      	b.n	800555e <evt1_execute.lto_priv.104+0x9e>
    }
    eid++;
 8005558:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800555a:	2d00      	cmp	r5, #0
 800555c:	d00b      	beq.n	8005576 <evt1_execute.lto_priv.104+0xb6>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800555e:	1c2b      	adds	r3, r5, #0
 8005560:	40e3      	lsrs	r3, r4
 8005562:	421e      	tst	r6, r3
 8005564:	d0f8      	beq.n	8005558 <evt1_execute.lto_priv.104+0x98>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8005566:	1c33      	adds	r3, r6, #0
 8005568:	40a3      	lsls	r3, r4
 800556a:	439d      	bics	r5, r3
 800556c:	00a3      	lsls	r3, r4, #2
      handlers[eid](eid);
 800556e:	59db      	ldr	r3, [r3, r7]
 8005570:	1c20      	adds	r0, r4, #0
 8005572:	4798      	blx	r3
 8005574:	e7f0      	b.n	8005558 <evt1_execute.lto_priv.104+0x98>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
 8005576:	4905      	ldr	r1, [pc, #20]	; (800558c <evt1_execute.lto_priv.104+0xcc>)
 8005578:	2004      	movs	r0, #4
 800557a:	f7fb f811 	bl	80005a0 <_test_assert_sequence>
 800557e:	e7c8      	b.n	8005512 <evt1_execute.lto_priv.104+0x52>
 8005580:	200006b0 	.word	0x200006b0
 8005584:	20000f20 	.word	0x20000f20
 8005588:	080062b0 	.word	0x080062b0
 800558c:	080061e0 	.word	0x080061e0

08005590 <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8005590:	b508      	push	{r3, lr}
 8005592:	2043      	movs	r0, #67	; 0x43
 8005594:	f7fb f84c 	bl	8000630 <test_emit_token>
 8005598:	bd08      	pop	{r3, pc}
 800559a:	46c0      	nop			; (mov r8, r8)
 800559c:	46c0      	nop			; (mov r8, r8)
 800559e:	46c0      	nop			; (mov r8, r8)

080055a0 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80055a0:	b508      	push	{r3, lr}
 80055a2:	2042      	movs	r0, #66	; 0x42
 80055a4:	f7fb f844 	bl	8000630 <test_emit_token>
 80055a8:	bd08      	pop	{r3, pc}
 80055aa:	46c0      	nop			; (mov r8, r8)
 80055ac:	46c0      	nop			; (mov r8, r8)
 80055ae:	46c0      	nop			; (mov r8, r8)

080055b0 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80055b0:	b508      	push	{r3, lr}
 80055b2:	2041      	movs	r0, #65	; 0x41
 80055b4:	f7fb f83c 	bl	8000630 <test_emit_token>
 80055b8:	bd08      	pop	{r3, pc}
 80055ba:	46c0      	nop			; (mov r8, r8)
 80055bc:	46c0      	nop			; (mov r8, r8)
 80055be:	46c0      	nop			; (mov r8, r8)
 80055c0:	080003d2 	.word	0x080003d2
 80055c4:	080003b2 	.word	0x080003b2
 80055c8:	080003b2 	.word	0x080003b2
 80055cc:	080003d6 	.word	0x080003d6
 80055d0:	080003a8 	.word	0x080003a8
 80055d4:	080003a0 	.word	0x080003a0
 80055d8:	080003b2 	.word	0x080003b2
 80055dc:	080003a8 	.word	0x080003a8
 80055e0:	656c6469 	.word	0x656c6469
 80055e4:	00000000 	.word	0x00000000
 80055e8:	00000a0d 	.word	0x00000a0d
 80055ec:	00000000 	.word	0x00000000
 80055f0:	00000042 	.word	0x00000042
 80055f4:	00000041 	.word	0x00000041
 80055f8:	00000044 	.word	0x00000044
 80055fc:	00000043 	.word	0x00000043
 8005600:	44434241 	.word	0x44434241
 8005604:	00000045 	.word	0x00000045
	...

08005610 <testmtx4>:
 8005610:	08006058 080016b1 00000000 08001711     X`..............

08005620 <testmtx5>:
 8005620:	08006048 080016a1 00000000 08003931     H`..........19..

08005630 <testmtx6>:
 8005630:	08006030 08002fe1 00000000 08003851     0`.../......Q8..

08005640 <testmtx7>:
 8005640:	08006018 08002fc1 00000000 08003761     .`.../......a7..

08005650 <testmtx8>:
 8005650:	08006004 08002f91 00000000 080035b1     .`.../.......5..

08005660 <patternmsg>:
 8005660:	08005940 00000000 00000000 00000000     @Y..............

08005670 <patterndyn>:
 8005670:	080058d0 080058e0 080058f0 00000000     .X...X...X......

08005680 <testbmk11>:
 8005680:	08005d24 08003a11 00000000 08003ac1     $]...:.......:..

08005690 <ch_debug>:
 8005690:	6e69616d 18001600 08440204 1814100c     main......D.....
 80056a0:	1e1d1c00 00000000 00000000 00000000     ................

080056b0 <patternevt>:
 80056b0:	080059f0 080056c0 08005a00 00000000     .Y...V...Z......

080056c0 <testevt2>:
 80056c0:	08005f94 08005161 00000000 08005181     ._..aQ.......Q..

080056d0 <testsys2>:
 80056d0:	08006180 00000000 00000000 08003a41     .a..........A:..

080056e0 <testsys3>:
 80056e0:	0800616c 00000000 00000000 080042b1     la...........B..

080056f0 <testsys1>:
 80056f0:	0800619c 00000000 00000000 08004321     .a..........!C..

08005700 <vmt>:
 8005700:	08001401 08001501 08001471 08001561     ........q...a...
 8005710:	08001461 08001551 080013f1 080014f1     a...Q...........

08005720 <testsem1>:
 8005720:	080060f0 08001701 00000000 08001f41     .`..........A...

08005730 <testsem2>:
 8005730:	080060dc 080016f1 00000000 08001de1     .`..............

08005740 <testsem3>:
 8005740:	080060bc 080016e1 00000000 08001d31     .`..........1...

08005750 <testsem4>:
 8005750:	08006098 00000000 00000000 08001c21     .`..........!...

08005760 <testheap1>:
 8005760:	08005f58 08004ff1 00000000 08004da1     X_...O.......M..

08005770 <testthd2>:
 8005770:	08006134 00000000 00000000 080020c1     4a........... ..

08005780 <testbmk7>:
 8005780:	08005dbc 08003a31 00000000 08003e21     .]..1:......!>..

08005790 <testbmk3>:
 8005790:	08005e40 00000000 00000000 080040e1     @^...........@..

080057a0 <testbmk10>:
 80057a0:	08005d48 00000000 00000000 08003b61     H]..........a;..

080057b0 <testbmk4>:
 80057b0:	08005e24 00000000 00000000 08003fd1     $^...........?..

080057c0 <testbmk12>:
 80057c0:	08005d04 08003a01 00000000 08003a51     .]...:......Q:..

080057d0 <testbmk13>:
 80057d0:	08005ce8 00000000 00000000 08002431     .\..........1$..

080057e0 <testbmk1>:
 80057e0:	08005e70 00000000 00000000 08004241     p^..........AB..

080057f0 <testbmk2>:
 80057f0:	08005e58 00000000 00000000 080041d1     X^...........A..

08005800 <testbmk5>:
 8005800:	08005e04 00000000 00000000 08003f51     .^..........Q?..

08005810 <testbmk6>:
 8005810:	08005de4 00000000 00000000 08003d71     .]..........q=..

08005820 <patternsys>:
 8005820:	080056f0 080056d0 080056e0 00000000     .V...V...V......

08005830 <testbmk8>:
 8005830:	08005d90 00000000 00000000 08003c81     .]...........<..

08005840 <testbmk9>:
 8005840:	08005d6c 00000000 00000000 08003be1     l]...........;..

08005850 <patternbmk>:
 8005850:	080057e0 080057f0 08005790 080057b0     .W...W...W...W..
 8005860:	08005800 08005810 08005780 08005830     .X...X...W..0X..
 8005870:	08005840 080057a0 08005680 080057c0     @X...W...V...W..
 8005880:	080057d0 00000000 00000000 00000000     .W..............

08005890 <patterns>:
 8005890:	08005820 08005950 080059d0 08005a10      X..PY...Y...Z..
 80058a0:	08005660 08005990 080056b0 08005910     `V...Y...V...Y..
 80058b0:	080061d0 08005670 08005920 08005850     .a..pV.. Y..PX..
	...

080058d0 <testdyn1>:
 80058d0:	08005f10 080046d1 00000000 08004cc1     ._...F.......L..

080058e0 <testdyn2>:
 80058e0:	08005ee0 080046b1 00000000 08004bc1     .^...F.......K..

080058f0 <testdyn3>:
 80058f0:	08005eb8 08004681 00000000 080049d1     .^...F.......I..

08005900 <testmbox1>:
 8005900:	08005fd4 08002f61 00000000 08003001     ._..a/.......0..

08005910 <patternheap>:
 8005910:	08005760 00000000 00000000 00000000     `W..............

08005920 <patternqueues>:
 8005920:	08005970 08005980 00000000 00000000     pY...Y..........

08005930 <testpools1>:
 8005930:	08005f3c 08004711 00000000 08004af1     <_...G.......J..

08005940 <testmsg1>:
 8005940:	08005ff4 00000000 00000000 08003531     ._..........15..

08005950 <patternthd>:
 8005950:	080059a0 08005770 080059c0 080059b0     .Y..pW...Y...Y..
	...

08005970 <testqueues1>:
 8005970:	08005ea0 08004651 00000000 08004751     .^..QF......QG..

08005980 <testqueues2>:
 8005980:	08005e88 08004621 00000000 080043f1     .^..!F.......C..

08005990 <patternmbox>:
 8005990:	08005900 00000000 00000000 00000000     .Y..............

080059a0 <testthd1>:
 80059a0:	08006150 00000000 00000000 08001ac1     Pa..............

080059b0 <testthd4>:
 80059b0:	08006108 00000000 00000000 08002221     .a..........!"..

080059c0 <testthd3>:
 80059c0:	08006118 00000000 00000000 080022d1     .a..........."..

080059d0 <patternsem>:
 80059d0:	08005720 08005730 08005740 08005750      W..0W..@W..PW..
	...

080059f0 <testevt1>:
 80059f0:	08005fb0 08005171 00000000 080054c1     ._..qQ.......T..

08005a00 <testevt3>:
 8005a00:	08005f80 08005151 00000000 08005021     ._..QQ......!P..

08005a10 <patternmtx>:
 8005a10:	080061c0 08005610 08005620 08005630     .a...V.. V..0V..
 8005a20:	08005640 08005650 00000000 00000000     @V..PV..........
 8005a30:	6e696c62 0072656b 202d2d2d 74737953     blinker.--- Syst
 8005a40:	203a6d65 00000000 74796220 00007365     em: .... bytes..
 8005a50:	202d2d2d 65726854 203a6461 00000000     --- Thread: ....
 8005a60:	202d2d2d 656d6954 203a2072 00000000     --- Timer : ....
 8005a70:	202d2d2d 616d6553 203a6870 00000000     --- Semaph: ....
 8005a80:	202d2d2d 6e657645 203a5374 00000000     --- EventS: ....
 8005a90:	202d2d2d 6e657645 203a4c74 00000000     --- EventL: ....
 8005aa0:	202d2d2d 6574754d 203a2078 00000000     --- Mutex : ....
 8005ab0:	202d2d2d 646e6f43 203a2e56 00000000     --- CondV.: ....
 8005ac0:	202d2d2d 75657551 203a2065 00000000     --- Queue : ....
 8005ad0:	202d2d2d 6c69614d 203a2e42 00000000     --- MailB.: ....
 8005ae0:	202a2a2a 6e72654b 203a6c65 20202020     *** Kernel:     
 8005af0:	00002020 202a2a2a 706d6f43 64656c69       ..*** Compiled
 8005b00:	2020203a 00002020 202a2a2a 706d6f43     :     ..*** Comp
 8005b10:	72656c69 2020203a 00002020 202a2a2a     iler:     ..*** 
 8005b20:	68637241 63657469 65727574 0000203a     Architecture: ..
 8005b30:	202a2a2a 65726f43 72615620 746e6169     *** Core Variant
 8005b40:	0000203a 202a2a2a 74726f50 666e4920     : ..*** Port Inf
 8005b50:	20203a6f 00002020 202a2a2a 74616c50     o:    ..*** Plat
 8005b60:	6d726f66 2020203a 00002020 202a2a2a     form:     ..*** 
 8005b70:	74736554 616f4220 203a6472 00002020     Test Board:   ..
 8005b80:	202d2d2d 74736554 73614320 00002065     --- Test Case ..
 8005b90:	00002820 202d2d2d 75736552 203a746c      (..--- Result: 
 8005ba0:	4c494146 20455255 00002328 00005b20     FAILURE (#.. [..
 8005bb0:	616e6946 6572206c 746c7573 0000203a     Final result: ..
 8005bc0:	202a2a2a 62696843 2f534f69 74205452     *** ChibiOS/RT t
 8005bd0:	20747365 74697573 00000065 002a2a2a     est suite...***.
 8005be0:	00000029 0000295d 202d2d2d 75736552     )...])..--- Resu
 8005bf0:	203a746c 43435553 00535345 4c494146     lt: SUCCESS.FAIL
 8005c00:	00455255 2e302e33 00367030 206c754a     URE.3.0.0p6.Jul 
 8005c10:	32203220 20353130 3132202d 3a36353a      2 2015 - 21:56:
 8005c20:	00003033 20434347 2e392e34 30322033     30..GCC 4.9.3 20
 8005c30:	33303531 28203330 656c6572 29657361     150303 (release)
 8005c40:	52415b20 6d652f4d 64646562 342d6465      [ARM/embedded-4
 8005c50:	622d395f 636e6172 65722068 69736976     _9-branch revisi
 8005c60:	32206e6f 32323132 00005d30 764d5241     on 221220]..ARMv
 8005c70:	004d2d36 74726f43 4d2d7865 00000030     6-M.Cortex-M0...
 8005c80:	65657250 6974706d 74206e6f 756f7268     Preemption throu
 8005c90:	4e206867 0000494d 334d5453 33304632     gh NMI..STM32F03
 8005ca0:	20387830 72746e45 654c2079 206c6576     0x8 Entry Level 
 8005cb0:	756c6156 694c2065 6420656e 63697665     Value Line devic
 8005cc0:	00007365 694d5453 656f7263 7463656c     es..STMicroelect
 8005cd0:	696e6f72 4e207363 454c4355 30462d4f     ronics NUCLEO-F0
 8005ce0:	38523033 00000000 636e6542 72616d68     30R8....Benchmar
 8005cf0:	52202c6b 66204d41 70746f6f 746e6972     k, RAM footprint
 8005d00:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
 8005d10:	78657475 6c207365 2f6b636f 6f6c6e75     utexes lock/unlo
 8005d20:	00006b63 636e6542 72616d68 73202c6b     ck..Benchmark, s
 8005d30:	70616d65 65726f68 61772073 732f7469     emaphores wait/s
 8005d40:	616e6769 0000006c 636e6542 72616d68     ignal...Benchmar
 8005d50:	76202c6b 75747269 74206c61 72656d69     k, virtual timer
 8005d60:	65732073 65722f74 00746573 636e6542     s set/reset.Benc
 8005d70:	72616d68 49202c6b 51204f2f 65756575     hmark, I/O Queue
 8005d80:	68742073 67756f72 74757068 00000000     s throughput....
 8005d90:	636e6542 72616d68 72202c6b 646e756f     Benchmark, round
 8005da0:	626f7220 63206e69 65746e6f 73207478      robin context s
 8005db0:	63746977 676e6968 00000000 636e6542     witching....Benc
 8005dc0:	72616d68 6d202c6b 20737361 63736572     hmark, mass resc
 8005dd0:	75646568 202c656c 68742035 64616572     hedule, 5 thread
 8005de0:	00000073 636e6542 72616d68 74202c6b     s...Benchmark, t
 8005df0:	61657268 202c7364 61657263 6f206574     hreads, create o
 8005e00:	00796c6e 636e6542 72616d68 74202c6b     nly.Benchmark, t
 8005e10:	61657268 202c7364 6c6c7566 63796320     hreads, full cyc
 8005e20:	0000656c 636e6542 72616d68 63202c6b     le..Benchmark, c
 8005e30:	65746e6f 73207478 63746977 00000068     ontext switch...
 8005e40:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8005e50:	20736567 00003323 636e6542 72616d68     ges #3..Benchmar
 8005e60:	6d202c6b 61737365 20736567 00003223     k, messages #2..
 8005e70:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8005e80:	20736567 00003123 75657551 202c7365     ges #1..Queues, 
 8005e90:	7074756f 71207475 65756575 00000073     output queues...
 8005ea0:	75657551 202c7365 75706e69 75712074     Queues, input qu
 8005eb0:	73657565 00000000 616e7944 2063696d     eues....Dynamic 
 8005ec0:	73495041 6572202c 74736967 61207972     APIs, registry a
 8005ed0:	7220646e 72656665 65636e65 00000073     nd references...
 8005ee0:	616e7944 2063696d 73495041 6874202c     Dynamic APIs, th
 8005ef0:	64616572 72632073 69746165 66206e6f     reads creation f
 8005f00:	206d6f72 6f6d656d 70207972 006c6f6f     rom memory pool.
 8005f10:	616e7944 2063696d 73495041 6874202c     Dynamic APIs, th
 8005f20:	64616572 72632073 69746165 66206e6f     reads creation f
 8005f30:	206d6f72 70616568 00000000 6f6d654d     rom heap....Memo
 8005f40:	50207972 736c6f6f 7571202c 2f657565     ry Pools, queue/
 8005f50:	75716564 00657565 70616548 6c61202c     dequeue.Heap, al
 8005f60:	61636f6c 6e6f6974 646e6120 61726620     location and fra
 8005f70:	6e656d67 69746174 74206e6f 00747365     gmentation test.
 8005f80:	6e657645 202c7374 656d6974 7374756f     Events, timeouts
 8005f90:	00000000 6e657645 202c7374 74696177     ....Events, wait
 8005fa0:	646e6120 6f726220 61636461 00007473      and broadcast..
 8005fb0:	6e657645 202c7374 69676572 61727473     Events, registra
 8005fc0:	6e6f6974 646e6120 73696420 63746170     tion and dispatc
 8005fd0:	00000068 6c69614d 65786f62 71202c73     h...Mailboxes, q
 8005fe0:	69756575 6120676e 7420646e 6f656d69     ueuing and timeo
 8005ff0:	00737475 7373654d 73656761 6f6c202c     uts.Messages, lo
 8006000:	0000706f 646e6f43 2c726156 6f6f6220     op..CondVar, boo
 8006010:	74207473 00747365 646e6f43 2c726156     st test.CondVar,
 8006020:	6f726220 61636461 74207473 00747365      broadcast test.
 8006030:	646e6f43 2c726156 67697320 206c616e     CondVar, signal 
 8006040:	74736574 00000000 6574754d 2c736578     test....Mutexes,
 8006050:	61747320 00737574 6574754d 2c736578      status.Mutexes,
 8006060:	69727020 7469726f 65722079 6e727574      priority return
 8006070:	00000000 6574754d 2c736578 69727020     ....Mutexes, pri
 8006080:	7469726f 6e652079 75657571 20676e69     ority enqueuing 
 8006090:	74736574 00000000 616e6942 53207972     test....Binary S
 80060a0:	70616d65 65726f68 66202c73 74636e75     emaphores, funct
 80060b0:	616e6f69 7974696c 00000000 616d6553     ionality....Sema
 80060c0:	726f6870 202c7365 6d6f7461 73206369     phores, atomic s
 80060d0:	616e6769 61772d6c 00007469 616d6553     ignal-wait..Sema
 80060e0:	726f6870 202c7365 656d6974 0074756f     phores, timeout.
 80060f0:	616d6553 726f6870 202c7365 75716e65     Semaphores, enqu
 8006100:	6e697565 00000067 65726854 2c736461     euing...Threads,
 8006110:	6c656420 00737961 65726854 2c736461      delays.Threads,
 8006120:	69727020 7469726f 68632079 65676e61      priority change
 8006130:	00000000 65726854 2c736461 716e6520     ....Threads, enq
 8006140:	69756575 7420676e 20747365 00003223     ueuing test #2..
 8006150:	65726854 2c736461 716e6520 69756575     Threads, enqueui
 8006160:	7420676e 20747365 00003123 74737953     ng test #1..Syst
 8006170:	202c6d65 65746e69 74697267 00000079     em, integrity...
 8006180:	74737953 202c6d65 65746e69 70757272     System, interrup
 8006190:	68207374 6c646e61 00676e69 74737953     ts handling.Syst
 80061a0:	202c6d65 74697263 6c616369 6e6f7a20     em, critical zon
 80061b0:	00007365 00000000 00000000 00000000     es..............

080061c0 <testmtx1>:
 80061c0:	08006074 080016d1 00000000 080019c1     t`..............

080061d0 <patternpools>:
 80061d0:	08005930 00000000 00000000 00000000     0Y..............
 80061e0:	00434241 00000000 00000000 00000000     ABC.............
 80061f0:	202d2d2d 726f6353 203a2065 00000000     --- Score : ....
 8006200:	636f6c20 6e752b6b 6b636f6c 0000532f      lock+unlock/S..
 8006210:	69617720 69732b74 6c616e67 0000532f      wait+signal/S..
 8006220:	6d697420 2f737265 00000053 74796220      timers/S... byt
 8006230:	532f7365 00000000 78746320 2f637773     es/S.... ctxswc/
 8006240:	00000053 72687420 73646165 0000532f     S... threads/S..
 8006250:	73657220 64656863 73656c75 202c532f      reschedules/S, 
 8006260:	00000000 67736d20 2c532f73 00000020     .... msgs/S, ...
 8006270:	44434241 00000000 00000000 00000000     ABCD............

08006280 <wa>:
 8006280:	200006c0 20000808 20000950 20000a98     ... ... P.. ... 
 8006290:	20000be0 00000000 00000000 00000000     ... ............
 80062a0:	00004241 00000000 00000000 00000000     AB..............

080062b0 <evhndl>:
 80062b0:	080055b1 080055a1 08005591              .U...U...U..
